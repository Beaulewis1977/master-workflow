#!/usr/bin/env node

import inquirer from 'inquirer';
import chalk from 'chalk';
import fs from 'fs-extra';
import path from 'path';
import { execa } from 'execa';
import { fileURLToPath } from 'url';

const PROJECT_DIR = process.cwd();
const INSTALL_DIR = path.join(PROJECT_DIR, '.ai-workflow');

const components = {
  claudeCode: { name: 'Claude Code Integration', value: 'claudeCode', checked: false },
  agentOS: { name: 'Agent-OS Planning System', value: 'agentOS', checked: false },
  claudeFlow: { name: 'Claude Flow 2.0 Multi-Agent', value: 'claudeFlow', checked: false },
  tmux: { name: `TMux Orchestrator ${chalk.dim('(24/7 operation)')}`, value: 'tmux', checked: false },
};

class Installer {
  constructor() {
    this.selectedComponents = [];
    this.templateData = {};
    this.SCRIPT_DIR = path.dirname(fileURLToPath(import.meta.url));
  }

  printHeader() {
    console.log(chalk.cyan.bold('\n═══════════════════════════════════════════════════════'));
    console.log(chalk.cyan.bold('  Intelligent Workflow System - Modular Node.js Installer'));
    console.log(chalk.cyan.bold('═══════════════════════════════════════════════════════\n'));
  }

  async showComponentSelection() {
    const { selected } = await inquirer.prompt([
      {
        type: 'checkbox',
        name: 'selected',
        message: 'Select components to install:',
        choices: [
          { name: `Core Workflow System ${chalk.dim('(required)')}`, value: 'core', checked: true, disabled: true },
          new inquirer.Separator(),
          ...Object.values(components)
        ],
        pageSize: 10,
      }
    ]);
    this.selectedComponents = selected;
  }

  summarizeSelection() {
    console.log(chalk.cyan('\nSelected Components:'));
    console.log(chalk.green('  ✓ Core Workflow System'));
    for (const key in components) {
        if (this.selectedComponents.includes(key)) {
            console.log(chalk.green(`  ✓ ${components[key].name}`));
        }
    }
    console.log('');
  }

  async checkDependencies() {
    console.log(chalk.blue('\nChecking dependencies...'));
    try {
      const { stdout } = await execa('node', ['--version']);
      const nodeVersion = stdout.trim().substring(1);
      const majorVersion = parseInt(nodeVersion.split('.')[0], 10);
      if (majorVersion < 18) {
        console.error(chalk.red(`  ✗ Node.js version ${nodeVersion} found, but v18+ is required.`));
        process.exit(1);
      }
    } catch (error) {
      console.error(chalk.red('  ✗ Node.js is not installed. Please install Node.js 18+ and try again.'));
      process.exit(1);
    }
  }

  async createDirectoryStructure() {
    console.log(chalk.blue('Creating directory structure...'));
    await fs.mkdirp(path.join(INSTALL_DIR, 'intelligence-engine'));
    await fs.mkdirp(path.join(INSTALL_DIR, 'bin'));
    if (this.selectedComponents.includes('agentOS')) {
      await fs.mkdirp(path.join(PROJECT_DIR, '.agent-os', 'product', 'docs'));
      await fs.mkdirp(path.join(PROJECT_DIR, '.agent-os', 'specs'));
      await fs.mkdirp(path.join(PROJECT_DIR, '.agent-os', 'plans'));
    }
  }

  async installCoreSystem() {
    console.log(chalk.blue('Installing core system files...'));
    await fs.copy(path.join(this.SCRIPT_DIR, 'intelligence-engine'), path.join(INSTALL_DIR, 'intelligence-engine'));
    await fs.copy(path.join(this.SCRIPT_DIR, 'configs'), path.join(INSTALL_DIR, 'configs'));
  }

  async createCli() {
    console.log(chalk.blue('Creating ai-workflow CLI...'));
    const cliPath = path.join(INSTALL_DIR, 'bin', 'ai-workflow');
    const cliScript = `#!/bin/bash
# Modular AI Workflow CLI (Generated by install.js)
INSTALL_DIR="$(dirname "$(dirname "$(readlink -f "$0" || echo "$0")")")"
CONFIG_FILE="$INSTALL_DIR/installation-config.json"
if [ -f "$CONFIG_FILE" ]; then
    INSTALLER_PATH=$(jq -r '.installerPath' "$CONFIG_FILE" 2>/dev/null || echo "")
else
    INSTALLER_PATH=""
fi
case "$1" in
    add)
        shift
        if [ -z "$1" ]; then echo "Please specify a component to add."; exit 1; fi
        if [ -n "$INSTALLER_PATH" ] && [ -f "$INSTALLER_PATH/install.js" ]; then
            node "$INSTALLER_PATH/install.js" --add "$1"
        else
            echo "Error: Could not find the installer script."
            exit 1
        fi
        ;;
    analyze)
        shift
        node "$INSTALL_DIR/intelligence-engine/complexity-analyzer.js" "$@"
        ;;
    *)
        echo "Unknown command: $1"
        exit 1
        ;;
esac`;
    await fs.writeFile(cliPath, cliScript);
    await fs.chmod(cliPath, '755');
    const symlinkPath = path.join(PROJECT_DIR, 'ai-workflow');
    await fs.remove(symlinkPath).catch(() => {});
    await fs.symlink(cliPath, symlinkPath);
  }

  async saveInstallationConfig() {
    console.log(chalk.blue('Saving installation configuration...'));
    const configFile = path.join(INSTALL_DIR, 'installation-config.json');
    const config = {
        version: "2.0.0",
        components: { core: true, ...this.selectedComponents.reduce((acc, comp) => ({ ...acc, [comp]: true }), {}) },
        installerPath: this.SCRIPT_DIR,
        installedAt: new Date().toISOString(),
    };
    await fs.writeJson(configFile, config, { spaces: 2 });
  }

  async installComponent(name, installFn) {
    if (this.selectedComponents.includes(name)) {
      await installFn.call(this);
    }
  }

  async installAgentOsComponents() {
    // This is now handled by generateDocumentation
  }

  async runAnalysis() {
    console.log(chalk.blue('Analyzing project...'));
    const analyzerPath = path.join(INSTALL_DIR, 'intelligence-engine', 'complexity-analyzer.js');
    const { stdout } = await execa('node', [analyzerPath, PROJECT_DIR]);
    return JSON.parse(stdout);
  }

  async askProjectQuestions(analysis) {
    console.log(chalk.blue('Please answer a few questions:'));
    return inquirer.prompt([
      { type: 'input', name: 'PRODUCT_NAME', message: 'Product name?', default: path.basename(PROJECT_DIR) },
      { type: 'input', name: 'PRODUCT_MISSION', message: 'Product mission?' },
      { type: 'input', name: 'TARGET_AUDIENCE', message: 'Target audience?' },
      { type: 'list', name: 'CLOUD_PROVIDER', message: 'Cloud provider?', choices: ['AWS', 'GCP', 'Azure', 'Other'] },
    ]);
  }

  async processTemplate(templateName, data) {
    const templatePath = path.join(this.SCRIPT_DIR, 'templates', templateName);
    let content = await fs.readFile(templatePath, 'utf8');
    for (const key in data) {
      const value = data[key];
      let displayValue = value;
       if (typeof value === 'object' && value !== null) {
        displayValue = JSON.stringify(value, null, 2);
      }
      content = content.replace(new RegExp(`{{${key}}}`, 'g'), displayValue || '');
    }
    return content;
  }

  async generateDocumentation() {
    console.log(chalk.blue('\nGenerating documentation...'));
    const productDir = path.join(PROJECT_DIR, '.agent-os', 'product');
    const docsDir = path.join(productDir, 'docs');
    await fs.mkdirp(docsDir);

    const templates = ['mission.md', 'roadmap.md', 'decisions.md'];
    const docTemplates = ['ARCHITECTURE.md', 'CONTRIBUTING.md', 'DEPLOYMENT.md'];

    for (const tpl of templates) {
        const content = await this.processTemplate(`${tpl}.template`, this.templateData);
        await fs.writeFile(path.join(productDir, tpl), content);
    }
    for (const tpl of docTemplates) {
        const content = await this.processTemplate(`${tpl}.template`, this.templateData);
        await fs.writeFile(path.join(docsDir, tpl), content);
    }
    console.log(chalk.green.bold('Documentation generated successfully!'));
  }

  async performInstallation(answers) {
    this.templateData = answers;
    if (this.selectedComponents.includes('agentOS')) {
      await this.generateDocumentation();
    }
    await this.createCli();
    await this.saveInstallationConfig();
    console.log(chalk.green.bold('\n✅ Installation Complete!'));
  }

  async run() {
    this.printHeader();
    await this.showComponentSelection();
    await this.checkDependencies();
    await this.createDirectoryStructure();
    await this.installCoreSystem();
    const analysis = await this.runAnalysis();
    const userAnswers = await this.askProjectQuestions(analysis);
    const answers = { ...analysis, ...userAnswers };
    await this.performInstallation(answers);
  }

  async runHeadless(testConfig) {
    this.selectedComponents = testConfig.components || [];
    await this.createDirectoryStructure();
    await this.installCoreSystem();

    // In a test, we can't ask questions, so we use mock analysis and answers.
    // A more advanced test could mock the analyzer's output.
    const analysis = testConfig.mockAnalysis || { factors: {} };
    const answers = { ...analysis, ...testConfig.answers };

    await this.performInstallation(answers);
  }

  async addComponent(componentName) {
    console.log(chalk.blue(`\nAdding component: ${componentName}...`));
    const validComponents = Object.keys(components);
    if (!validComponents.includes(componentName)) {
      process.exit(1);
    }
    const configFile = path.join(INSTALL_DIR, 'installation-config.json');
    if (!await fs.pathExists(configFile)) {
      process.exit(1);
    }
    const config = await fs.readJson(configFile);
    if (config.components[componentName]) {
      return;
    }
    this.selectedComponents = [componentName];
    await this.createDirectoryStructure();
    const installFn = this[`install${componentName.charAt(0).toUpperCase() + componentName.slice(1)}Components`];
    if (installFn) {
        await this.installComponent(componentName, installFn);
    }
    config.components[componentName] = true;
    await fs.writeJson(configFile, config, { spaces: 2 });
    console.log(chalk.green.bold(`\n✅ Component '${componentName}' added successfully!`));
  }
}

const main = async () => {
    const args = process.argv.slice(2);
    const installer = new Installer();
    if (args[0] === '--add' && args[1]) {
        await installer.addComponent(args[1]);
    } else {
        await installer.run();
    }
};

if (import.meta.url.startsWith('file:') && process.argv[1] === new URL(import.meta.url).pathname) {
    main().catch(error => {
        console.error(chalk.red('\nAn unexpected error occurred:'), error);
        process.exit(1);
    });
}

export default Installer;
