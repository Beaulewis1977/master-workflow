/**
 * Performance Monitor - Comprehensive System Performance and Memory Profiling
 * 
 * Advanced monitoring system for the Queen Controller's 10-agent architecture
 * with real-time metrics, memory profiling, and performance analytics.
 * 
 * @module performance-monitor
 * @version 1.0.0
 */

const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

/**
 * Comprehensive performance monitoring and profiling system
 */
class PerformanceMonitor extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.config = {
            // Monitoring intervals
            metricsInterval: options.metricsInterval || 5000, // 5 seconds
            memoryInterval: options.memoryInterval || 10000, // 10 seconds
            detailedInterval: options.detailedInterval || 30000, // 30 seconds
            
            // Data retention
            maxMetricHistory: options.maxMetricHistory || 1000,
            maxEventHistory: options.maxEventHistory || 500,
            maxProfileSamples: options.maxProfileSamples || 100,
            
            // Thresholds for alerts
            memoryWarningThreshold: options.memoryWarningThreshold || 0.8, // 80%
            memoryCriticalThreshold: options.memoryCriticalThreshold || 0.95, // 95%
            cpuWarningThreshold: options.cpuWarningThreshold || 0.7, // 70%
            responseTimeWarningThreshold: options.responseTimeWarningThreshold || 1000, // 1 second
            
            // Profiling options
            enableMemoryProfiling: options.enableMemoryProfiling !== false,
            enableCpuProfiling: options.enableCpuProfiling !== false,
            enableNetworkProfiling: options.enableNetworkProfiling !== false,
            enableGCProfiling: options.enableGCProfiling !== false,
            
            // Reporting
            enableReporting: options.enableReporting !== false,
            reportInterval: options.reportInterval || 300000, // 5 minutes
            reportPath: options.reportPath || './performance-reports'
        };\n        
        // Performance metrics storage
        this.metrics = {\n            system: {\n                startTime: Date.now(),\n                uptime: 0,\n                memoryUsage: {\n                    rss: 0,\n                    heapUsed: 0,\n                    heapTotal: 0,\n                    external: 0,\n                    arrayBuffers: 0\n                },\n                cpuUsage: {\n                    user: 0,\n                    system: 0,\n                    percent: 0\n                },\n                eventLoop: {\n                    delay: 0,\n                    utilization: 0\n                },\n                gcStats: {\n                    totalGCs: 0,\n                    totalTime: 0,\n                    avgTime: 0,\n                    lastGC: null\n                }\n            },\n            application: {\n                requests: {\n                    total: 0,\n                    successful: 0,\n                    failed: 0,\n                    avgResponseTime: 0,\n                    p95ResponseTime: 0,\n                    p99ResponseTime: 0\n                },\n                agents: {\n                    active: 0,\n                    total: 0,\n                    messagesProcessed: 0,\n                    avgMessageLatency: 0\n                },\n                cache: {\n                    hitRate: 0,\n                    memoryUsage: 0,\n                    operations: 0\n                },\n                neural: {\n                    predictions: 0,\n                    trainingIterations: 0,\n                    avgPredictionTime: 0,\n                    memoryUsage: 0\n                }\n            }\n        };\n        \n        // Historical data\n        this.metricHistory = [];\n        this.eventHistory = [];\n        this.profileSamples = [];\n        this.responseTimeHistory = [];\n        \n        // Performance tracking\n        this.activeRequests = new Map();\n        this.lastCpuUsage = null;\n        this.performanceObservers = new Map();\n        \n        // Alert state\n        this.alertState = {\n            memoryWarning: false,\n            memoryCritical: false,\n            cpuWarning: false,\n            responseTimeWarning: false\n        };\n        \n        // Initialize monitoring\n        this.initializeMonitoring();\n        this.startMonitoring();\n        \n        console.log('PERFORMANCE MONITOR: Advanced monitoring system initialized');\n    }\n    \n    /**\n     * Initialize performance monitoring components\n     */\n    initializeMonitoring() {\n        // Initialize performance observers if available\n        this.initializePerformanceObservers();\n        \n        // Initialize GC monitoring if available\n        this.initializeGCMonitoring();\n        \n        // Initialize process monitoring\n        this.initializeProcessMonitoring();\n        \n        // Create report directory\n        this.ensureReportDirectory();\n    }\n    \n    /**\n     * Initialize Node.js performance observers\n     */\n    initializePerformanceObservers() {\n        try {\n            const { performance, PerformanceObserver } = require('perf_hooks');\n            \n            // HTTP request observer\n            if (this.config.enableNetworkProfiling) {\n                const httpObserver = new PerformanceObserver((list) => {\n                    for (const entry of list.getEntries()) {\n                        this.recordHttpMetric(entry);\n                    }\n                });\n                httpObserver.observe({ type: 'http' });\n                this.performanceObservers.set('http', httpObserver);\n            }\n            \n            // Function call observer\n            if (this.config.enableCpuProfiling) {\n                const functionObserver = new PerformanceObserver((list) => {\n                    for (const entry of list.getEntries()) {\n                        this.recordFunctionMetric(entry);\n                    }\n                });\n                functionObserver.observe({ type: 'function' });\n                this.performanceObservers.set('function', functionObserver);\n            }\n            \n            console.log('PERFORMANCE MONITOR: Performance observers initialized');\n            \n        } catch (error) {\n            console.warn('PERFORMANCE MONITOR: Performance observers not available:', error.message);\n        }\n    }\n    \n    /**\n     * Initialize garbage collection monitoring\n     */\n    initializeGCMonitoring() {\n        if (!this.config.enableGCProfiling) return;\n        \n        try {\n            // Try to enable GC monitoring\n            if (global.gc) {\n                this.setupGCHooks();\n                console.log('PERFORMANCE MONITOR: GC monitoring enabled');\n            } else {\n                console.warn('PERFORMANCE MONITOR: GC monitoring not available (run with --expose-gc)');\n            }\n        } catch (error) {\n            console.warn('PERFORMANCE MONITOR: GC monitoring setup failed:', error.message);\n        }\n    }\n    \n    /**\n     * Setup garbage collection hooks\n     */\n    setupGCHooks() {\n        // Hook into process events for GC monitoring\n        if (process.env.NODE_ENV === 'production') {\n            // In production, use less intrusive monitoring\n            setInterval(() => {\n                this.sampleGCStats();\n            }, 60000); // Every minute\n        } else {\n            // In development, more detailed monitoring\n            setInterval(() => {\n                this.detailedGCMonitoring();\n            }, 30000); // Every 30 seconds\n        }\n    }\n    \n    /**\n     * Initialize process-level monitoring\n     */\n    initializeProcessMonitoring() {\n        // Monitor process events\n        process.on('warning', (warning) => {\n            this.recordEvent('process_warning', {\n                name: warning.name,\n                message: warning.message,\n                stack: warning.stack\n            });\n        });\n        \n        process.on('uncaughtException', (error) => {\n            this.recordEvent('uncaught_exception', {\n                message: error.message,\n                stack: error.stack\n            });\n        });\n        \n        process.on('unhandledRejection', (reason, promise) => {\n            this.recordEvent('unhandled_rejection', {\n                reason: reason.toString(),\n                promise: promise.toString()\n            });\n        });\n    }\n    \n    /**\n     * Start monitoring loops\n     */\n    startMonitoring() {\n        // Basic metrics collection\n        setInterval(() => {\n            this.collectBasicMetrics();\n        }, this.config.metricsInterval);\n        \n        // Memory profiling\n        if (this.config.enableMemoryProfiling) {\n            setInterval(() => {\n                this.collectMemoryProfile();\n            }, this.config.memoryInterval);\n        }\n        \n        // Detailed system analysis\n        setInterval(() => {\n            this.collectDetailedMetrics();\n        }, this.config.detailedInterval);\n        \n        // Performance reporting\n        if (this.config.enableReporting) {\n            setInterval(() => {\n                this.generatePerformanceReport();\n            }, this.config.reportInterval);\n        }\n        \n        console.log('PERFORMANCE MONITOR: Monitoring loops started');\n    }\n    \n    /**\n     * Collect basic performance metrics\n     */\n    collectBasicMetrics() {\n        try {\n            const now = Date.now();\n            \n            // System uptime\n            this.metrics.system.uptime = now - this.metrics.system.startTime;\n            \n            // Memory usage\n            const memUsage = process.memoryUsage();\n            this.metrics.system.memoryUsage = {\n                rss: memUsage.rss,\n                heapUsed: memUsage.heapUsed,\n                heapTotal: memUsage.heapTotal,\n                external: memUsage.external,\n                arrayBuffers: memUsage.arrayBuffers || 0\n            };\n            \n            // CPU usage\n            const cpuUsage = process.cpuUsage(this.lastCpuUsage);\n            const totalCpuTime = cpuUsage.user + cpuUsage.system;\n            const elapsedTime = this.config.metricsInterval * 1000; // Convert to microseconds\n            \n            this.metrics.system.cpuUsage = {\n                user: cpuUsage.user,\n                system: cpuUsage.system,\n                percent: (totalCpuTime / elapsedTime) * 100\n            };\n            this.lastCpuUsage = cpuUsage;\n            \n            // Event loop metrics\n            this.collectEventLoopMetrics();\n            \n            // Check for alerts\n            this.checkPerformanceAlerts();\n            \n            // Store historical data\n            this.storeMetricSnapshot(now);\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Basic metrics collection error:', error.message);\n        }\n    }\n    \n    /**\n     * Collect event loop metrics\n     */\n    collectEventLoopMetrics() {\n        try {\n            // Event loop delay measurement\n            const start = process.hrtime.bigint();\n            setImmediate(() => {\n                const delay = Number(process.hrtime.bigint() - start) / 1e6; // Convert to milliseconds\n                this.metrics.system.eventLoop.delay = delay;\n            });\n            \n            // Event loop utilization (if available)\n            if (process.eventLoopUtilization) {\n                const utilization = process.eventLoopUtilization();\n                this.metrics.system.eventLoop.utilization = utilization.utilization * 100;\n            }\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Event loop metrics error:', error.message);\n        }\n    }\n    \n    /**\n     * Collect memory profiling data\n     */\n    collectMemoryProfile() {\n        try {\n            const memUsage = this.metrics.system.memoryUsage;\n            const totalMemory = memUsage.rss;\n            const heapUsed = memUsage.heapUsed;\n            const heapTotal = memUsage.heapTotal;\n            \n            const profile = {\n                timestamp: Date.now(),\n                totalMemory,\n                heapUsed,\n                heapTotal,\n                heapUtilization: (heapUsed / heapTotal) * 100,\n                externalMemory: memUsage.external,\n                arrayBuffers: memUsage.arrayBuffers\n            };\n            \n            this.profileSamples.push(profile);\n            \n            // Trim samples if too many\n            if (this.profileSamples.length > this.config.maxProfileSamples) {\n                this.profileSamples.shift();\n            }\n            \n            // Analyze memory trends\n            this.analyzeMemoryTrends();\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Memory profiling error:', error.message);\n        }\n    }\n    \n    /**\n     * Collect detailed system metrics\n     */\n    collectDetailedMetrics() {\n        try {\n            // Resource usage\n            if (process.resourceUsage) {\n                const resourceUsage = process.resourceUsage();\n                this.metrics.system.resourceUsage = resourceUsage;\n            }\n            \n            // Platform-specific metrics\n            this.collectPlatformMetrics();\n            \n            // V8 heap statistics\n            this.collectV8HeapStats();\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Detailed metrics collection error:', error.message);\n        }\n    }\n    \n    /**\n     * Collect V8 heap statistics\n     */\n    collectV8HeapStats() {\n        try {\n            const v8 = require('v8');\n            const heapStats = v8.getHeapStatistics();\n            const heapSpaceStats = v8.getHeapSpaceStatistics();\n            \n            this.metrics.system.v8Heap = {\n                totalHeapSize: heapStats.total_heap_size,\n                totalHeapSizeExecutable: heapStats.total_heap_size_executable,\n                totalPhysicalSize: heapStats.total_physical_size,\n                totalAvailableSize: heapStats.total_available_size,\n                usedHeapSize: heapStats.used_heap_size,\n                heapSizeLimit: heapStats.heap_size_limit,\n                mallocedMemory: heapStats.malloced_memory,\n                peakMallocedMemory: heapStats.peak_malloced_memory,\n                spaces: heapSpaceStats\n            };\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: V8 heap stats error:', error.message);\n        }\n    }\n    \n    /**\n     * Collect platform-specific metrics\n     */\n    collectPlatformMetrics() {\n        try {\n            const os = require('os');\n            \n            this.metrics.system.platform = {\n                loadAverage: os.loadavg(),\n                freeMemory: os.freemem(),\n                totalMemory: os.totalmem(),\n                uptime: os.uptime(),\n                cpus: os.cpus().length\n            };\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Platform metrics error:', error.message);\n        }\n    }\n    \n    /**\n     * Analyze memory usage trends\n     */\n    analyzeMemoryTrends() {\n        if (this.profileSamples.length < 10) return;\n        \n        const recent = this.profileSamples.slice(-10);\n        const older = this.profileSamples.slice(-20, -10);\n        \n        if (older.length === 0) return;\n        \n        // Calculate trends\n        const recentAvgHeap = recent.reduce((sum, s) => sum + s.heapUsed, 0) / recent.length;\n        const olderAvgHeap = older.reduce((sum, s) => sum + s.heapUsed, 0) / older.length;\n        \n        const heapGrowthRate = (recentAvgHeap - olderAvgHeap) / olderAvgHeap;\n        \n        if (heapGrowthRate > 0.1) { // 10% growth\n            this.recordEvent('memory_trend_warning', {\n                heapGrowthRate: heapGrowthRate * 100,\n                recentAvgHeap,\n                olderAvgHeap\n            });\n        }\n    }\n    \n    /**\n     * Check for performance alerts\n     */\n    checkPerformanceAlerts() {\n        const memUsage = this.metrics.system.memoryUsage;\n        const totalAvailable = this.metrics.system.platform?.totalMemory || (2 * 1024 * 1024 * 1024); // 2GB default\n        const memoryUtilization = memUsage.rss / totalAvailable;\n        const cpuPercent = this.metrics.system.cpuUsage.percent;\n        \n        // Memory alerts\n        if (memoryUtilization > this.config.memoryCriticalThreshold && !this.alertState.memoryCritical) {\n            this.alertState.memoryCritical = true;\n            this.emit('alert', {\n                type: 'memory_critical',\n                level: 'critical',\n                message: `Critical memory usage: ${(memoryUtilization * 100).toFixed(1)}%`,\n                data: { memoryUtilization, memUsage }\n            });\n        } else if (memoryUtilization > this.config.memoryWarningThreshold && !this.alertState.memoryWarning) {\n            this.alertState.memoryWarning = true;\n            this.emit('alert', {\n                type: 'memory_warning',\n                level: 'warning',\n                message: `High memory usage: ${(memoryUtilization * 100).toFixed(1)}%`,\n                data: { memoryUtilization, memUsage }\n            });\n        }\n        \n        // CPU alerts\n        if (cpuPercent > this.config.cpuWarningThreshold && !this.alertState.cpuWarning) {\n            this.alertState.cpuWarning = true;\n            this.emit('alert', {\n                type: 'cpu_warning',\n                level: 'warning',\n                message: `High CPU usage: ${cpuPercent.toFixed(1)}%`,\n                data: { cpuPercent }\n            });\n        }\n        \n        // Reset alerts if conditions improve\n        if (memoryUtilization < this.config.memoryWarningThreshold * 0.9) {\n            this.alertState.memoryWarning = false;\n            this.alertState.memoryCritical = false;\n        }\n        \n        if (cpuPercent < this.config.cpuWarningThreshold * 0.9) {\n            this.alertState.cpuWarning = false;\n        }\n    }\n    \n    /**\n     * Record HTTP performance metric\n     */\n    recordHttpMetric(entry) {\n        const responseTime = entry.duration;\n        \n        this.responseTimeHistory.push({\n            timestamp: Date.now(),\n            duration: responseTime,\n            name: entry.name\n        });\n        \n        // Trim history\n        if (this.responseTimeHistory.length > this.config.maxMetricHistory) {\n            this.responseTimeHistory.shift();\n        }\n        \n        // Update application metrics\n        this.updateResponseTimeMetrics(responseTime);\n        \n        // Check for response time alerts\n        if (responseTime > this.config.responseTimeWarningThreshold) {\n            this.emit('alert', {\n                type: 'response_time_warning',\n                level: 'warning',\n                message: `Slow response time: ${responseTime.toFixed(2)}ms`,\n                data: { responseTime, entry }\n            });\n        }\n    }\n    \n    /**\n     * Record function performance metric\n     */\n    recordFunctionMetric(entry) {\n        // Track function performance for profiling\n        this.recordEvent('function_performance', {\n            name: entry.name,\n            duration: entry.duration,\n            timestamp: Date.now()\n        });\n    }\n    \n    /**\n     * Update response time metrics\n     */\n    updateResponseTimeMetrics(responseTime) {\n        const app = this.metrics.application.requests;\n        \n        app.total++;\n        \n        // Update average response time (exponential moving average)\n        const alpha = 0.1;\n        app.avgResponseTime = alpha * responseTime + (1 - alpha) * app.avgResponseTime;\n        \n        // Calculate percentiles from recent history\n        if (this.responseTimeHistory.length > 10) {\n            const recent = this.responseTimeHistory.slice(-100).map(r => r.duration).sort((a, b) => a - b);\n            app.p95ResponseTime = recent[Math.floor(recent.length * 0.95)];\n            app.p99ResponseTime = recent[Math.floor(recent.length * 0.99)];\n        }\n    }\n    \n    /**\n     * Record system event\n     */\n    recordEvent(type, data) {\n        const event = {\n            id: crypto.randomUUID(),\n            type,\n            timestamp: Date.now(),\n            data\n        };\n        \n        this.eventHistory.push(event);\n        \n        // Trim event history\n        if (this.eventHistory.length > this.config.maxEventHistory) {\n            this.eventHistory.shift();\n        }\n        \n        this.emit('event', event);\n    }\n    \n    /**\n     * Store metric snapshot in history\n     */\n    storeMetricSnapshot(timestamp) {\n        const snapshot = {\n            timestamp,\n            system: JSON.parse(JSON.stringify(this.metrics.system)),\n            application: JSON.parse(JSON.stringify(this.metrics.application))\n        };\n        \n        this.metricHistory.push(snapshot);\n        \n        // Trim metric history\n        if (this.metricHistory.length > this.config.maxMetricHistory) {\n            this.metricHistory.shift();\n        }\n    }\n    \n    /**\n     * Sample garbage collection statistics\n     */\n    sampleGCStats() {\n        try {\n            if (global.gc && this.metrics.system.gcStats) {\n                const beforeHeap = process.memoryUsage().heapUsed;\n                const start = process.hrtime.bigint();\n                \n                global.gc();\n                \n                const duration = Number(process.hrtime.bigint() - start) / 1e6;\n                const afterHeap = process.memoryUsage().heapUsed;\n                const memoryFreed = beforeHeap - afterHeap;\n                \n                this.metrics.system.gcStats.totalGCs++;\n                this.metrics.system.gcStats.totalTime += duration;\n                this.metrics.system.gcStats.avgTime = this.metrics.system.gcStats.totalTime / this.metrics.system.gcStats.totalGCs;\n                this.metrics.system.gcStats.lastGC = {\n                    timestamp: Date.now(),\n                    duration,\n                    memoryFreed,\n                    beforeHeap,\n                    afterHeap\n                };\n                \n                this.recordEvent('garbage_collection', this.metrics.system.gcStats.lastGC);\n            }\n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: GC sampling error:', error.message);\n        }\n    }\n    \n    /**\n     * Detailed garbage collection monitoring\n     */\n    detailedGCMonitoring() {\n        // In development mode, we can afford more detailed monitoring\n        this.sampleGCStats();\n        \n        // Monitor heap fragmentation\n        try {\n            const v8 = require('v8');\n            const heapStats = v8.getHeapStatistics();\n            const fragmentation = (heapStats.total_heap_size - heapStats.used_heap_size) / heapStats.total_heap_size;\n            \n            if (fragmentation > 0.3) { // 30% fragmentation\n                this.recordEvent('heap_fragmentation_warning', {\n                    fragmentation: fragmentation * 100,\n                    totalHeapSize: heapStats.total_heap_size,\n                    usedHeapSize: heapStats.used_heap_size\n                });\n            }\n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Detailed GC monitoring error:', error.message);\n        }\n    }\n    \n    /**\n     * Update application metrics from external sources\n     */\n    updateApplicationMetrics(metrics) {\n        try {\n            // Agent metrics\n            if (metrics.agents) {\n                Object.assign(this.metrics.application.agents, metrics.agents);\n            }\n            \n            // Cache metrics\n            if (metrics.cache) {\n                Object.assign(this.metrics.application.cache, metrics.cache);\n            }\n            \n            // Neural network metrics\n            if (metrics.neural) {\n                Object.assign(this.metrics.application.neural, metrics.neural);\n            }\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Application metrics update error:', error.message);\n        }\n    }\n    \n    /**\n     * Generate comprehensive performance report\n     */\n    async generatePerformanceReport() {\n        try {\n            const report = {\n                timestamp: new Date().toISOString(),\n                summary: this.generateSummaryStats(),\n                metrics: this.metrics,\n                trends: this.analyzeTrends(),\n                alerts: this.getActiveAlerts(),\n                recommendations: this.generateRecommendations(),\n                rawData: {\n                    metricHistory: this.metricHistory.slice(-100), // Last 100 snapshots\n                    eventHistory: this.eventHistory.slice(-50), // Last 50 events\n                    profileSamples: this.profileSamples.slice(-20) // Last 20 profiles\n                }\n            };\n            \n            // Save report to file\n            await this.saveReport(report);\n            \n            this.emit('report-generated', report);\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Report generation error:', error.message);\n        }\n    }\n    \n    /**\n     * Generate summary statistics\n     */\n    generateSummaryStats() {\n        const memUsage = this.metrics.system.memoryUsage;\n        const totalMemory = this.metrics.system.platform?.totalMemory || 0;\n        \n        return {\n            uptime: this.metrics.system.uptime,\n            memoryUtilization: totalMemory ? (memUsage.rss / totalMemory) * 100 : 0,\n            heapUtilization: (memUsage.heapUsed / memUsage.heapTotal) * 100,\n            cpuUsage: this.metrics.system.cpuUsage.percent,\n            eventLoopDelay: this.metrics.system.eventLoop.delay,\n            avgResponseTime: this.metrics.application.requests.avgResponseTime,\n            totalRequests: this.metrics.application.requests.total,\n            cacheHitRate: this.metrics.application.cache.hitRate,\n            activeAgents: this.metrics.application.agents.active\n        };\n    }\n    \n    /**\n     * Analyze performance trends\n     */\n    analyzeTrends() {\n        if (this.metricHistory.length < 20) {\n            return { insufficient_data: true };\n        }\n        \n        const recent = this.metricHistory.slice(-10);\n        const older = this.metricHistory.slice(-20, -10);\n        \n        const trends = {\n            memoryTrend: this.calculateTrend(older, recent, 'system.memoryUsage.heapUsed'),\n            cpuTrend: this.calculateTrend(older, recent, 'system.cpuUsage.percent'),\n            responseTimeTrend: this.calculateTrend(older, recent, 'application.requests.avgResponseTime')\n        };\n        \n        return trends;\n    }\n    \n    /**\n     * Calculate trend for a specific metric\n     */\n    calculateTrend(older, recent, metricPath) {\n        const getValue = (obj, path) => {\n            return path.split('.').reduce((o, p) => o && o[p], obj);\n        };\n        \n        const olderValues = older.map(m => getValue(m, metricPath)).filter(v => v !== undefined);\n        const recentValues = recent.map(m => getValue(m, metricPath)).filter(v => v !== undefined);\n        \n        if (olderValues.length === 0 || recentValues.length === 0) {\n            return { trend: 'unknown', change: 0 };\n        }\n        \n        const olderAvg = olderValues.reduce((a, b) => a + b, 0) / olderValues.length;\n        const recentAvg = recentValues.reduce((a, b) => a + b, 0) / recentValues.length;\n        \n        const change = ((recentAvg - olderAvg) / olderAvg) * 100;\n        \n        let trend = 'stable';\n        if (change > 5) trend = 'increasing';\n        else if (change < -5) trend = 'decreasing';\n        \n        return { trend, change: change.toFixed(2) };\n    }\n    \n    /**\n     * Get currently active alerts\n     */\n    getActiveAlerts() {\n        return Object.entries(this.alertState)\n            .filter(([key, active]) => active)\n            .map(([key]) => key);\n    }\n    \n    /**\n     * Generate performance recommendations\n     */\n    generateRecommendations() {\n        const recommendations = [];\n        const memUsage = this.metrics.system.memoryUsage;\n        const heapUtilization = (memUsage.heapUsed / memUsage.heapTotal) * 100;\n        \n        if (heapUtilization > 80) {\n            recommendations.push({\n                type: 'memory',\n                priority: 'high',\n                message: 'High heap utilization detected. Consider implementing more aggressive garbage collection or optimizing memory usage patterns.'\n            });\n        }\n        \n        if (this.metrics.system.cpuUsage.percent > 70) {\n            recommendations.push({\n                type: 'cpu',\n                priority: 'high',\n                message: 'High CPU usage detected. Consider optimizing computational algorithms or implementing caching strategies.'\n            });\n        }\n        \n        if (this.metrics.application.requests.avgResponseTime > 1000) {\n            recommendations.push({\n                type: 'performance',\n                priority: 'medium',\n                message: 'Average response time is over 1 second. Consider optimizing database queries, implementing caching, or reviewing application logic.'\n            });\n        }\n        \n        return recommendations;\n    }\n    \n    /**\n     * Save performance report to file\n     */\n    async saveReport(report) {\n        try {\n            const filename = `performance-report-${Date.now()}.json`;\n            const filepath = path.join(this.config.reportPath, filename);\n            \n            await fs.writeFile(filepath, JSON.stringify(report, null, 2));\n            \n            console.log(`PERFORMANCE MONITOR: Report saved to ${filepath}`);\n            \n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Report save error:', error.message);\n        }\n    }\n    \n    /**\n     * Ensure report directory exists\n     */\n    async ensureReportDirectory() {\n        try {\n            await fs.mkdir(this.config.reportPath, { recursive: true });\n        } catch (error) {\n            console.error('PERFORMANCE MONITOR: Report directory creation error:', error.message);\n        }\n    }\n    \n    /**\n     * Get current performance snapshot\n     */\n    getSnapshot() {\n        return {\n            timestamp: Date.now(),\n            metrics: JSON.parse(JSON.stringify(this.metrics)),\n            summary: this.generateSummaryStats(),\n            alerts: this.getActiveAlerts()\n        };\n    }\n    \n    /**\n     * Get performance statistics\n     */\n    getStats() {\n        return {\n            ...this.generateSummaryStats(),\n            trends: this.analyzeTrends(),\n            alerts: this.getActiveAlerts(),\n            eventCount: this.eventHistory.length,\n            metricHistorySize: this.metricHistory.length,\n            profileSampleCount: this.profileSamples.length\n        };\n    }\n    \n    /**\n     * Reset performance statistics\n     */\n    reset() {\n        // Reset counters but keep configuration\n        this.metrics.application.requests = {\n            total: 0,\n            successful: 0,\n            failed: 0,\n            avgResponseTime: 0,\n            p95ResponseTime: 0,\n            p99ResponseTime: 0\n        };\n        \n        this.metricHistory = [];\n        this.eventHistory = [];\n        this.profileSamples = [];\n        this.responseTimeHistory = [];\n        \n        console.log('PERFORMANCE MONITOR: Statistics reset');\n    }\n    \n    /**\n     * Shutdown performance monitor\n     */\n    shutdown() {\n        // Clear all intervals\n        // Note: In a real implementation, we'd track interval IDs\n        \n        // Disconnect performance observers\n        for (const observer of this.performanceObservers.values()) {\n            try {\n                observer.disconnect();\n            } catch (error) {\n                console.error('Error disconnecting observer:', error.message);\n            }\n        }\n        \n        this.performanceObservers.clear();\n        \n        // Generate final report\n        this.generatePerformanceReport().catch(error => {\n            console.error('Final report generation error:', error.message);\n        });\n        \n        console.log('PERFORMANCE MONITOR: Shutdown complete');\n    }\n}\n\nmodule.exports = PerformanceMonitor;