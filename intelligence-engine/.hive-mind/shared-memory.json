{
  "entries": {
    "document-analysis:68da34ca0ed34af3b219f8157d039ec0": {
      "projectPath": "/workspaces/MASTER-WORKFLOW/intelligence-engine",
      "totalDocuments": 20,
      "agentOSDocuments": 5,
      "documentsWithCustomizations": 0,
      "analysisResults": {
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/SHARED-MEMORY-README.md": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/SHARED-MEMORY-README.md",
          "fileName": "SHARED-MEMORY-README.md",
          "extension": "md",
          "type": "markdown",
          "content": "# SharedMemoryStore - Production-Ready Cross-Agent Data Sharing\n\n## Overview\n\nThe SharedMemoryStore is a comprehensive, production-ready implementation that provides cross-agent data sharing, context preservation, result caching, and state synchronization for the Hive-Mind architecture. It integrates seamlessly with the existing `.hive-mind/` infrastructure and SQLite databases.\n\n## Features\n\n### Core Functionality\n- **Dual-layer Architecture**: In-memory cache + SQLite persistence\n- **Atomic Operations**: Thread-safe operations for concurrent access\n- **Memory Versioning**: Version control with conflict resolution\n- **Pub/Sub Events**: Real-time updates and notifications\n- **Garbage Collection**: Intelligent cleanup of expired data\n- **Performance Optimization**: High-frequency access optimization\n\n### Cross-Agent Capabilities\n- **Data Sharing**: Seamless data exchange between agents\n- **Context Preservation**: Persistent agent contexts across sessions\n- **Result Caching**: Intelligent caching with TTL support\n- **State Synchronization**: Real-time state updates\n- **Communication Channels**: Structured inter-agent messaging\n\n### Memory Management\n- **Memory Limits**: Configurable memory and entry limits\n- **LRU Eviction**: Least Recently Used eviction strategy\n- **Compression**: Automatic compression for large data\n- **Namespace Isolation**: Organized data separation\n- **Lock Management**: Exclusive access controls\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    SharedMemoryStore                        │\n├─────────────────────────────────────────────────────────────┤\n│  In-Memory Cache     │  Persistent Store  │  Version Store  │\n│  ├─ Fast Access     │  ├─ SQLite DB      │  ├─ Version     │\n│  ├─ LRU Eviction    │  ├─ File Fallback  │  │   History    │\n│  └─ Transient Data  │  └─ Cross-Session  │  └─ Conflict    │\n│                     │      Persistence   │      Resolution │\n├─────────────────────────────────────────────────────────────┤\n│  Metadata Store     │  Subscriber Store   │  Lock Store    │\n│  ├─ Entry Info     │  ├─ Pub/Sub        │  ├─ Exclusive   │\n│  ├─ TTL Tracking   │  ├─ Pattern Match  │  │   Locks      │\n│  └─ Access Stats   │  └─ Event Routing  │  └─ Timeouts    │\n├─────────────────────────────────────────────────────────────┤\n│                    Event System                             │\n│  ├─ Memory Updates          ├─ Agent Notifications         │\n│  ├─ Garbage Collection      ├─ Lock Acquisition/Release   │\n│  └─ Performance Metrics     └─ Error Handling             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Integration with Existing Infrastructure\n\n### SQLite Integration\n- **hive.db**: Cross-agent coordination and event logging\n- **memory.db**: Shared memory persistence and versioning\n- **Fallback**: Graceful degradation to file-based storage\n\n### File Structure\n```\n.hive-mind/\n├── hive.db                 # Main coordination database\n├── memory.db               # Shared memory database\n├── shared-memory.json      # File-based fallback\n├── backups/               # Automatic backups\n│   └── shared-memory-*.json\n└── sessions/              # Session data\n    ├── session-*.json\n    └── hive-mind-prompt-*.txt\n```\n\n## Usage Examples\n\n### Basic Operations\n\n```javascript\nconst SharedMemoryStore = require('./shared-memory');\n\n// Initialize\nconst memory = new SharedMemoryStore({\n  projectRoot: '/path/to/project',\n  maxMemorySize: 500 * 1024 * 1024, // 500MB\n  maxEntries: 100000,\n  gcInterval: 300000 // 5 minutes\n});\n\n// Wait for initialization\nawait new Promise(resolve => memory.once('initialized', resolve));\n\n// Store data with options\nawait memory.set('analysis-results', {\n  complexity: 'high',\n  maintainability: 0.7,\n  issues: ['refactor-needed']\n}, {\n  namespace: memory.namespaces.TASK_RESULTS,\n  dataType: memory.dataTypes.PERSISTENT,\n  ttl: 24 * 60 * 60 * 1000, // 24 hours\n  agentId: 'code-analyzer-001',\n  metadata: { analysisType: 'code-quality' }\n});\n\n// Retrieve data\nconst results = await memory.get('analysis-results', {\n  agentId: 'requesting-agent',\n  includeMetadata: true\n});\n\nconsole.log('Results:', results.value);\nconsole.log('Metadata:', results.metadata);\n```\n\n### Cross-Agent Data Sharing\n\n```javascript\n// Agent A stores analysis results\nawait memory.set('shared-analysis', {\n  codeQuality: 85,\n  testCoverage: 0.78,\n  recommendations: ['add-unit-tests', 'refactor-large-functions']\n}, {\n  namespace: memory.namespaces.CROSS_AGENT,\n  agentId: 'analyzer-agent-001',\n  metadata: { sharedWith: ['test-agent-001', 'doc-agent-001'] }\n});\n\n// Agent B retrieves and processes\nconst sharedData = await memory.get('shared-analysis', {\n  agentId: 'test-agent-001'\n});\n\n// Agent B stores processed results\nawait memory.set('processed-analysis', {\n  originalAnalysis: sharedData,\n  additionalTests: ['integration-tests', 'performance-tests'],\n  testPlan: 'comprehensive-testing-strategy.md'\n}, {\n  namespace: memory.namespaces.CROSS_AGENT,\n  agentId: 'test-agent-001'\n});\n```\n\n### Context Preservation\n\n```javascript\n// Store agent context\nconst agentId = 'long-running-agent-001';\nawait memory.set(`agent-context-${agentId}`, {\n  currentTask: 'large-codebase-analysis',\n  progress: 0.65,\n  processedFiles: ['app.js', 'utils.js', 'config.js'],\n  currentFile: 'components/dashboard.js',\n  intermediateResults: {\n    totalFiles: 150,\n    analyzedFiles: 98,\n    issuesFound: 23\n  },\n  sessionData: {\n    startTime: Date.now(),\n    tokensUsed: 85000,\n    maxTokens: 200000\n  }\n}, {\n  namespace: memory.namespaces.AGENT_CONTEXT,\n  dataType: memory.dataTypes.PERSISTENT,\n  agentId: agentId\n});\n\n// Later, restore context (even after restart)\nconst restoredContext = await memory.get(`agent-context-${agentId}`, {\n  agentId: agentId\n});\n\nconsole.log(`Resuming analysis at ${restoredContext.progress * 100}% completion`);\n```\n\n### Pub/Sub Notifications\n\n```javascript\n// Subscribe to data changes\nconst unsubscribe = memory.subscribe('task-results-*', (event) => {\n  console.log(`Task result updated: ${event.key}`);\n  console.log(`Event type: ${event.eventType}`);\n  console.log(`Updated by: ${event.data.agentId}`);\n  \n  // Process the update\n  if (event.eventType === 'set') {\n    handleNewTaskResult(event.key, event.data.value);\n  }\n}, {\n  agentId: 'monitoring-agent',\n  events: ['set', 'delete']\n});\n\n// Later, unsubscribe\nunsubscribe();\n```\n\n### Atomic Operations\n\n```javascript\n// Safe counter increment\nconst finalCount = await memory.atomic('global-counter', (currentValue) => {\n  return (currentValue || 0) + 1;\n}, {\n  agentId: 'counter-agent'\n});\n\n// Complex atomic update\nawait memory.atomic('shared-state', (currentState) => {\n  if (!currentState) {\n    return { initialized: true, agents: [], lastUpdate: Date.now() };\n  }\n  \n  // Add agent if not already present\n  if (!currentState.agents.includes('new-agent-001')) {\n    currentState.agents.push('new-agent-001');\n    currentState.lastUpdate = Date.now();\n  }\n  \n  return currentState;\n}, {\n  agentId: 'new-agent-001',\n  timeout: 5000\n});\n```\n\n### Locking Mechanism\n\n```javascript\nconst key = 'critical-resource';\nconst agentId = 'processing-agent';\n\ntry {\n  // Acquire exclusive lock\n  const lock = await memory.acquireLock(key, agentId, {\n    timeout: 30000 // 30 seconds\n  });\n  \n  console.log(`Lock acquired: ${lock.acquiredAt}`);\n  \n  // Perform critical operations\n  const data = await memory.get(key);\n  const processedData = await expensiveProcessing(data);\n  await memory.set(key, processedData, { agentId });\n  \n} finally {\n  // Always release the lock\n  await memory.releaseLock(key, agentId);\n}\n```\n\n## Configuration Options\n\n### Constructor Options\n\n```javascript\nconst memory = new SharedMemoryStore({\n  projectRoot: '/path/to/project',           // Project root directory\n  maxMemorySize: 500 * 1024 * 1024,         // 500MB maximum memory\n  maxEntries: 100000,                       // Maximum entries\n  gcInterval: 300000,                       // GC interval (5 minutes)\n  compressionThreshold: 1024 * 1024         // Compression threshold (1MB)\n});\n```\n\n### Data Types\n\n```javascript\nmemory.dataTypes = {\n  PERSISTENT: 'persistent',     // Survive process restarts\n  TRANSIENT: 'transient',       // Memory-only, cleared on restart\n  CACHED: 'cached',             // LRU cache with TTL\n  VERSIONED: 'versioned',       // Version controlled with history\n  SHARED: 'shared',             // Cross-agent shared data\n  LOCKED: 'locked'              // Requires exclusive access\n};\n```\n\n### Namespaces\n\n```javascript\nmemory.namespaces = {\n  AGENT_CONTEXT: 'agent_context',   // Agent contexts and state\n  TASK_RESULTS: 'task_results',     // Task execution results\n  SHARED_STATE: 'shared_state',     // Shared application state\n  CROSS_AGENT: 'cross_agent',       // Cross-agent communication\n  CACHE: 'cache',                   // Cached computations\n  TEMP: 'temp',                     // Temporary data\n  CONFIG: 'config',                 // Configuration data\n  METRICS: 'metrics'                // Performance metrics\n};\n```\n\n## Performance Metrics\n\n### Available Statistics\n\n```javascript\nconst stats = memory.getStats();\nconsole.log({\n  reads: stats.reads,                    // Total read operations\n  writes: stats.writes,                  // Total write operations\n  hits: stats.hits,                      // Cache hits\n  misses: stats.misses,                  // Cache misses\n  cacheHitRate: stats.cacheHitRate,      // Hit rate percentage\n  evictions: stats.evictions,            // LRU evictions\n  gcRuns: stats.gcRuns,                  // Garbage collection runs\n  memoryUsage: stats.memoryUsage,        // Current memory usage\n  entryCount: stats.entryCount,          // Current entry count\n  averageReadTime: stats.averageReadTime,   // Average read time (ms)\n  averageWriteTime: stats.averageWriteTime, // Average write time (ms)\n  memoryUtilization: stats.memoryUtilization, // Memory usage %\n  entryUtilization: stats.entryUtilization,   // Entry usage %\n  dbStatus: stats.dbStatus,              // SQLite status\n  activeSubscribers: stats.activeSubscribers, // Pub/sub subscribers\n  activeLocks: stats.activeLocks         // Active locks\n});\n```\n\n## Testing\n\n### Running Tests\n\n```bash\n# Run comprehensive test suite\nnode intelligence-engine/test-shared-memory.js\n\n# Run with coverage (if available)\nnpm run test\n\n# Run specific test categories\nnode -e \"\nconst Tester = require('./intelligence-engine/test-shared-memory');\nconst tester = new Tester();\ntester.testBasicOperations().then(() => console.log('Basic tests passed'));\n\"\n```\n\n### Test Coverage\n\nThe test suite covers:\n- ✅ Basic CRUD operations\n- ✅ Namespace isolation\n- ✅ Data type handling\n- ✅ TTL and expiration\n- ✅ Versioning system\n- ✅ Atomic operations\n- ✅ Pub/Sub notifications\n- ✅ Locking mechanism\n- ✅ Cross-agent sharing\n- ✅ Context preservation\n- ✅ Result caching\n- ✅ Memory limits\n- ✅ Garbage collection\n- ✅ Performance metrics\n- ✅ SQLite integration\n- ✅ File-based fallback\n\n## Integration Example\n\n### Full Integration with Queen Controller\n\n```javascript\nconst HiveMindIntegration = require('./memory-integration-example');\n\n// Initialize complete system\nconst integration = new HiveMindIntegration({\n  projectRoot: process.cwd(),\n  maxConcurrentAgents: 10\n});\n\n// Wait for initialization\nawait new Promise(resolve => integration.once('integration-ready', resolve));\n\n// Spawn agents with memory integration\nconst analyzerAgent = await integration.spawnAgent('code-analyzer', {\n  id: 'analyze-project',\n  description: 'Comprehensive project analysis'\n});\n\nconst testAgent = await integration.spawnAgent('test-runner', {\n  id: 'run-tests',\n  description: 'Execute test suites'\n});\n\n// Share data between agents\nawait integration.shareDataBetweenAgents(\n  analyzerAgent, \n  testAgent, \n  { analysisResults: { complexity: 'medium', issues: [] } }\n);\n\n// Monitor system status\nconst status = integration.getSystemStatus();\nconsole.log('System Status:', status);\n\n// Graceful shutdown\nawait integration.shutdown();\n```\n\n## Best Practices\n\n### Memory Management\n1. **Use appropriate data types** for different use cases\n2. **Set TTL values** for temporary data\n3. **Monitor memory usage** regularly\n4. **Use namespaces** to organize data\n5. **Implement proper cleanup** in agent lifecycle\n\n### Cross-Agent Communication\n1. **Use structured data formats** for sharing\n2. **Include metadata** for context\n3. **Subscribe to relevant channels** only\n4. **Handle notification failures** gracefully\n5. **Version shared data structures** for compatibility\n\n### Performance Optimization\n1. **Cache frequently accessed data** in memory\n2. **Use atomic operations** for concurrent access\n3. **Batch operations** when possible\n4. **Monitor performance metrics** continuously\n5. **Tune garbage collection** intervals\n\n### Error Handling\n1. **Handle SQLite unavailability** gracefully\n2. **Implement retry logic** for transient failures\n3. **Log errors appropriately** without exposing sensitive data\n4. **Provide fallback mechanisms** for critical operations\n5. **Monitor and alert** on persistent errors\n\n## Troubleshooting\n\n### Common Issues\n\n#### SQLite Not Available\n```\nError: Module 'sqlite3' not found\nSolution: Run 'npm install sqlite3' or use file-based fallback\n```\n\n#### Memory Limit Exceeded\n```\nError: Memory limit exceeded: 524288000 > 500000000\nSolution: Increase maxMemorySize or implement data cleanup\n```\n\n#### Lock Timeout\n```\nError: Key shared-resource is already locked by agent agent-001\nSolution: Implement proper lock release or increase timeout\n```\n\n#### Performance Degradation\n```\nIssue: High average read/write times\nSolution: Check memory usage, run GC, optimize data structure\n```\n\n### Debugging\n\nEnable debug logging:\n```javascript\nconst memory = new SharedMemoryStore({\n  // ... options\n});\n\nmemory.on('error', (error) => {\n  console.error('Memory Store Error:', error);\n});\n\nmemory.on('memory-set', (event) => {\n  console.log('Memory Set:', event);\n});\n\nmemory.on('garbage-collection', (event) => {\n  console.log('GC Run:', event);\n});\n```\n\n## Future Enhancements\n\n### Planned Features\n- [ ] **Compression**: Automatic compression for large values\n- [ ] **Replication**: Multi-node memory synchronization\n- [ ] **Query Engine**: SQL-like queries for complex data retrieval\n- [ ] **Backup/Restore**: Automated backup and restore mechanisms\n- [ ] **Metrics Dashboard**: Web-based monitoring interface\n- [ ] **Schema Validation**: JSON schema validation for stored data\n- [ ] **Encryption**: At-rest and in-transit encryption\n- [ ] **Clustering**: Distributed memory across multiple instances\n\n### Contribution Guidelines\n\n1. **Follow existing code style** and patterns\n2. **Add comprehensive tests** for new features\n3. **Update documentation** for any changes\n4. **Ensure backward compatibility** when possible\n5. **Performance test** any memory-related changes\n\n---\n\n## Summary\n\nThe SharedMemoryStore provides a robust, production-ready foundation for cross-agent data sharing in the Hive-Mind architecture. It combines the performance of in-memory caching with the reliability of persistent storage, while offering advanced features like versioning, pub/sub notifications, and atomic operations.\n\n**Created by Claude Code - August 2025**  \n**Version 2.1.0 - Production Ready**",
          "size": 15346,
          "lastModified": "2025-08-13T02:15:05.516Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "headers": [
              {
                "level": 1,
                "text": "SharedMemoryStore - Production-Ready Cross-Agent Data Sharing",
                "line": 0
              },
              {
                "level": 2,
                "text": "Overview",
                "line": 2
              },
              {
                "level": 2,
                "text": "Features",
                "line": 6
              },
              {
                "level": 3,
                "text": "Core Functionality",
                "line": 8
              },
              {
                "level": 3,
                "text": "Cross-Agent Capabilities",
                "line": 16
              },
              {
                "level": 3,
                "text": "Memory Management",
                "line": 23
              },
              {
                "level": 2,
                "text": "Architecture",
                "line": 30
              },
              {
                "level": 2,
                "text": "Integration with Existing Infrastructure",
                "line": 54
              },
              {
                "level": 3,
                "text": "SQLite Integration",
                "line": 56
              },
              {
                "level": 3,
                "text": "File Structure",
                "line": 61
              },
              {
                "level": 2,
                "text": "Usage Examples",
                "line": 74
              },
              {
                "level": 3,
                "text": "Basic Operations",
                "line": 76
              },
              {
                "level": 3,
                "text": "Cross-Agent Data Sharing",
                "line": 115
              },
              {
                "level": 3,
                "text": "Context Preservation",
                "line": 145
              },
              {
                "level": 3,
                "text": "Pub/Sub Notifications",
                "line": 179
              },
              {
                "level": 3,
                "text": "Atomic Operations",
                "line": 201
              },
              {
                "level": 3,
                "text": "Locking Mechanism",
                "line": 230
              },
              {
                "level": 2,
                "text": "Configuration Options",
                "line": 255
              },
              {
                "level": 3,
                "text": "Constructor Options",
                "line": 257
              },
              {
                "level": 3,
                "text": "Data Types",
                "line": 269
              },
              {
                "level": 3,
                "text": "Namespaces",
                "line": 282
              },
              {
                "level": 2,
                "text": "Performance Metrics",
                "line": 297
              },
              {
                "level": 3,
                "text": "Available Statistics",
                "line": 299
              },
              {
                "level": 2,
                "text": "Testing",
                "line": 323
              },
              {
                "level": 3,
                "text": "Running Tests",
                "line": 325
              },
              {
                "level": 1,
                "text": "Run comprehensive test suite",
                "line": 328
              },
              {
                "level": 1,
                "text": "Run with coverage (if available)",
                "line": 331
              },
              {
                "level": 1,
                "text": "Run specific test categories",
                "line": 334
              },
              {
                "level": 3,
                "text": "Test Coverage",
                "line": 342
              },
              {
                "level": 2,
                "text": "Integration Example",
                "line": 362
              },
              {
                "level": 3,
                "text": "Full Integration with Queen Controller",
                "line": 364
              },
              {
                "level": 2,
                "text": "Best Practices",
                "line": 404
              },
              {
                "level": 3,
                "text": "Memory Management",
                "line": 406
              },
              {
                "level": 3,
                "text": "Cross-Agent Communication",
                "line": 413
              },
              {
                "level": 3,
                "text": "Performance Optimization",
                "line": 420
              },
              {
                "level": 3,
                "text": "Error Handling",
                "line": 427
              },
              {
                "level": 2,
                "text": "Troubleshooting",
                "line": 434
              },
              {
                "level": 3,
                "text": "Common Issues",
                "line": 436
              },
              {
                "level": 4,
                "text": "SQLite Not Available",
                "line": 438
              },
              {
                "level": 4,
                "text": "Memory Limit Exceeded",
                "line": 444
              },
              {
                "level": 4,
                "text": "Lock Timeout",
                "line": 450
              },
              {
                "level": 4,
                "text": "Performance Degradation",
                "line": 456
              },
              {
                "level": 3,
                "text": "Debugging",
                "line": 462
              },
              {
                "level": 2,
                "text": "Future Enhancements",
                "line": 483
              },
              {
                "level": 3,
                "text": "Planned Features",
                "line": 485
              },
              {
                "level": 3,
                "text": "Contribution Guidelines",
                "line": 495
              },
              {
                "level": 2,
                "text": "Summary",
                "line": 505
              }
            ],
            "codeBlocks": [],
            "lists": [
              {
                "indent": 0,
                "text": "**Dual-layer Architecture**: In-memory cache + SQLite persistence",
                "line": 9
              },
              {
                "indent": 0,
                "text": "**Atomic Operations**: Thread-safe operations for concurrent access",
                "line": 10
              },
              {
                "indent": 0,
                "text": "**Memory Versioning**: Version control with conflict resolution",
                "line": 11
              },
              {
                "indent": 0,
                "text": "**Pub/Sub Events**: Real-time updates and notifications",
                "line": 12
              },
              {
                "indent": 0,
                "text": "**Garbage Collection**: Intelligent cleanup of expired data",
                "line": 13
              },
              {
                "indent": 0,
                "text": "**Performance Optimization**: High-frequency access optimization",
                "line": 14
              },
              {
                "indent": 0,
                "text": "**Data Sharing**: Seamless data exchange between agents",
                "line": 17
              },
              {
                "indent": 0,
                "text": "**Context Preservation**: Persistent agent contexts across sessions",
                "line": 18
              },
              {
                "indent": 0,
                "text": "**Result Caching**: Intelligent caching with TTL support",
                "line": 19
              },
              {
                "indent": 0,
                "text": "**State Synchronization**: Real-time state updates",
                "line": 20
              },
              {
                "indent": 0,
                "text": "**Communication Channels**: Structured inter-agent messaging",
                "line": 21
              },
              {
                "indent": 0,
                "text": "**Memory Limits**: Configurable memory and entry limits",
                "line": 24
              },
              {
                "indent": 0,
                "text": "**LRU Eviction**: Least Recently Used eviction strategy",
                "line": 25
              },
              {
                "indent": 0,
                "text": "**Compression**: Automatic compression for large data",
                "line": 26
              },
              {
                "indent": 0,
                "text": "**Namespace Isolation**: Organized data separation",
                "line": 27
              },
              {
                "indent": 0,
                "text": "**Lock Management**: Exclusive access controls",
                "line": 28
              },
              {
                "indent": 0,
                "text": "**hive.db**: Cross-agent coordination and event logging",
                "line": 57
              },
              {
                "indent": 0,
                "text": "**memory.db**: Shared memory persistence and versioning",
                "line": 58
              },
              {
                "indent": 0,
                "text": "**Fallback**: Graceful degradation to file-based storage",
                "line": 59
              },
              {
                "indent": 0,
                "text": "✅ Basic CRUD operations",
                "line": 345
              },
              {
                "indent": 0,
                "text": "✅ Namespace isolation",
                "line": 346
              },
              {
                "indent": 0,
                "text": "✅ Data type handling",
                "line": 347
              },
              {
                "indent": 0,
                "text": "✅ TTL and expiration",
                "line": 348
              },
              {
                "indent": 0,
                "text": "✅ Versioning system",
                "line": 349
              },
              {
                "indent": 0,
                "text": "✅ Atomic operations",
                "line": 350
              },
              {
                "indent": 0,
                "text": "✅ Pub/Sub notifications",
                "line": 351
              },
              {
                "indent": 0,
                "text": "✅ Locking mechanism",
                "line": 352
              },
              {
                "indent": 0,
                "text": "✅ Cross-agent sharing",
                "line": 353
              },
              {
                "indent": 0,
                "text": "✅ Context preservation",
                "line": 354
              },
              {
                "indent": 0,
                "text": "✅ Result caching",
                "line": 355
              },
              {
                "indent": 0,
                "text": "✅ Memory limits",
                "line": 356
              },
              {
                "indent": 0,
                "text": "✅ Garbage collection",
                "line": 357
              },
              {
                "indent": 0,
                "text": "✅ Performance metrics",
                "line": 358
              },
              {
                "indent": 0,
                "text": "✅ SQLite integration",
                "line": 359
              },
              {
                "indent": 0,
                "text": "✅ File-based fallback",
                "line": 360
              },
              {
                "indent": 0,
                "text": "[ ] **Compression**: Automatic compression for large values",
                "line": 486
              },
              {
                "indent": 0,
                "text": "[ ] **Replication**: Multi-node memory synchronization",
                "line": 487
              },
              {
                "indent": 0,
                "text": "[ ] **Query Engine**: SQL-like queries for complex data retrieval",
                "line": 488
              },
              {
                "indent": 0,
                "text": "[ ] **Backup/Restore**: Automated backup and restore mechanisms",
                "line": 489
              },
              {
                "indent": 0,
                "text": "[ ] **Metrics Dashboard**: Web-based monitoring interface",
                "line": 490
              },
              {
                "indent": 0,
                "text": "[ ] **Schema Validation**: JSON schema validation for stored data",
                "line": 491
              },
              {
                "indent": 0,
                "text": "[ ] **Encryption**: At-rest and in-transit encryption",
                "line": 492
              },
              {
                "indent": 0,
                "text": "[ ] **Clustering**: Distributed memory across multiple instances",
                "line": 493
              }
            ],
            "links": [],
            "images": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "templateMarkers": [
            {
              "marker": "${agentId}",
              "position": 5201,
              "type": "template-variable"
            },
            {
              "marker": "${agentId}",
              "position": 5779,
              "type": "template-variable"
            },
            {
              "marker": "${restoredContext.progress * 100}",
              "position": 5852,
              "type": "template-variable"
            },
            {
              "marker": "${event.key}",
              "position": 6080,
              "type": "template-variable"
            },
            {
              "marker": "${event.eventType}",
              "position": 6123,
              "type": "template-variable"
            },
            {
              "marker": "${event.data.agentId}",
              "position": 6172,
              "type": "template-variable"
            },
            {
              "marker": "${lock.acquiredAt}",
              "position": 7360,
              "type": "template-variable"
            }
          ],
          "customSections": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/README.md": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/README.md",
          "fileName": "README.md",
          "extension": "md",
          "type": "markdown",
          "content": "# Intelligence Engine\n\nThe Intelligence Engine is the core component of the MASTER-WORKFLOW system that provides intelligent decision-making, workflow orchestration, and cross-agent coordination capabilities.\n\n## Components\n\n### Core Modules\n\n#### 1. Queen Controller (`queen-controller.js`)\n- **Purpose**: Hierarchical sub-agent architecture master controller\n- **Features**:\n  - Manages up to 10 concurrent sub-agents\n  - Tracks 200k token context windows per agent\n  - Handles inter-agent communication\n  - Provides task distribution and monitoring\n  - Resource usage and performance tracking\n\n#### 2. SharedMemoryStore (`shared-memory.js`) ⭐ **NEW**\n- **Purpose**: Production-ready cross-agent data sharing and context preservation\n- **Features**:\n  - Dual-layer architecture (in-memory + SQLite persistence)\n  - Atomic operations for concurrent access\n  - Memory versioning and conflict resolution\n  - Pub/Sub event system for real-time updates\n  - Garbage collection for expired data\n  - Performance optimization for high-frequency access\n  - Cross-agent result sharing and context preservation\n  - Memory limits and intelligent cleanup\n\n#### 3. HiveMindIntegration (`memory-integration-example.js`) ⭐ **NEW**\n- **Purpose**: Integration layer between Queen Controller and SharedMemoryStore\n- **Features**:\n  - Seamless cross-agent data sharing\n  - Communication channels for inter-agent messaging\n  - Context preservation across agent sessions\n  - Result caching and aggregation\n  - Event-driven coordination\n\n### Specialized Modules\n\n#### 4. Approach Selector (`approach-selector.js`)\n- **Purpose**: Intelligent approach selection for project development\n- **Features**: Technology stack analysis, methodology selection\n\n#### 5. Complexity Analyzer (`complexity-analyzer.js`)\n- **Purpose**: Project complexity assessment and scoring\n- **Features**: Multi-dimensional complexity analysis, scaling recommendations\n\n#### 6. Document Customizer (`document-customizer.js`)\n- **Purpose**: Dynamic documentation generation and customization\n- **Features**: Template-based document generation, project-specific customization\n\n#### 7. Integration Checker (`integration-checker.js`)\n- **Purpose**: System integration validation and compatibility checking\n- **Features**: Dependency analysis, compatibility matrix evaluation\n\n#### 8. Project Scanner (`project-scanner.js`)\n- **Purpose**: Comprehensive project structure and technology detection\n- **Features**: File system analysis, technology stack identification\n\n#### 9. Smart Tool Selector (`smart-tool-selector.js`)\n- **Purpose**: Intelligent tool and technology selection\n- **Features**: Context-aware tool recommendations, integration assessment\n\n#### 10. Sub-Agent Manager (`sub-agent-manager.js`)\n- **Purpose**: Sub-agent lifecycle management and coordination\n- **Features**: Agent spawning, monitoring, and task distribution\n\n## Installation\n\n### Quick Setup\n\n```bash\n# Install dependencies\n./intelligence-engine/install-dependencies.sh\n\n# Verify installation\nnode intelligence-engine/test-shared-memory.js\n```\n\n### Manual Setup\n\n```bash\n# Install SQLite3 (optional, will fallback to file-based storage)\nnpm install sqlite3\n\n# Create .hive-mind directory structure\nmkdir -p .hive-mind/{backups,sessions}\ntouch .hive-mind/{hive.db,memory.db}\n```\n\n## Usage Examples\n\n### Basic SharedMemoryStore Usage\n\n```javascript\nconst SharedMemoryStore = require('./intelligence-engine/shared-memory');\n\n// Initialize\nconst memory = new SharedMemoryStore({\n  projectRoot: process.cwd(),\n  maxMemorySize: 500 * 1024 * 1024, // 500MB\n  maxEntries: 100000\n});\n\n// Wait for initialization\nawait new Promise(resolve => memory.once('initialized', resolve));\n\n// Store and retrieve data\nawait memory.set('analysis-results', {\n  complexity: 'medium',\n  recommendations: ['optimize-performance', 'add-tests']\n}, {\n  namespace: memory.namespaces.TASK_RESULTS,\n  agentId: 'analyzer-001'\n});\n\nconst results = await memory.get('analysis-results');\nconsole.log('Analysis:', results);\n```\n\n### Full Hive-Mind Integration\n\n```javascript\nconst HiveMindIntegration = require('./intelligence-engine/memory-integration-example');\n\n// Initialize complete system\nconst integration = new HiveMindIntegration({\n  projectRoot: process.cwd(),\n  maxConcurrentAgents: 10\n});\n\n// Wait for initialization\nawait new Promise(resolve => integration.once('integration-ready', resolve));\n\n// Spawn agents with memory integration\nconst analyzerAgent = await integration.spawnAgent('code-analyzer', {\n  id: 'analyze-project',\n  description: 'Comprehensive project analysis'\n});\n\n// Share data between agents\nawait integration.shareDataBetweenAgents(\n  analyzerAgent, \n  'test-runner-001',\n  { analysisResults: { issues: [], suggestions: [] } }\n);\n\n// Get system status\nconst status = integration.getSystemStatus();\nconsole.log('System Status:', status);\n```\n\n### Queen Controller with Memory Integration\n\n```javascript\nconst QueenController = require('./intelligence-engine/queen-controller');\nconst SharedMemoryStore = require('./intelligence-engine/shared-memory');\n\n// Initialize shared memory\nconst memory = new SharedMemoryStore({ projectRoot: process.cwd() });\nawait new Promise(resolve => memory.once('initialized', resolve));\n\n// Initialize queen with memory integration\nconst queen = new QueenController({\n  projectRoot: process.cwd(),\n  maxConcurrent: 5,\n  sharedMemory: memory\n});\n\n// Spawn agents with enhanced context\nconst agentId = await queen.spawnSubAgent('code-analyzer', {\n  id: 'analysis-task',\n  description: 'Analyze codebase quality'\n});\n\n// Monitor agents\nconst status = queen.getStatus();\nconsole.log('Active agents:', status.active);\n```\n\n## Architecture\n\n### Memory System Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                  Intelligence Engine                        │\n├─────────────────────────────────────────────────────────────┤\n│                   Queen Controller                          │\n│  ├─ Agent Management        ├─ Task Distribution           │\n│  ├─ Resource Monitoring     ├─ Performance Tracking       │\n│  └─ Inter-Agent Communication                              │\n├─────────────────────────────────────────────────────────────┤\n│                 SharedMemoryStore                           │\n│  ├─ In-Memory Cache         ├─ SQLite Persistence          │\n│  ├─ Pub/Sub Events          ├─ Atomic Operations           │\n│  ├─ Memory Versioning       ├─ Garbage Collection          │\n│  └─ Lock Management         └─ Performance Optimization    │\n├─────────────────────────────────────────────────────────────┤\n│                 HiveMind Integration                        │\n│  ├─ Cross-Agent Channels    ├─ Context Preservation        │\n│  ├─ Result Aggregation      ├─ State Synchronization       │\n│  └─ Event Coordination      └─ Communication Routing       │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Data Flow\n\n```\nAgent A ──┐\n          ├─→ SharedMemoryStore ──→ SQLite/Files\nAgent B ──┤         │\n          │         ├─→ Pub/Sub Events ──→ Subscribers\nAgent C ──┘         │\n                    └─→ Cross-Agent Channels ──→ Other Agents\n```\n\n## File Structure\n\n```\nintelligence-engine/\n├── README.md                           # This file\n├── SHARED-MEMORY-README.md            # Detailed SharedMemoryStore docs\n├── install-dependencies.sh            # Installation script\n├── shared-memory.js                   # SharedMemoryStore implementation\n├── test-shared-memory.js              # Comprehensive test suite\n├── memory-integration-example.js      # Integration example\n├── queen-controller.js                # Enhanced with memory integration\n├── approach-selector.js               # Approach selection logic\n├── complexity-analyzer.js             # Complexity analysis\n├── document-customizer.js             # Document generation\n├── integration-checker.js             # Integration validation\n├── project-scanner.js                 # Project analysis\n├── smart-tool-selector.js             # Tool selection\n├── sub-agent-manager.js               # Agent management\n└── user-choice-handler.sh             # User interaction handler\n```\n\n## Testing\n\n### Comprehensive Test Suite\n\n```bash\n# Run full SharedMemoryStore test suite\nnode intelligence-engine/test-shared-memory.js\n\n# Run integration demonstration\nnode intelligence-engine/memory-integration-example.js\n\n# Run individual component tests\nnode test/test-intelligent-system.sh\n```\n\n### Test Coverage\n\nThe test suite covers:\n- ✅ Basic CRUD operations\n- ✅ Cross-agent data sharing\n- ✅ Context preservation\n- ✅ Memory versioning\n- ✅ Atomic operations\n- ✅ Pub/Sub notifications\n- ✅ Garbage collection\n- ✅ Performance metrics\n- ✅ SQLite integration\n- ✅ File-based fallback\n\n## Performance Metrics\n\n### SharedMemoryStore Statistics\n\n```javascript\nconst stats = memory.getStats();\nconsole.log({\n  reads: stats.reads,                    // Total read operations\n  writes: stats.writes,                  // Total write operations\n  cacheHitRate: stats.cacheHitRate,      // Cache efficiency\n  memoryUsage: stats.memoryUsage,        // Current memory usage\n  averageReadTime: stats.averageReadTime,   // Performance metrics\n  averageWriteTime: stats.averageWriteTime,\n  gcRuns: stats.gcRuns,                  // Garbage collection\n  evictions: stats.evictions             // Memory management\n});\n```\n\n## Configuration\n\n### Environment Variables\n\n```bash\n# SQLite configuration\nexport HIVE_MIND_DB_PATH=\"/custom/path/.hive-mind\"\nexport SQLITE_MEMORY_LIMIT=\"1000000000\"  # 1GB\n\n# Performance tuning\nexport MEMORY_GC_INTERVAL=\"300000\"       # 5 minutes\nexport MEMORY_MAX_ENTRIES=\"100000\"\nexport MEMORY_COMPRESSION_THRESHOLD=\"1048576\"  # 1MB\n\n# Debug settings\nexport HIVE_MIND_DEBUG=\"true\"\nexport MEMORY_STORE_VERBOSE=\"true\"\n```\n\n### Configuration Options\n\n```javascript\nconst memory = new SharedMemoryStore({\n  projectRoot: process.cwd(),           // Project root directory\n  maxMemorySize: 500 * 1024 * 1024,    // 500MB maximum memory\n  maxEntries: 100000,                   // Maximum entries\n  gcInterval: 300000,                   // GC interval (5 minutes)\n  compressionThreshold: 1024 * 1024     // Compression threshold (1MB)\n});\n```\n\n## Integration Points\n\n### With Existing Systems\n\n#### 1. MASTER-WORKFLOW Integration\n- Seamless integration with existing workflow system\n- Enhanced agent coordination and data sharing\n- Backward compatibility maintained\n\n#### 2. .hive-mind Directory\n- Uses existing SQLite databases (`hive.db`, `memory.db`)\n- Preserves session data and agent contexts\n- Automatic backup and recovery\n\n#### 3. Queen Controller Enhancement\n- Enhanced with SharedMemoryStore capabilities\n- Maintains existing API compatibility\n- Improved performance and reliability\n\n## Security Considerations\n\n### Data Protection\n- **Memory Isolation**: Namespace-based data separation\n- **Access Control**: Agent-based access permissions\n- **Data Expiration**: Automatic cleanup of sensitive data\n- **Lock Management**: Prevents concurrent access conflicts\n\n### Best Practices\n1. Use appropriate namespaces for data organization\n2. Set TTL values for temporary/sensitive data\n3. Monitor memory usage and performance metrics\n4. Implement proper error handling and logging\n5. Regular backup of persistent data\n\n## Troubleshooting\n\n### Common Issues\n\n#### SQLite Not Available\n```bash\n# Install SQLite3\nnpm install sqlite3\n\n# Or use file-based fallback (automatic)\n# System will continue to work with reduced performance\n```\n\n#### Memory Limit Exceeded\n```bash\n# Increase memory limits or implement cleanup\nconst memory = new SharedMemoryStore({\n  maxMemorySize: 1000 * 1024 * 1024  # 1GB\n});\n```\n\n#### Performance Issues\n```bash\n# Monitor memory usage\nconst stats = memory.getStats();\nconsole.log('Memory utilization:', stats.memoryUtilization);\n\n# Tune garbage collection\nconst memory = new SharedMemoryStore({\n  gcInterval: 60000  # 1 minute\n});\n```\n\n## Future Enhancements\n\n### Planned Features\n- [ ] **Compression**: Automatic compression for large values\n- [ ] **Replication**: Multi-node memory synchronization\n- [ ] **Query Engine**: SQL-like queries for complex data retrieval\n- [ ] **Metrics Dashboard**: Web-based monitoring interface\n- [ ] **Encryption**: At-rest and in-transit encryption\n- [ ] **Clustering**: Distributed memory across multiple instances\n\n### Contribution Guidelines\n\n1. Follow existing code style and patterns\n2. Add comprehensive tests for new features\n3. Update documentation for any changes\n4. Ensure backward compatibility when possible\n5. Performance test any memory-related changes\n\n## Support\n\n### Documentation\n- **SharedMemoryStore**: `./SHARED-MEMORY-README.md`\n- **API Reference**: Inline code documentation\n- **Examples**: `./memory-integration-example.js`\n\n### Getting Help\n- Review test files for usage examples\n- Check logs for error messages and debugging info\n- Monitor performance metrics for optimization opportunities\n\n---\n\n## Summary\n\nThe Intelligence Engine provides a robust, production-ready foundation for intelligent workflow orchestration and cross-agent coordination. The new SharedMemoryStore component significantly enhances the system's capabilities by providing reliable, high-performance data sharing and context preservation mechanisms.\n\n**Key Benefits:**\n- **Performance**: Dual-layer memory architecture for optimal speed\n- **Reliability**: SQLite persistence with file-based fallback\n- **Scalability**: Configurable limits and intelligent garbage collection\n- **Integration**: Seamless integration with existing systems\n- **Production-Ready**: Comprehensive error handling and monitoring\n\n**Created by Claude Code - August 2025**  \n**Version 2.1.0 - Enhanced with SharedMemoryStore**",
          "size": 13747,
          "lastModified": "2025-08-13T02:17:06.969Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "headers": [
              {
                "level": 1,
                "text": "Intelligence Engine",
                "line": 0
              },
              {
                "level": 2,
                "text": "Components",
                "line": 4
              },
              {
                "level": 3,
                "text": "Core Modules",
                "line": 6
              },
              {
                "level": 4,
                "text": "1. Queen Controller (`queen-controller.js`)",
                "line": 8
              },
              {
                "level": 4,
                "text": "2. SharedMemoryStore (`shared-memory.js`) ⭐ **NEW**",
                "line": 17
              },
              {
                "level": 4,
                "text": "3. HiveMindIntegration (`memory-integration-example.js`) ⭐ **NEW**",
                "line": 29
              },
              {
                "level": 3,
                "text": "Specialized Modules",
                "line": 38
              },
              {
                "level": 4,
                "text": "4. Approach Selector (`approach-selector.js`)",
                "line": 40
              },
              {
                "level": 4,
                "text": "5. Complexity Analyzer (`complexity-analyzer.js`)",
                "line": 44
              },
              {
                "level": 4,
                "text": "6. Document Customizer (`document-customizer.js`)",
                "line": 48
              },
              {
                "level": 4,
                "text": "7. Integration Checker (`integration-checker.js`)",
                "line": 52
              },
              {
                "level": 4,
                "text": "8. Project Scanner (`project-scanner.js`)",
                "line": 56
              },
              {
                "level": 4,
                "text": "9. Smart Tool Selector (`smart-tool-selector.js`)",
                "line": 60
              },
              {
                "level": 4,
                "text": "10. Sub-Agent Manager (`sub-agent-manager.js`)",
                "line": 64
              },
              {
                "level": 2,
                "text": "Installation",
                "line": 68
              },
              {
                "level": 3,
                "text": "Quick Setup",
                "line": 70
              },
              {
                "level": 1,
                "text": "Install dependencies",
                "line": 73
              },
              {
                "level": 1,
                "text": "Verify installation",
                "line": 76
              },
              {
                "level": 3,
                "text": "Manual Setup",
                "line": 80
              },
              {
                "level": 1,
                "text": "Install SQLite3 (optional, will fallback to file-based storage)",
                "line": 83
              },
              {
                "level": 1,
                "text": "Create .hive-mind directory structure",
                "line": 86
              },
              {
                "level": 2,
                "text": "Usage Examples",
                "line": 91
              },
              {
                "level": 3,
                "text": "Basic SharedMemoryStore Usage",
                "line": 93
              },
              {
                "level": 3,
                "text": "Full Hive-Mind Integration",
                "line": 121
              },
              {
                "level": 3,
                "text": "Queen Controller with Memory Integration",
                "line": 153
              },
              {
                "level": 2,
                "text": "Architecture",
                "line": 181
              },
              {
                "level": 3,
                "text": "Memory System Architecture",
                "line": 183
              },
              {
                "level": 3,
                "text": "Data Flow",
                "line": 207
              },
              {
                "level": 2,
                "text": "File Structure",
                "line": 218
              },
              {
                "level": 2,
                "text": "Testing",
                "line": 239
              },
              {
                "level": 3,
                "text": "Comprehensive Test Suite",
                "line": 241
              },
              {
                "level": 1,
                "text": "Run full SharedMemoryStore test suite",
                "line": 244
              },
              {
                "level": 1,
                "text": "Run integration demonstration",
                "line": 247
              },
              {
                "level": 1,
                "text": "Run individual component tests",
                "line": 250
              },
              {
                "level": 3,
                "text": "Test Coverage",
                "line": 254
              },
              {
                "level": 2,
                "text": "Performance Metrics",
                "line": 268
              },
              {
                "level": 3,
                "text": "SharedMemoryStore Statistics",
                "line": 270
              },
              {
                "level": 2,
                "text": "Configuration",
                "line": 286
              },
              {
                "level": 3,
                "text": "Environment Variables",
                "line": 288
              },
              {
                "level": 1,
                "text": "SQLite configuration",
                "line": 291
              },
              {
                "level": 1,
                "text": "Performance tuning",
                "line": 295
              },
              {
                "level": 1,
                "text": "Debug settings",
                "line": 300
              },
              {
                "level": 3,
                "text": "Configuration Options",
                "line": 305
              },
              {
                "level": 2,
                "text": "Integration Points",
                "line": 317
              },
              {
                "level": 3,
                "text": "With Existing Systems",
                "line": 319
              },
              {
                "level": 4,
                "text": "1. MASTER-WORKFLOW Integration",
                "line": 321
              },
              {
                "level": 4,
                "text": "2. .hive-mind Directory",
                "line": 326
              },
              {
                "level": 4,
                "text": "3. Queen Controller Enhancement",
                "line": 331
              },
              {
                "level": 2,
                "text": "Security Considerations",
                "line": 336
              },
              {
                "level": 3,
                "text": "Data Protection",
                "line": 338
              },
              {
                "level": 3,
                "text": "Best Practices",
                "line": 344
              },
              {
                "level": 2,
                "text": "Troubleshooting",
                "line": 351
              },
              {
                "level": 3,
                "text": "Common Issues",
                "line": 353
              },
              {
                "level": 4,
                "text": "SQLite Not Available",
                "line": 355
              },
              {
                "level": 1,
                "text": "Install SQLite3",
                "line": 357
              },
              {
                "level": 1,
                "text": "Or use file-based fallback (automatic)",
                "line": 360
              },
              {
                "level": 1,
                "text": "System will continue to work with reduced performance",
                "line": 361
              },
              {
                "level": 4,
                "text": "Memory Limit Exceeded",
                "line": 364
              },
              {
                "level": 1,
                "text": "Increase memory limits or implement cleanup",
                "line": 366
              },
              {
                "level": 4,
                "text": "Performance Issues",
                "line": 372
              },
              {
                "level": 1,
                "text": "Monitor memory usage",
                "line": 374
              },
              {
                "level": 1,
                "text": "Tune garbage collection",
                "line": 378
              },
              {
                "level": 2,
                "text": "Future Enhancements",
                "line": 384
              },
              {
                "level": 3,
                "text": "Planned Features",
                "line": 386
              },
              {
                "level": 3,
                "text": "Contribution Guidelines",
                "line": 394
              },
              {
                "level": 2,
                "text": "Support",
                "line": 402
              },
              {
                "level": 3,
                "text": "Documentation",
                "line": 404
              },
              {
                "level": 3,
                "text": "Getting Help",
                "line": 409
              },
              {
                "level": 2,
                "text": "Summary",
                "line": 416
              }
            ],
            "codeBlocks": [],
            "lists": [
              {
                "indent": 0,
                "text": "**Purpose**: Hierarchical sub-agent architecture master controller",
                "line": 9
              },
              {
                "indent": 0,
                "text": "**Features**:",
                "line": 10
              },
              {
                "indent": 2,
                "text": "Manages up to 10 concurrent sub-agents",
                "line": 11
              },
              {
                "indent": 2,
                "text": "Tracks 200k token context windows per agent",
                "line": 12
              },
              {
                "indent": 2,
                "text": "Handles inter-agent communication",
                "line": 13
              },
              {
                "indent": 2,
                "text": "Provides task distribution and monitoring",
                "line": 14
              },
              {
                "indent": 2,
                "text": "Resource usage and performance tracking",
                "line": 15
              },
              {
                "indent": 0,
                "text": "**Purpose**: Production-ready cross-agent data sharing and context preservation",
                "line": 18
              },
              {
                "indent": 0,
                "text": "**Features**:",
                "line": 19
              },
              {
                "indent": 2,
                "text": "Dual-layer architecture (in-memory + SQLite persistence)",
                "line": 20
              },
              {
                "indent": 2,
                "text": "Atomic operations for concurrent access",
                "line": 21
              },
              {
                "indent": 2,
                "text": "Memory versioning and conflict resolution",
                "line": 22
              },
              {
                "indent": 2,
                "text": "Pub/Sub event system for real-time updates",
                "line": 23
              },
              {
                "indent": 2,
                "text": "Garbage collection for expired data",
                "line": 24
              },
              {
                "indent": 2,
                "text": "Performance optimization for high-frequency access",
                "line": 25
              },
              {
                "indent": 2,
                "text": "Cross-agent result sharing and context preservation",
                "line": 26
              },
              {
                "indent": 2,
                "text": "Memory limits and intelligent cleanup",
                "line": 27
              },
              {
                "indent": 0,
                "text": "**Purpose**: Integration layer between Queen Controller and SharedMemoryStore",
                "line": 30
              },
              {
                "indent": 0,
                "text": "**Features**:",
                "line": 31
              },
              {
                "indent": 2,
                "text": "Seamless cross-agent data sharing",
                "line": 32
              },
              {
                "indent": 2,
                "text": "Communication channels for inter-agent messaging",
                "line": 33
              },
              {
                "indent": 2,
                "text": "Context preservation across agent sessions",
                "line": 34
              },
              {
                "indent": 2,
                "text": "Result caching and aggregation",
                "line": 35
              },
              {
                "indent": 2,
                "text": "Event-driven coordination",
                "line": 36
              },
              {
                "indent": 0,
                "text": "**Purpose**: Intelligent approach selection for project development",
                "line": 41
              },
              {
                "indent": 0,
                "text": "**Features**: Technology stack analysis, methodology selection",
                "line": 42
              },
              {
                "indent": 0,
                "text": "**Purpose**: Project complexity assessment and scoring",
                "line": 45
              },
              {
                "indent": 0,
                "text": "**Features**: Multi-dimensional complexity analysis, scaling recommendations",
                "line": 46
              },
              {
                "indent": 0,
                "text": "**Purpose**: Dynamic documentation generation and customization",
                "line": 49
              },
              {
                "indent": 0,
                "text": "**Features**: Template-based document generation, project-specific customization",
                "line": 50
              },
              {
                "indent": 0,
                "text": "**Purpose**: System integration validation and compatibility checking",
                "line": 53
              },
              {
                "indent": 0,
                "text": "**Features**: Dependency analysis, compatibility matrix evaluation",
                "line": 54
              },
              {
                "indent": 0,
                "text": "**Purpose**: Comprehensive project structure and technology detection",
                "line": 57
              },
              {
                "indent": 0,
                "text": "**Features**: File system analysis, technology stack identification",
                "line": 58
              },
              {
                "indent": 0,
                "text": "**Purpose**: Intelligent tool and technology selection",
                "line": 61
              },
              {
                "indent": 0,
                "text": "**Features**: Context-aware tool recommendations, integration assessment",
                "line": 62
              },
              {
                "indent": 0,
                "text": "**Purpose**: Sub-agent lifecycle management and coordination",
                "line": 65
              },
              {
                "indent": 0,
                "text": "**Features**: Agent spawning, monitoring, and task distribution",
                "line": 66
              },
              {
                "indent": 0,
                "text": "✅ Basic CRUD operations",
                "line": 257
              },
              {
                "indent": 0,
                "text": "✅ Cross-agent data sharing",
                "line": 258
              },
              {
                "indent": 0,
                "text": "✅ Context preservation",
                "line": 259
              },
              {
                "indent": 0,
                "text": "✅ Memory versioning",
                "line": 260
              },
              {
                "indent": 0,
                "text": "✅ Atomic operations",
                "line": 261
              },
              {
                "indent": 0,
                "text": "✅ Pub/Sub notifications",
                "line": 262
              },
              {
                "indent": 0,
                "text": "✅ Garbage collection",
                "line": 263
              },
              {
                "indent": 0,
                "text": "✅ Performance metrics",
                "line": 264
              },
              {
                "indent": 0,
                "text": "✅ SQLite integration",
                "line": 265
              },
              {
                "indent": 0,
                "text": "✅ File-based fallback",
                "line": 266
              },
              {
                "indent": 0,
                "text": "Seamless integration with existing workflow system",
                "line": 322
              },
              {
                "indent": 0,
                "text": "Enhanced agent coordination and data sharing",
                "line": 323
              },
              {
                "indent": 0,
                "text": "Backward compatibility maintained",
                "line": 324
              },
              {
                "indent": 0,
                "text": "Uses existing SQLite databases (`hive.db`, `memory.db`)",
                "line": 327
              },
              {
                "indent": 0,
                "text": "Preserves session data and agent contexts",
                "line": 328
              },
              {
                "indent": 0,
                "text": "Automatic backup and recovery",
                "line": 329
              },
              {
                "indent": 0,
                "text": "Enhanced with SharedMemoryStore capabilities",
                "line": 332
              },
              {
                "indent": 0,
                "text": "Maintains existing API compatibility",
                "line": 333
              },
              {
                "indent": 0,
                "text": "Improved performance and reliability",
                "line": 334
              },
              {
                "indent": 0,
                "text": "**Memory Isolation**: Namespace-based data separation",
                "line": 339
              },
              {
                "indent": 0,
                "text": "**Access Control**: Agent-based access permissions",
                "line": 340
              },
              {
                "indent": 0,
                "text": "**Data Expiration**: Automatic cleanup of sensitive data",
                "line": 341
              },
              {
                "indent": 0,
                "text": "**Lock Management**: Prevents concurrent access conflicts",
                "line": 342
              },
              {
                "indent": 0,
                "text": "[ ] **Compression**: Automatic compression for large values",
                "line": 387
              },
              {
                "indent": 0,
                "text": "[ ] **Replication**: Multi-node memory synchronization",
                "line": 388
              },
              {
                "indent": 0,
                "text": "[ ] **Query Engine**: SQL-like queries for complex data retrieval",
                "line": 389
              },
              {
                "indent": 0,
                "text": "[ ] **Metrics Dashboard**: Web-based monitoring interface",
                "line": 390
              },
              {
                "indent": 0,
                "text": "[ ] **Encryption**: At-rest and in-transit encryption",
                "line": 391
              },
              {
                "indent": 0,
                "text": "[ ] **Clustering**: Distributed memory across multiple instances",
                "line": 392
              },
              {
                "indent": 0,
                "text": "**SharedMemoryStore**: `./SHARED-MEMORY-README.md`",
                "line": 405
              },
              {
                "indent": 0,
                "text": "**API Reference**: Inline code documentation",
                "line": 406
              },
              {
                "indent": 0,
                "text": "**Examples**: `./memory-integration-example.js`",
                "line": 407
              },
              {
                "indent": 0,
                "text": "Review test files for usage examples",
                "line": 410
              },
              {
                "indent": 0,
                "text": "Check logs for error messages and debugging info",
                "line": 411
              },
              {
                "indent": 0,
                "text": "Monitor performance metrics for optimization opportunities",
                "line": 412
              },
              {
                "indent": 0,
                "text": "**Performance**: Dual-layer memory architecture for optimal speed",
                "line": 421
              },
              {
                "indent": 0,
                "text": "**Reliability**: SQLite persistence with file-based fallback",
                "line": 422
              },
              {
                "indent": 0,
                "text": "**Scalability**: Configurable limits and intelligent garbage collection",
                "line": 423
              },
              {
                "indent": 0,
                "text": "**Integration**: Seamless integration with existing systems",
                "line": 424
              },
              {
                "indent": 0,
                "text": "**Production-Ready**: Comprehensive error handling and monitoring",
                "line": 425
              }
            ],
            "links": [],
            "images": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "templateMarkers": [],
          "customSections": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/approach-selector.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/approach-selector.js",
          "fileName": "approach-selector.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Claude Flow Approach Selector\n * Intelligently selects the optimal Claude Flow approach based on project analysis\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst versionPolicy = require('../lib/version-policy');\n\nclass ApproachSelector {\n  constructor() {\n    // Default version name (env or heuristic)\n    this.defaultVersion = versionPolicy.getSelectedVersionName({});\n    \n    this.approaches = {\n      simpleSwarm: {\n        name: 'Simple Swarm',\n        command: 'npx claude-flow swarm',  // Version will be added dynamically\n        scoreRange: [0, 30],\n        description: 'Quick AI coordination for straightforward tasks',\n        timeEstimate: '5-30 minutes',\n        agentCount: 1,\n        bestFor: [\n          'Single feature development',\n          'Quick prototypes',\n          'Bug fixes',\n          'Simple integrations',\n          'Learning and experimentation'\n        ],\n        limitations: [\n          'No persistent memory',\n          'Limited coordination',\n          'Single-threaded execution'\n        ]\n      },\n      hiveMind: {\n        name: 'Hive-Mind',\n        command: 'npx claude-flow hive-mind spawn',  // Version will be added dynamically\n        scoreRange: [31, 70],\n        description: 'Intelligent multi-agent coordination with specialized roles',\n        timeEstimate: '30 minutes - 4 hours',\n        agentCount: '4-6',\n        bestFor: [\n          'Multi-feature development',\n          'Fullstack applications',\n          'Complex integrations',\n          'Team-based development',\n          'Medium-scale projects'\n        ],\n        features: [\n          'Specialized agent roles',\n          'Cross-session memory',\n          'Parallel execution',\n          'Intelligent coordination'\n        ]\n      },\n      hiveMindSparc: {\n        name: 'Hive-Mind + SPARC',\n        command: 'npx claude-flow hive-mind spawn --sparc',  // Version will be added dynamically\n        scoreRange: [71, 100],\n        description: 'Enterprise methodology with systematic development phases',\n        timeEstimate: '4+ hours',\n        agentCount: '8-12',\n        bestFor: [\n          'Enterprise applications',\n          'Complex system architecture',\n          'Long-term projects',\n          'Systematic development',\n          'Professional documentation'\n        ],\n        sparcPhases: [\n          'Specification - Requirements and planning',\n          'Pseudocode - Algorithm design',\n          'Architecture - System design',\n          'Refinement - Iterative improvement',\n          'Completion - Final implementation'\n        ]\n      }\n    };\n    \n    this.userPreferences = this.loadUserPreferences();\n  }\n\n  /**\n   * Select optimal approach based on analysis\n   * @param {Object} analysis - Project analysis results\n   * @param {string} userChoice - User's approach choice\n   * @param {string} taskDescription - Task description\n   * @param {string} claudeFlowVersion - Specific Claude Flow version to use\n   */\n  selectApproach(analysis, userChoice = null, taskDescription = '', claudeFlowVersion = null) {\n    // Determine version name by precedence (input → env → analysis → fallback)\n    this.selectedVersion = versionPolicy.getSelectedVersionName({ input: claudeFlowVersion, analysis });\n    // If user made explicit choice, validate and use it\n    if (userChoice) {\n      return this.validateUserChoice(userChoice, analysis);\n    }\n    \n    // Otherwise, select based on analysis\n    const score = analysis.score || 50;\n    const stage = analysis.stage || 'unknown';\n    \n    // Find approach based on score\n    let selectedApproach = null;\n    for (const [key, approach] of Object.entries(this.approaches)) {\n      if (score >= approach.scoreRange[0] && score <= approach.scoreRange[1]) {\n        selectedApproach = key;\n        break;\n      }\n    }\n    \n    // Adjust based on stage\n    selectedApproach = this.adjustForStage(selectedApproach, stage, score);\n    \n    // Consider task description if provided\n    if (taskDescription) {\n      selectedApproach = this.adjustForTask(selectedApproach, taskDescription, score);\n    }\n    \n    // Apply user preferences\n    selectedApproach = this.applyUserPreferences(selectedApproach, analysis);\n    \n    return this.prepareRecommendation(selectedApproach, analysis, score);\n  }\n\n  /**\n   * Validate user choice against analysis\n   */\n  validateUserChoice(userChoice, analysis) {\n    const score = analysis.score || 50;\n    let approach = null;\n    \n    // Map user choice to approach\n    switch (userChoice.toLowerCase()) {\n      case 'swarm':\n      case 'simple':\n      case 'simple-swarm':\n      case '1':\n        approach = 'simpleSwarm';\n        break;\n      case 'hive':\n      case 'hive-mind':\n      case 'hivemind':\n      case '2':\n        approach = 'hiveMind';\n        break;\n      case 'sparc':\n      case 'enterprise':\n      case 'hive-mind-sparc':\n      case '3':\n        approach = 'hiveMindSparc';\n        break;\n      default:\n        // Try to guess from choice\n        if (userChoice.includes('simple')) approach = 'simpleSwarm';\n        else if (userChoice.includes('sparc')) approach = 'hiveMindSparc';\n        else if (userChoice.includes('hive')) approach = 'hiveMind';\n    }\n    \n    if (!approach) {\n      return {\n        error: true,\n        message: `Invalid choice: ${userChoice}`,\n        validChoices: ['simple-swarm', 'hive-mind', 'hive-mind-sparc']\n      };\n    }\n    \n    // Check if choice matches recommendation\n    const recommended = this.getRecommendedApproach(score);\n    const mismatch = approach !== recommended;\n    \n    const result = this.prepareRecommendation(approach, analysis, score);\n    \n    if (mismatch) {\n      result.warning = this.generateMismatchWarning(approach, recommended, score);\n      result.mismatch = true;\n    }\n    \n    result.userSelected = true;\n    return result;\n  }\n\n  /**\n   * Adjust approach based on project stage\n   */\n  adjustForStage(approach, stage, score) {\n    switch (stage) {\n      case 'idea':\n        // Ideas often benefit from systematic planning\n        if (score > 20 && approach === 'simpleSwarm') {\n          return 'hiveMind'; // Upgrade to get better planning\n        }\n        break;\n      case 'mature':\n        // Mature projects might need more coordination\n        if (score > 60 && approach === 'hiveMind') {\n          return 'hiveMindSparc'; // Consider SPARC for better maintenance\n        }\n        break;\n    }\n    return approach;\n  }\n\n  /**\n   * Adjust approach based on task description\n   */\n  adjustForTask(approach, taskDescription, score) {\n    const task = taskDescription.toLowerCase();\n    \n    // Keywords suggesting simple tasks\n    const simpleKeywords = ['fix', 'bug', 'typo', 'style', 'rename', 'simple', 'quick', 'small'];\n    if (simpleKeywords.some(keyword => task.includes(keyword))) {\n      if (score < 50) return 'simpleSwarm';\n    }\n    \n    // Keywords suggesting complex tasks\n    const complexKeywords = ['architect', 'enterprise', 'system', 'redesign', 'refactor', 'migration', 'infrastructure'];\n    if (complexKeywords.some(keyword => task.includes(keyword))) {\n      if (score > 40) return 'hiveMindSparc';\n    }\n    \n    // Keywords suggesting multi-agent coordination\n    const coordinationKeywords = ['fullstack', 'full-stack', 'frontend and backend', 'multiple', 'parallel', 'team'];\n    if (coordinationKeywords.some(keyword => task.includes(keyword))) {\n      if (approach === 'simpleSwarm' && score > 20) return 'hiveMind';\n    }\n    \n    return approach;\n  }\n\n  /**\n   * Apply user preferences from history\n   */\n  applyUserPreferences(approach, analysis) {\n    if (!this.userPreferences || !this.userPreferences.history) {\n      return approach;\n    }\n    \n    // Check if user consistently overrides for similar projects\n    const similarProjects = this.userPreferences.history.filter(h => \n      Math.abs(h.score - analysis.score) < 10\n    );\n    \n    if (similarProjects.length >= 3) {\n      // User has consistent preference for similar complexity\n      const preferredApproach = this.getMostCommon(similarProjects.map(p => p.selected));\n      if (preferredApproach && preferredApproach !== approach) {\n        return preferredApproach;\n      }\n    }\n    \n    return approach;\n  }\n\n  /**\n   * Prepare recommendation object\n   */\n  prepareRecommendation(approachKey, analysis, score) {\n    const approach = this.approaches[approachKey];\n    \n    return {\n      selected: approachKey,\n      name: approach.name,\n      command: this.buildCommand(approach, analysis),\n      commands: this.buildCommands(approach, analysis),\n      score: score,\n      stage: analysis.stage,\n      description: approach.description,\n      timeEstimate: approach.timeEstimate,\n      agentCount: approach.agentCount,\n      bestFor: approach.bestFor,\n      reasoning: this.generateReasoning(approachKey, analysis),\n      matchScore: this.calculateMatchScore(approachKey, score),\n      alternatives: this.getAlternatives(approachKey, score),\n      setupSteps: this.getSetupSteps(approachKey, analysis)\n    };\n  }\n\n  /**\n   * Build actual command with parameters\n   */\n  buildCommand(approach, analysis) {\n    // Get the version suffix from centralized policy\n    const versionSuffix = versionPolicy.getSuffixForName(this.selectedVersion);\n    \n    // Build command with version\n    let baseCommand = approach.command.replace('npx claude-flow', `npx claude-flow${versionSuffix}`);\n    \n    // Add project-specific parameters\n    if (approach.name === 'Hive-Mind') {\n      const agentCount = this.determineAgentCount(analysis);\n      baseCommand += ` --agents ${agentCount} --claude`;\n      \n      // Add project name if available\n      const projectName = analysis.projectName || path.basename(process.cwd());\n      baseCommand += ` \"${projectName}\"`;\n    } else if (approach.name === 'Hive-Mind + SPARC') {\n      const agentCount = this.determineAgentCount(analysis, true);\n      baseCommand += ` --agents ${agentCount} --claude`;\n      \n      // Add project name\n      const projectName = analysis.projectName || path.basename(process.cwd());\n      baseCommand = baseCommand.replace('spawn', `spawn \"${projectName}\"`);\n    } else if (approach.name === 'Simple Swarm') {\n      // Add task description if provided\n      if (analysis.taskDescription) {\n        baseCommand += ` \"${analysis.taskDescription}\"`;\n      }\n    }\n    \n    return baseCommand;\n  }\n\n  /**\n   * Build commands array to avoid chaining with &&\n   */\n  buildCommands(approach, analysis) {\n    const versionSuffix = versionPolicy.getSuffixForName(this.selectedVersion);\n    const projectName = analysis.projectName || require('path').basename(process.cwd());\n\n    const commands = [];\n\n    if (approach.name === 'Hive-Mind + SPARC') {\n      const agentCount = this.determineAgentCount(analysis, true);\n      commands.push(\n        `npx claude-flow${versionSuffix} hive-mind spawn \"${projectName}\" --sparc --agents ${agentCount} --claude`,\n        `npx claude-flow${versionSuffix} sparc wizard --interactive`\n      );\n    }\n    else if (approach.name === 'Hive-Mind') {\n      const agentCount = this.determineAgentCount(analysis);\n      commands.push(\n        `npx claude-flow${versionSuffix} hive-mind spawn \"${projectName}\" --agents ${agentCount} --claude`\n      );\n    }\n    else if (approach.name === 'Simple Swarm') {\n      const task = analysis.taskDescription ? ` \"${analysis.taskDescription}\"` : '';\n      commands.push(\n        `npx claude-flow${versionSuffix} swarm${task}`\n      );\n    }\n    // Optional experimental/feature-flagged commands\n    const enableTraining = process.env.ENABLE_CF_TRAINING === 'true'\n      || (process.env.CF_ENABLE_EXPERIMENTAL === 'true' && versionPolicy.isExperimentalName(this.selectedVersion));\n    if (enableTraining) {\n      const epochs = Number(process.env.CF_TRAINING_EPOCHS || 3);\n      commands.push(`npx claude-flow${versionSuffix} training neural-train --epochs ${epochs}`);\n    }\n\n    const enableMemory = process.env.ENABLE_CF_MEMORY_OPS === 'true';\n    if (enableMemory) {\n      const action = (process.env.CF_MEMORY_ACTION || 'summarize').toLowerCase();\n      if (action === 'sync') {\n        commands.push(`npx claude-flow${versionSuffix} memory sync --project \"${projectName}\"`);\n      } else if (action === 'gc') {\n        commands.push(`npx claude-flow${versionSuffix} memory gc --project \"${projectName}\"`);\n      } else {\n        commands.push(`npx claude-flow${versionSuffix} memory summarize --project \"${projectName}\"`);\n      }\n    }\n\n    return commands;\n  }\n\n  /**\n   * Determine optimal agent count\n   */\n  determineAgentCount(analysis, sparc = false) {\n    const score = analysis.score || 50;\n    \n    if (sparc) {\n      if (score < 80) return 8;\n      if (score < 90) return 10;\n      return 12;\n    } else {\n      if (score < 40) return 4;\n      if (score < 60) return 5;\n      return 6;\n    }\n  }\n\n  /**\n   * Generate reasoning for selection\n   */\n  generateReasoning(approachKey, analysis) {\n    const reasons = [];\n    const score = analysis.score;\n    const stage = analysis.stage;\n    \n    // Score-based reasoning\n    if (approachKey === 'simpleSwarm') {\n      reasons.push(`Low complexity score (${score}/100) indicates straightforward task`);\n    } else if (approachKey === 'hiveMind') {\n      reasons.push(`Medium complexity score (${score}/100) requires coordinated approach`);\n    } else {\n      reasons.push(`High complexity score (${score}/100) benefits from systematic methodology`);\n    }\n    \n    // Stage-based reasoning\n    switch (stage) {\n      case 'idea':\n        reasons.push('Early stage project needs planning and architecture focus');\n        break;\n      case 'early':\n        reasons.push('Growing project benefits from establishing patterns');\n        break;\n      case 'active':\n        reasons.push('Active development requires efficient feature delivery');\n        break;\n      case 'mature':\n        reasons.push('Mature project needs maintenance and optimization focus');\n        break;\n    }\n    \n    // Factor-based reasoning\n    if (analysis.factors) {\n      if (analysis.factors.architecture?.score > 70) {\n        reasons.push('Complex architecture detected');\n      }\n      if (analysis.factors.features?.detected?.realtime) {\n        reasons.push('Real-time features require careful coordination');\n      }\n      if (analysis.factors.deployment?.kubernetes) {\n        reasons.push('Kubernetes deployment adds infrastructure complexity');\n      }\n    }\n    \n    return reasons;\n  }\n\n  /**\n   * Calculate match score for approach\n   */\n  calculateMatchScore(approachKey, score) {\n    const approach = this.approaches[approachKey];\n    const [min, max] = approach.scoreRange;\n    \n    if (score >= min && score <= max) {\n      // Perfect match within range\n      const rangeMiddle = (min + max) / 2;\n      const distance = Math.abs(score - rangeMiddle);\n      const maxDistance = (max - min) / 2;\n      return Math.round(100 - (distance / maxDistance * 20));\n    } else {\n      // Outside range, calculate distance penalty\n      const distance = score < min ? min - score : score - max;\n      return Math.max(0, Math.round(100 - distance * 2));\n    }\n  }\n\n  /**\n   * Get alternative approaches\n   */\n  getAlternatives(selected, score) {\n    const alternatives = [];\n    \n    for (const [key, approach] of Object.entries(this.approaches)) {\n      if (key !== selected) {\n        alternatives.push({\n          name: approach.name,\n          matchScore: this.calculateMatchScore(key, score),\n          command: approach.command\n        });\n      }\n    }\n    \n    return alternatives.sort((a, b) => b.matchScore - a.matchScore);\n  }\n\n  /**\n   * Get setup steps for approach\n   */\n  getSetupSteps(approachKey, analysis) {\n    const steps = [];\n    \n    // Common steps\n    steps.push('Initialize AI Dev OS environment');\n    steps.push('Analyze project complexity');\n    \n    // Approach-specific steps\n    switch (approachKey) {\n      case 'simpleSwarm':\n        steps.push('Set up simple Claude Flow swarm');\n        steps.push('Configure single-agent coordination');\n        steps.push('Initialize task-focused session');\n        break;\n      case 'hiveMind':\n        steps.push('Spawn Hive-Mind coordination system');\n        steps.push('Configure specialized agent roles');\n        steps.push('Set up cross-session memory');\n        steps.push('Initialize parallel execution environment');\n        break;\n      case 'hiveMindSparc':\n        steps.push('Initialize SPARC methodology phases');\n        steps.push('Spawn enterprise Hive-Mind system');\n        steps.push('Configure 8-12 specialized agents');\n        steps.push('Set up comprehensive documentation structure');\n        steps.push('Initialize cross-phase memory system');\n        break;\n    }\n    \n    // Stage-specific steps\n    if (analysis.stage === 'idea') {\n      steps.push('Generate foundational documentation');\n      steps.push('Create implementation roadmap');\n    } else if (analysis.stage === 'mature') {\n      steps.push('Document existing architecture');\n      steps.push('Set up maintenance workflows');\n    }\n    \n    return steps;\n  }\n\n  /**\n   * Generate mismatch warning\n   */\n  generateMismatchWarning(selected, recommended, score) {\n    const selectedApproach = this.approaches[selected];\n    const recommendedApproach = this.approaches[recommended];\n    \n    const warnings = [];\n    \n    if (selected === 'simpleSwarm' && score > 50) {\n      warnings.push('Simple Swarm may be insufficient for this complexity level');\n      warnings.push('Consider limited coordination capabilities');\n      warnings.push(`Recommended: ${recommendedApproach.name} for better results`);\n    } else if (selected === 'hiveMindSparc' && score < 30) {\n      warnings.push('SPARC methodology may be overkill for simple tasks');\n      warnings.push('Setup time will exceed task complexity');\n      warnings.push(`Recommended: ${recommendedApproach.name} for efficiency`);\n    } else {\n      warnings.push(`${selectedApproach.name} doesn't match complexity score (${score})`);\n      warnings.push(`Optimal approach: ${recommendedApproach.name}`);\n    }\n    \n    return {\n      level: Math.abs(score - selectedApproach.scoreRange[0]) > 30 ? 'high' : 'medium',\n      messages: warnings,\n      recommended: recommended\n    };\n  }\n\n  /**\n   * Get recommended approach for score\n   */\n  getRecommendedApproach(score) {\n    for (const [key, approach] of Object.entries(this.approaches)) {\n      if (score >= approach.scoreRange[0] && score <= approach.scoreRange[1]) {\n        return key;\n      }\n    }\n    return 'hiveMind'; // Default\n  }\n\n  /**\n   * Load user preferences\n   */\n  loadUserPreferences() {\n    const homeDir = process.env.HOME || process.env.USERPROFILE || os.homedir() || '.';\n    const prefsPath = path.join(homeDir, '.ai-dev-os', 'user-preferences.json');\n    try {\n      if (fs.existsSync(prefsPath)) {\n        return JSON.parse(fs.readFileSync(prefsPath, 'utf8'));\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n    return { history: [] };\n  }\n\n  /**\n   * Save user selection for learning\n   */\n  saveUserSelection(analysis, selected) {\n    const homeDir = process.env.HOME || process.env.USERPROFILE || os.homedir() || '.';\n    const prefsDir = path.join(homeDir, '.ai-dev-os');\n    const prefsPath = path.join(prefsDir, 'user-preferences.json');\n    \n    try {\n      if (!fs.existsSync(prefsDir)) {\n        fs.mkdirSync(prefsDir, { recursive: true });\n      }\n      \n      const prefs = this.loadUserPreferences();\n      if (!prefs.history) prefs.history = [];\n      \n      prefs.history.push({\n        timestamp: new Date().toISOString(),\n        score: analysis.score,\n        stage: analysis.stage,\n        selected: selected,\n        projectPath: process.cwd()\n      });\n      \n      // Keep only last 100 entries\n      if (prefs.history.length > 100) {\n        prefs.history = prefs.history.slice(-100);\n      }\n      \n      fs.writeFileSync(prefsPath, JSON.stringify(prefs, null, 2));\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n\n  /**\n   * Get most common element from array\n   */\n  getMostCommon(arr) {\n    if (!arr || arr.length === 0) return null;\n    \n    const counts = {};\n    for (const item of arr) {\n      counts[item] = (counts[item] || 0) + 1;\n    }\n    \n    let maxCount = 0;\n    let mostCommon = null;\n    for (const [item, count] of Object.entries(counts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        mostCommon = item;\n      }\n    }\n    \n    return mostCommon;\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  const selector = new ApproachSelector();\n  \n  // Parse command line arguments\n  const args = process.argv.slice(2);\n  const analysisPath = args[0];\n  const userChoice = args[1];\n  const taskDescription = args[2] || '';\n  \n  if (!analysisPath) {\n    console.error('Usage: approach-selector.js <analysis.json> [user-choice] [task-description]');\n    process.exit(1);\n  }\n  \n  try {\n    const analysis = JSON.parse(fs.readFileSync(analysisPath, 'utf8'));\n    const recommendation = selector.selectApproach(analysis, userChoice, taskDescription);\n    \n    // Save user selection if made\n    if (userChoice && !recommendation.error) {\n      selector.saveUserSelection(analysis, recommendation.selected);\n    }\n    \n    console.log(JSON.stringify(recommendation, null, 2));\n  } catch (error) {\n    console.error('Error:', error.message);\n    process.exit(1);\n  }\n}\n\nmodule.exports = ApproachSelector;",
          "size": 21506,
          "lastModified": "2025-08-12T03:29:56.714Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "ApproachSelector",
                "position": 286
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/claude-md-generator.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/claude-md-generator.js",
          "fileName": "claude-md-generator.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * CLAUDE.md Generator\n * Phase 3 Implementation - MASTER-WORKFLOW v3.0\n * \n * Generates comprehensive CLAUDE.md files that document workflow configuration,\n * sub-agent architecture, MCP server configurations, and custom instructions\n * based on deep codebase analysis.\n * \n * Features:\n * - Automatic complexity scoring and stage determination\n * - Workflow approach selection (Simple Swarm/Hive-Mind/Hive-Mind+SPARC)\n * - Sub-agent configuration matrix (10 agents with responsibilities)\n * - MCP server configuration (all 87 servers with auto-detection)\n * - Custom instruction generation based on codebase patterns\n * - Interactive setup wizard with customization options\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst readline = require('readline');\nconst chalk = require('chalk');\nconst EventEmitter = require('events');\n\n// Import existing components\nconst SharedMemoryStore = require('./shared-memory');\nconst ComplexityAnalyzer = require('./complexity-analyzer');\nconst ApproachSelector = require('./approach-selector');\nconst DeepCodebaseAnalyzer = require('./deep-codebase-analyzer');\nconst AgentCommunication = require('./agent-communication');\n\nclass ClaudeMdGenerator extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Integration with existing systems\n    this.sharedMemory = options.sharedMemory || new SharedMemoryStore();\n    this.complexityAnalyzer = options.complexityAnalyzer || new ComplexityAnalyzer();\n    this.approachSelector = options.approachSelector || new ApproachSelector();\n    this.deepAnalyzer = options.deepAnalyzer || new DeepCodebaseAnalyzer();\n    this.agentCommunication = options.agentCommunication || new AgentCommunication();\n    \n    // Configuration\n    this.config = {\n      interactive: true,\n      autoDetect: true,\n      includeMetrics: true,\n      includeExamples: true,\n      customInstructions: true,\n      ...options.config\n    };\n    \n    // MCP Server Categories (87 servers total)\n    this.mcpServerCategories = {\n      ESSENTIAL: [\n        'context7', 'filesystem', 'git', 'grep', 'http', 'memory'\n      ],\n      DEVELOPMENT: [\n        'docker', 'kubernetes', 'github', 'gitlab', 'jira', 'linear',\n        'npm', 'yarn', 'pnpm', 'composer', 'pip', 'cargo'\n      ],\n      DATABASE: [\n        'postgres', 'mysql', 'mongodb', 'redis', 'elasticsearch', \n        'dynamodb', 'cassandra', 'neo4j', 'sqlite', 'firestore'\n      ],\n      CLOUD: [\n        'aws', 'gcp', 'azure', 's3', 'cloudflare', 'vercel', \n        'netlify', 'heroku', 'digitalocean', 'linode'\n      ],\n      COMMUNICATION: [\n        'slack', 'discord', 'teams', 'twilio', 'sendgrid', \n        'mailgun', 'telegram', 'webhook', 'email', 'sms'\n      ],\n      MONITORING: [\n        'sentry', 'datadog', 'newrelic', 'prometheus', 'grafana',\n        'elastic', 'logstash', 'kibana', 'splunk', 'pagerduty'\n      ],\n      AI_ML: [\n        'openai', 'anthropic', 'huggingface', 'tensorflow', \n        'pytorch', 'langchain', 'pinecone', 'weaviate', 'qdrant'\n      ],\n      SPECIALIZED: [\n        'stripe', 'paypal', 'square', 'shopify', 'wordpress',\n        'drupal', 'magento', 'salesforce', 'hubspot', 'zendesk'\n      ],\n      TESTING: [\n        'jest', 'mocha', 'cypress', 'playwright', 'selenium',\n        'puppeteer', 'testcafe', 'vitest', 'jasmine', 'karma'\n      ],\n      BUILD_TOOLS: [\n        'webpack', 'vite', 'rollup', 'parcel', 'esbuild',\n        'turbo', 'nx', 'bazel', 'gradle', 'maven'\n      ]\n    };\n    \n    // Sub-agent templates (from Phase 2)\n    this.subAgents = [\n      'code-analyzer-agent',\n      'test-runner-agent',\n      'doc-generator-agent',\n      'api-builder-agent',\n      'database-architect-agent',\n      'security-scanner-agent',\n      'performance-optimizer-agent',\n      'deployment-engineer-agent',\n      'frontend-specialist-agent',\n      'recovery-specialist-agent'\n    ];\n    \n    // Workflow stages\n    this.stages = {\n      idea: { minComplexity: 0, maxComplexity: 10 },\n      early: { minComplexity: 11, maxComplexity: 30 },\n      active: { minComplexity: 31, maxComplexity: 60 },\n      mature: { minComplexity: 61, maxComplexity: 100 }\n    };\n    \n    // State management\n    this.analysis = null;\n    this.projectConfig = null;\n    this.selectedServers = new Set();\n    this.agentResponsibilities = new Map();\n    \n    this.setupEventHandlers();\n  }\n  \n  /**\n   * Setup event handlers\n   */\n  setupEventHandlers() {\n    this.agentCommunication.on('claude-md-request', this.handleGenerationRequest.bind(this));\n    this.deepAnalyzer.on('analysis-complete', this.handleAnalysisComplete.bind(this));\n  }\n  \n  /**\n   * Main entry point for CLAUDE.md generation\n   */\n  async generate(analysisOrPath = process.cwd(), options = {}) {\n    const generationId = `claude-md-${Date.now()}`;\n    \n    try {\n      console.log(chalk.cyan('\\n🎯 CLAUDE.md Generator v3.0'));\n      console.log(chalk.gray('Analyzing project and generating workflow configuration...\\n'));\n      \n      // Get or perform analysis\n      this.analysis = await this.getAnalysis(analysisOrPath);\n      \n      // Determine project configuration\n      this.projectConfig = await this.determineProjectConfig(this.analysis);\n      \n      // Interactive mode if enabled\n      if (this.config.interactive && !options.skipInteractive) {\n        await this.runInteractiveWizard();\n      } else {\n        // Auto-configuration\n        await this.autoConfigureProject();\n      }\n      \n      // Generate CLAUDE.md content\n      const content = await this.generateContent();\n      \n      // Preview if interactive\n      if (this.config.interactive && !options.skipPreview) {\n        await this.previewContent(content);\n        \n        const confirm = await this.askConfirmation('Save this configuration?');\n        if (!confirm) {\n          console.log(chalk.yellow('Generation cancelled by user.'));\n          return null;\n        }\n      }\n      \n      // Save CLAUDE.md\n      await this.saveClaudeMd(content);\n      \n      // Store in shared memory\n      await this.storeConfiguration(generationId, content);\n      \n      console.log(chalk.green('\\n✅ CLAUDE.md generated successfully!'));\n      \n      return {\n        generationId,\n        path: 'CLAUDE.md',\n        config: this.projectConfig\n      };\n      \n    } catch (error) {\n      this.emit('generation-error', { generationId, error });\n      throw error;\n    }\n  }\n  \n  /**\n   * Get or perform analysis\n   */\n  async getAnalysis(analysisOrPath) {\n    if (typeof analysisOrPath === 'object') {\n      // Already have analysis\n      return analysisOrPath;\n    }\n    \n    // Perform new analysis\n    console.log(chalk.cyan('🔍 Analyzing codebase...'));\n    const analysis = await this.deepAnalyzer.analyzeComplete(analysisOrPath);\n    \n    // Get complexity score\n    const complexity = await this.complexityAnalyzer.analyzeComplexity(analysisOrPath);\n    analysis.complexity = complexity;\n    \n    return analysis;\n  }\n  \n  /**\n   * Determine project configuration based on analysis\n   */\n  async determineProjectConfig(analysis) {\n    const config = {\n      projectName: path.basename(process.cwd()),\n      complexityScore: analysis.complexity?.score || 0,\n      stage: this.determineStage(analysis.complexity?.score || 0),\n      approach: await this.selectApproach(analysis),\n      architecture: analysis.architecture?.type || 'unknown',\n      languages: this.detectLanguages(analysis),\n      frameworks: this.detectFrameworks(analysis),\n      testingTools: this.detectTestingTools(analysis),\n      databases: this.detectDatabases(analysis),\n      apis: this.detectAPIs(analysis),\n      deployment: this.detectDeployment(analysis),\n      mcpServers: new Set(),\n      agentAssignments: new Map(),\n      customInstructions: []\n    };\n    \n    return config;\n  }\n  \n  /**\n   * Determine project stage based on complexity\n   */\n  determineStage(complexityScore) {\n    for (const [stage, range] of Object.entries(this.stages)) {\n      if (complexityScore >= range.minComplexity && complexityScore <= range.maxComplexity) {\n        return stage;\n      }\n    }\n    return 'active'; // Default\n  }\n  \n  /**\n   * Select workflow approach\n   */\n  async selectApproach(analysis) {\n    const selector = this.approachSelector;\n    const approach = await selector.selectApproach(analysis);\n    return approach;\n  }\n  \n  /**\n   * Run interactive configuration wizard\n   */\n  async runInteractiveWizard() {\n    console.log(chalk.cyan('\\n🧙 Interactive Configuration Wizard'));\n    console.log(chalk.gray('Let\\'s customize your CLAUDE.md configuration.\\n'));\n    \n    // Step 1: Confirm project details\n    console.log(chalk.bold('Step 1: Project Details'));\n    console.log(`  Project: ${this.projectConfig.projectName}`);\n    console.log(`  Complexity: ${this.projectConfig.complexityScore}/100`);\n    console.log(`  Stage: ${this.projectConfig.stage}`);\n    console.log(`  Architecture: ${this.projectConfig.architecture}`);\n    \n    const customizeName = await this.askYesNo('\\nCustomize project name?');\n    if (customizeName) {\n      this.projectConfig.projectName = await this.askInput('Project name:');\n    }\n    \n    // Step 2: Workflow approach\n    console.log(chalk.bold('\\nStep 2: Workflow Approach'));\n    console.log(`  Recommended: ${this.projectConfig.approach}`);\n    \n    const approaches = ['simple-swarm', 'hive-mind', 'hive-mind-sparc'];\n    console.log('\\n  Available approaches:');\n    console.log('  1) Simple Swarm - Basic agent coordination');\n    console.log('  2) Hive-Mind - Advanced Queen Controller with 10 agents');\n    console.log('  3) Hive-Mind + SPARC - Enterprise with methodology');\n    \n    const changeApproach = await this.askYesNo('\\nChange approach?');\n    if (changeApproach) {\n      const choice = await this.askChoice(['1', '2', '3']);\n      this.projectConfig.approach = approaches[parseInt(choice) - 1];\n    }\n    \n    // Step 3: MCP Server selection\n    console.log(chalk.bold('\\nStep 3: MCP Server Configuration'));\n    await this.configureMCPServers();\n    \n    // Step 4: Agent assignments\n    console.log(chalk.bold('\\nStep 4: Sub-Agent Assignments'));\n    await this.configureAgentAssignments();\n    \n    // Step 5: Custom instructions\n    console.log(chalk.bold('\\nStep 5: Custom Instructions'));\n    await this.configureCustomInstructions();\n  }\n  \n  /**\n   * Auto-configure project without interaction\n   */\n  async autoConfigureProject() {\n    console.log(chalk.cyan('🤖 Auto-configuring project...'));\n    \n    // Auto-detect MCP servers\n    this.projectConfig.mcpServers = await this.autoDetectMCPServers();\n    \n    // Auto-assign agents\n    this.projectConfig.agentAssignments = await this.autoAssignAgents();\n    \n    // Generate custom instructions\n    this.projectConfig.customInstructions = await this.generateCustomInstructions();\n  }\n  \n  /**\n   * Configure MCP servers interactively\n   */\n  async configureMCPServers() {\n    const detected = await this.autoDetectMCPServers();\n    \n    console.log(`\\n  Detected ${detected.size} relevant MCP servers:`);\n    let count = 0;\n    for (const server of detected) {\n      console.log(`    - ${server}`);\n      count++;\n      if (count >= 10 && detected.size > 10) {\n        console.log(`    ... and ${detected.size - 10} more`);\n        break;\n      }\n    }\n    \n    const customize = await this.askYesNo('\\nCustomize MCP server selection?');\n    if (customize) {\n      // Show categories and allow selection\n      for (const [category, servers] of Object.entries(this.mcpServerCategories)) {\n        console.log(chalk.yellow(`\\n  ${category}:`));\n        for (const server of servers) {\n          const enabled = detected.has(server);\n          const toggle = await this.askYesNo(`    ${server} (${enabled ? 'ON' : 'OFF'})?`);\n          if (toggle !== enabled) {\n            if (toggle) {\n              detected.add(server);\n            } else {\n              detected.delete(server);\n            }\n          }\n        }\n      }\n    }\n    \n    this.projectConfig.mcpServers = detected;\n  }\n  \n  /**\n   * Configure agent assignments interactively\n   */\n  async configureAgentAssignments() {\n    const assignments = await this.autoAssignAgents();\n    \n    console.log('\\n  Current agent assignments:');\n    for (const [agent, responsibilities] of assignments) {\n      console.log(`    ${agent}:`);\n      responsibilities.slice(0, 3).forEach(r => console.log(`      - ${r}`));\n      if (responsibilities.length > 3) {\n        console.log(`      ... and ${responsibilities.length - 3} more`);\n      }\n    }\n    \n    const customize = await this.askYesNo('\\nCustomize agent assignments?');\n    if (customize) {\n      // Allow reassignment of responsibilities\n      console.log(chalk.yellow('\\n  (Feature coming soon: Advanced agent customization)'));\n    }\n    \n    this.projectConfig.agentAssignments = assignments;\n  }\n  \n  /**\n   * Configure custom instructions\n   */\n  async configureCustomInstructions() {\n    const generated = await this.generateCustomInstructions();\n    \n    console.log('\\n  Generated instructions:');\n    generated.slice(0, 3).forEach(inst => console.log(`    - ${inst}`));\n    if (generated.length > 3) {\n      console.log(`    ... and ${generated.length - 3} more`);\n    }\n    \n    const addCustom = await this.askYesNo('\\nAdd custom instructions?');\n    if (addCustom) {\n      const instructions = [];\n      let adding = true;\n      while (adding) {\n        const instruction = await this.askInput('Instruction (empty to finish):');\n        if (instruction) {\n          instructions.push(instruction);\n        } else {\n          adding = false;\n        }\n      }\n      generated.push(...instructions);\n    }\n    \n    this.projectConfig.customInstructions = generated;\n  }\n  \n  /**\n   * Auto-detect relevant MCP servers\n   */\n  async autoDetectMCPServers() {\n    const servers = new Set(['context7', 'filesystem', 'git']); // Always include\n    \n    // Detect based on technologies\n    if (this.projectConfig.languages.includes('JavaScript') || \n        this.projectConfig.languages.includes('TypeScript')) {\n      servers.add('npm');\n    }\n    \n    if (this.projectConfig.frameworks.includes('React') || \n        this.projectConfig.frameworks.includes('Vue')) {\n      servers.add('vite');\n      servers.add('webpack');\n    }\n    \n    if (this.projectConfig.databases.includes('PostgreSQL')) {\n      servers.add('postgres');\n    }\n    \n    if (this.projectConfig.databases.includes('MongoDB')) {\n      servers.add('mongodb');\n    }\n    \n    if (this.analysis.apis?.rest?.length > 0) {\n      servers.add('http');\n      servers.add('openapi');\n    }\n    \n    if (this.projectConfig.deployment.includes('Docker')) {\n      servers.add('docker');\n    }\n    \n    if (this.projectConfig.deployment.includes('Kubernetes')) {\n      servers.add('kubernetes');\n    }\n    \n    if (this.projectConfig.testingTools.includes('Jest')) {\n      servers.add('jest');\n    }\n    \n    // Add cloud providers if detected\n    if (this.analysis.patterns?.cloudProviders?.includes('AWS')) {\n      servers.add('aws');\n      servers.add('s3');\n    }\n    \n    return servers;\n  }\n  \n  /**\n   * Auto-assign agents to responsibilities\n   */\n  async autoAssignAgents() {\n    const assignments = new Map();\n    \n    // Code Analyzer Agent\n    assignments.set('code-analyzer-agent', [\n      'Pattern extraction and analysis',\n      'Architecture detection',\n      'Code quality assessment',\n      'Dependency analysis'\n    ]);\n    \n    // Test Runner Agent\n    if (this.projectConfig.testingTools.length > 0) {\n      assignments.set('test-runner-agent', [\n        'Test execution and coverage',\n        'Test pattern analysis',\n        'Test suite optimization',\n        'Coverage gap identification'\n      ]);\n    }\n    \n    // API Builder Agent\n    if (this.analysis.apis && Object.keys(this.analysis.apis).length > 0) {\n      assignments.set('api-builder-agent', [\n        'API endpoint implementation',\n        'Schema validation',\n        'Authentication setup',\n        'API documentation'\n      ]);\n    }\n    \n    // Database Architect Agent\n    if (this.projectConfig.databases.length > 0) {\n      assignments.set('database-architect-agent', [\n        'Schema design and optimization',\n        'Query optimization',\n        'Migration management',\n        'Relationship mapping'\n      ]);\n    }\n    \n    // Security Scanner Agent\n    assignments.set('security-scanner-agent', [\n      'Vulnerability scanning',\n      'Security best practices',\n      'Dependency auditing',\n      'Compliance checking'\n    ]);\n    \n    // Performance Optimizer Agent\n    assignments.set('performance-optimizer-agent', [\n      'Performance bottleneck detection',\n      'Algorithm optimization',\n      'Memory usage analysis',\n      'Resource optimization'\n    ]);\n    \n    // Deployment Engineer Agent\n    if (this.projectConfig.deployment.length > 0) {\n      assignments.set('deployment-engineer-agent', [\n        'CI/CD pipeline setup',\n        'Deployment automation',\n        'Infrastructure as code',\n        'Zero-downtime deployments'\n      ]);\n    }\n    \n    // Frontend Specialist Agent\n    if (this.projectConfig.frameworks.some(f => \n      ['React', 'Vue', 'Angular', 'Svelte'].includes(f))) {\n      assignments.set('frontend-specialist-agent', [\n        'UI/UX implementation',\n        'Responsive design',\n        'Performance optimization',\n        'Accessibility compliance'\n      ]);\n    }\n    \n    // Doc Generator Agent\n    assignments.set('doc-generator-agent', [\n      'Documentation generation',\n      'API documentation',\n      'README maintenance',\n      'Code commenting'\n    ]);\n    \n    // Recovery Specialist Agent\n    assignments.set('recovery-specialist-agent', [\n      'Error recovery strategies',\n      'System resilience',\n      'Fallback mechanisms',\n      'Disaster recovery'\n    ]);\n    \n    return assignments;\n  }\n  \n  /**\n   * Generate custom instructions based on analysis\n   */\n  async generateCustomInstructions() {\n    const instructions = [];\n    \n    // Language-specific instructions\n    if (this.projectConfig.languages.includes('TypeScript')) {\n      instructions.push('Use strict TypeScript with proper type definitions');\n    }\n    \n    if (this.projectConfig.languages.includes('Python')) {\n      instructions.push('Follow PEP 8 style guide for Python code');\n    }\n    \n    // Framework-specific instructions\n    if (this.projectConfig.frameworks.includes('React')) {\n      instructions.push('Use functional components with hooks');\n      instructions.push('Implement proper error boundaries');\n    }\n    \n    // Architecture-specific instructions\n    if (this.projectConfig.architecture === 'microservices') {\n      instructions.push('Maintain service independence and loose coupling');\n      instructions.push('Use API contracts for service communication');\n    }\n    \n    // Testing instructions\n    if (this.projectConfig.testingTools.length > 0) {\n      instructions.push('Maintain test coverage above 80%');\n      instructions.push('Write tests before implementing features (TDD)');\n    }\n    \n    // Security instructions\n    if (this.analysis.security?.vulnerabilities?.length > 0) {\n      instructions.push('Address security vulnerabilities as priority');\n      instructions.push('Follow OWASP security guidelines');\n    }\n    \n    // Performance instructions\n    if (this.analysis.performance?.bottlenecks?.length > 0) {\n      instructions.push('Optimize identified performance bottlenecks');\n      instructions.push('Use lazy loading and code splitting');\n    }\n    \n    return instructions;\n  }\n  \n  /**\n   * Generate CLAUDE.md content\n   */\n  async generateContent() {\n    const content = [];\n    \n    // Header\n    content.push(`# Claude Configuration - ${this.projectConfig.projectName} (${this.projectConfig.stage} Stage)`);\n    content.push('');\n    \n    // Phase 3 marker\n    content.push('## Phase 3 Complete: Deep Analysis & Document Generation ✅');\n    content.push(`- **Implementation Date**: ${new Date().toLocaleDateString()}`);\n    content.push('- **Implementer**: Claude (Autonomous Workflow System)');\n    content.push('- **Status**: Successfully completed with comprehensive analysis');\n    content.push('');\n    \n    // Queen Controller Features\n    content.push('### Queen Controller Features');\n    content.push('- **10 Concurrent Sub-Agents**: Full capacity with specialized roles');\n    content.push('- **200k Context Windows**: Each agent tracks individual context');\n    content.push('- **Hierarchical Management**: Queen Controller orchestrates all agents');\n    content.push('- **Shared Memory Store**: Cross-agent data sharing with SQLite persistence');\n    content.push('- **Event-Driven Architecture**: Real-time agent coordination');\n    content.push('');\n    \n    // Project Analysis\n    content.push('## Project Analysis');\n    content.push(`- **Complexity Score**: ${this.projectConfig.complexityScore}/100`);\n    content.push(`- **Stage**: ${this.projectConfig.stage}`);\n    content.push(`- **Selected Approach**: ${this.projectConfig.approach}`);\n    content.push(`- **Architecture**: ${this.projectConfig.architecture}`);\n    content.push(`- **Command**: \\`npx --yes claude-flow@latest ${this.projectConfig.approach} spawn \"${this.projectConfig.projectName}\" --agents 10 --claude\\``);\n    content.push('');\n    \n    // Technology Stack\n    content.push('## Technology Stack');\n    \n    if (this.projectConfig.languages.length > 0) {\n      content.push('### Languages');\n      this.projectConfig.languages.forEach(lang => {\n        content.push(`- ${lang}`);\n      });\n      content.push('');\n    }\n    \n    if (this.projectConfig.frameworks.length > 0) {\n      content.push('### Frameworks');\n      this.projectConfig.frameworks.forEach(fw => {\n        content.push(`- ${fw}`);\n      });\n      content.push('');\n    }\n    \n    // Sub-Agent Assignments\n    content.push('## Sub-Agent Architecture & Responsibilities');\n    content.push('');\n    \n    let agentNum = 1;\n    for (const [agent, responsibilities] of this.projectConfig.agentAssignments) {\n      content.push(`### ${agentNum}. ${agent}`);\n      responsibilities.forEach(resp => {\n        content.push(`- ${resp}`);\n      });\n      content.push('');\n      agentNum++;\n    }\n    \n    // MCP Server Configuration\n    content.push('## MCP Server Configuration');\n    content.push(`### Active Servers (${this.projectConfig.mcpServers.size}/87)`);\n    \n    // Group servers by category\n    for (const [category, servers] of Object.entries(this.mcpServerCategories)) {\n      const activeInCategory = servers.filter(s => this.projectConfig.mcpServers.has(s));\n      if (activeInCategory.length > 0) {\n        content.push(`#### ${category}`);\n        activeInCategory.forEach(server => {\n          content.push(`- ${server}: {\"enabled\":true}`);\n        });\n        content.push('');\n      }\n    }\n    \n    // Custom Instructions\n    if (this.projectConfig.customInstructions.length > 0) {\n      content.push('## Project-Specific Instructions');\n      this.projectConfig.customInstructions.forEach(inst => {\n        content.push(`- ${inst}`);\n      });\n      content.push('');\n    }\n    \n    // Workflow Configuration\n    content.push('## Workflow Configuration');\n    content.push(`### ${this.projectConfig.approach} Workflow`);\n    \n    if (this.projectConfig.approach === 'hive-mind') {\n      content.push('1. Queen Controller initialization');\n      content.push('2. Sub-agent spawning (10 concurrent)');\n      content.push('3. Task distribution and dependency management');\n      content.push('4. Parallel execution with shared memory');\n      content.push('5. Result aggregation and reporting');\n    } else if (this.projectConfig.approach === 'hive-mind-sparc') {\n      content.push('1. SPARC methodology initialization');\n      content.push('2. Specification phase with deep analysis');\n      content.push('3. Pseudocode generation with Queen Controller');\n      content.push('4. Architecture implementation with 10 agents');\n      content.push('5. Refinement with continuous testing');\n      content.push('6. Completion with full documentation');\n    } else {\n      content.push('1. Simple agent coordination');\n      content.push('2. Sequential task execution');\n      content.push('3. Basic result aggregation');\n    }\n    content.push('');\n    \n    // Quality Metrics\n    content.push('## Quality Metrics');\n    content.push('- **Test Coverage Target**: 80%+');\n    content.push('- **Performance Benchmarks**: < 30s analysis time');\n    content.push('- **Security Score**: OWASP compliance');\n    content.push('- **Documentation Coverage**: 100%');\n    content.push('');\n    \n    // Version Policy\n    content.push('## Version Policy');\n    content.push('- Canonical versions: 3.0, alpha, beta, dev, latest, stable');\n    content.push('- Experimental: alpha, beta, dev');\n    content.push('- Override via env: CLAUDE_FLOW_VERSION=stable');\n    content.push('');\n    \n    // Footer\n    content.push('---');\n    content.push('');\n    content.push('*Generated by CLAUDE.md Generator v3.0*');\n    content.push(`*Date: ${new Date().toISOString()}*`);\n    content.push('*Phase 3: Deep Analysis & Document Generation Complete*');\n    \n    return content.join('\\n');\n  }\n  \n  /**\n   * Preview content before saving\n   */\n  async previewContent(content) {\n    console.log(chalk.cyan('\\n📄 CLAUDE.md Preview:'));\n    console.log(chalk.gray('=' .repeat(80)));\n    \n    // Show first 50 lines\n    const lines = content.split('\\n');\n    const preview = lines.slice(0, 50);\n    console.log(preview.join('\\n'));\n    \n    if (lines.length > 50) {\n      console.log(chalk.gray(`\\n... and ${lines.length - 50} more lines`));\n    }\n    \n    console.log(chalk.gray('=' .repeat(80)));\n  }\n  \n  /**\n   * Save CLAUDE.md file\n   */\n  async saveClaudeMd(content) {\n    await fs.writeFile('CLAUDE.md', content, 'utf8');\n  }\n  \n  /**\n   * Store configuration in shared memory\n   */\n  async storeConfiguration(generationId, content) {\n    await this.sharedMemory.set(\n      `claude-md:${generationId}`,\n      {\n        generationId,\n        content,\n        config: this.projectConfig,\n        timestamp: Date.now()\n      },\n      {\n        namespace: this.sharedMemory.namespaces.TASK_RESULTS,\n        dataType: this.sharedMemory.dataTypes.PERSISTENT\n      }\n    );\n  }\n  \n  // Detection helper methods\n  detectLanguages(analysis) {\n    const languages = new Set();\n    \n    // Check file extensions\n    if (analysis.patterns?.fileExtensions) {\n      const extMap = {\n        '.js': 'JavaScript',\n        '.jsx': 'JavaScript',\n        '.ts': 'TypeScript',\n        '.tsx': 'TypeScript',\n        '.py': 'Python',\n        '.java': 'Java',\n        '.cs': 'C#',\n        '.go': 'Go',\n        '.rs': 'Rust',\n        '.php': 'PHP',\n        '.rb': 'Ruby',\n        '.swift': 'Swift',\n        '.kt': 'Kotlin'\n      };\n      \n      for (const ext of analysis.patterns.fileExtensions) {\n        if (extMap[ext]) {\n          languages.add(extMap[ext]);\n        }\n      }\n    }\n    \n    return Array.from(languages);\n  }\n  \n  detectFrameworks(analysis) {\n    const frameworks = new Set();\n    \n    // Check package.json dependencies\n    if (analysis.patterns?.dependencies) {\n      const deps = analysis.patterns.dependencies;\n      \n      if (deps.react) frameworks.add('React');\n      if (deps.vue) frameworks.add('Vue');\n      if (deps.angular) frameworks.add('Angular');\n      if (deps.svelte) frameworks.add('Svelte');\n      if (deps.express) frameworks.add('Express');\n      if (deps.fastify) frameworks.add('Fastify');\n      if (deps.nestjs) frameworks.add('NestJS');\n      if (deps.django) frameworks.add('Django');\n      if (deps.flask) frameworks.add('Flask');\n      if (deps.rails) frameworks.add('Rails');\n    }\n    \n    return Array.from(frameworks);\n  }\n  \n  detectTestingTools(analysis) {\n    const tools = new Set();\n    \n    if (analysis.testing?.frameworks) {\n      analysis.testing.frameworks.forEach(fw => tools.add(fw));\n    }\n    \n    return Array.from(tools);\n  }\n  \n  detectDatabases(analysis) {\n    const databases = new Set();\n    \n    if (analysis.databases?.schemas) {\n      // Detect from connection strings or configs\n      if (analysis.databases.type) {\n        databases.add(analysis.databases.type);\n      }\n    }\n    \n    return Array.from(databases);\n  }\n  \n  detectAPIs(analysis) {\n    const apis = new Set();\n    \n    if (analysis.apis?.rest) apis.add('REST');\n    if (analysis.apis?.graphql) apis.add('GraphQL');\n    if (analysis.apis?.grpc) apis.add('gRPC');\n    if (analysis.apis?.websocket) apis.add('WebSocket');\n    \n    return Array.from(apis);\n  }\n  \n  detectDeployment(analysis) {\n    const deployment = new Set();\n    \n    // Check for deployment files\n    if (analysis.patterns?.files) {\n      if (analysis.patterns.files.includes('Dockerfile')) {\n        deployment.add('Docker');\n      }\n      if (analysis.patterns.files.includes('docker-compose.yml')) {\n        deployment.add('Docker Compose');\n      }\n      if (analysis.patterns.files.includes('kubernetes.yaml')) {\n        deployment.add('Kubernetes');\n      }\n    }\n    \n    return Array.from(deployment);\n  }\n  \n  // Interactive helper methods\n  async askYesNo(question) {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n    \n    return new Promise(resolve => {\n      rl.question(`${question} (y/n): `, answer => {\n        rl.close();\n        resolve(answer.toLowerCase() === 'y');\n      });\n    });\n  }\n  \n  async askInput(prompt) {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n    \n    return new Promise(resolve => {\n      rl.question(`${prompt} `, answer => {\n        rl.close();\n        resolve(answer);\n      });\n    });\n  }\n  \n  async askChoice(options) {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n    \n    return new Promise(resolve => {\n      rl.question(`Choose (${options.join('/')}): `, answer => {\n        rl.close();\n        if (options.includes(answer)) {\n          resolve(answer);\n        } else {\n          console.log(chalk.red('Invalid choice. Please try again.'));\n          resolve(this.askChoice(options));\n        }\n      });\n    });\n  }\n  \n  async askConfirmation(message) {\n    return await this.askYesNo(message);\n  }\n  \n  // Event handlers\n  handleGenerationRequest(data) {\n    const { analysis, options } = data;\n    this.generate(analysis, options);\n  }\n  \n  handleAnalysisComplete(data) {\n    const { analysis } = data;\n    this.emit('analysis-ready', analysis);\n  }\n}\n\n// Export for use in other modules\nmodule.exports = ClaudeMdGenerator;\n\n// CLI interface if run directly\nif (require.main === module) {\n  const generator = new ClaudeMdGenerator();\n  \n  const args = process.argv.slice(2);\n  const options = {\n    skipInteractive: args.includes('--auto'),\n    skipPreview: args.includes('--no-preview')\n  };\n  \n  generator.generate(process.cwd(), options)\n    .then(result => {\n      if (result) {\n        console.log('✅ Generation complete:', result);\n      }\n      process.exit(0);\n    })\n    .catch(error => {\n      console.error('❌ Generation failed:', error);\n      process.exit(1);\n    });\n}",
          "size": 31263,
          "lastModified": "2025-08-13T16:26:49.699Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "ClaudeMdGenerator",
                "position": 1212
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/agent-os-document-analyzer.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/agent-os-document-analyzer.js",
          "fileName": "agent-os-document-analyzer.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Agent-OS Document Analyzer\n * Comprehensive analysis of Agent-OS documents with customization detection and intelligent update strategies\n * \n * This component provides sophisticated document analysis capabilities for Agent-OS projects:\n * - Analyzes existing Agent-OS documents to understand current state\n * - Detects user customizations and modifications using advanced pattern matching\n * - Calculates intelligent update strategies for merging new templates with existing content\n * - Preserves user content during updates while applying improvements\n * - Provides detailed reporting on document changes and merge strategies\n * \n * Features:\n * - Multi-format document analysis (Markdown, JSON, YAML, JS, Shell)\n * - Advanced customization detection using AST parsing and pattern matching\n * - Intelligent merge strategies with conflict resolution\n * - Version-aware document comparison\n * - Integration with CustomizationManager and SharedMemoryStore\n * - Comprehensive reporting and analytics\n * - Event-driven architecture for real-time updates\n * \n * @author Claude Code\n * @date August 2025\n * @version 1.0.0\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst crypto = require('crypto');\nconst EventEmitter = require('events');\n\nclass AgentOSDocumentAnalyzer extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Configuration\n    this.projectRoot = options.projectRoot || process.cwd();\n    this.sharedMemory = options.sharedMemory;\n    this.customizationManager = options.customizationManager;\n    \n    // Core analysis components\n    this.documentCache = new Map();\n    this.analysisResults = new Map();\n    this.updateStrategiesCache = new Map();\n    this.mergeReports = new Map();\n    this.templateRegistry = new Map();\n    \n    // Analysis statistics\n    this.stats = {\n      documentsAnalyzed: 0,\n      customizationsDetected: 0,\n      updateStrategiesGenerated: 0,\n      mergeConflicts: 0,\n      preservedUserContent: 0,\n      successfulMerges: 0,\n      analysisTime: 0\n    };\n    \n    // Agent-OS document patterns and signatures\n    this.agentOSPatterns = {\n      // File patterns that indicate Agent-OS documents\n      filePatterns: [\n        /^CLAUDE\\.md$/i,\n        /^README\\.md$/i,\n        /^\\.claude\\/.*$/,\n        /^agent-os\\.json$/i,\n        /^package\\.json$/,\n        /^docker.*$/i,\n        /^compose.*\\.ya?ml$/i,\n        /^\\.env\\.example$/,\n        /install.*\\.sh$/i,\n        /setup.*\\.sh$/i\n      ],\n      \n      // Content signatures that identify Agent-OS generated content\n      contentSignatures: [\n        /# Claude Configuration/i,\n        /## Agent-OS/i,\n        /Generated by Agent-OS/i,\n        /claude-flow/i,\n        /hive-mind/i,\n        /sub-agent/i,\n        /@agent-os/i,\n        /AGENT_OS_VERSION/i,\n        /# DO NOT MODIFY - Agent-OS Managed/i\n      ],\n      \n      // Template markers\n      templateMarkers: [\n        /{{.*?}}/g,  // Handlebars-style\n        /\\$\\{.*?\\}/g,  // Template literals\n        /__.*?__/g,   // Double underscore placeholders\n        /\\[\\[.*?\\]\\]/g  // Double bracket placeholders\n      ]\n    };\n    \n    // Document type analyzers\n    this.analyzers = {\n      'markdown': this.analyzeMarkdownDocument.bind(this),\n      'json': this.analyzeJSONDocument.bind(this),\n      'yaml': this.analyzeYAMLDocument.bind(this),\n      'javascript': this.analyzeJavaScriptDocument.bind(this),\n      'shell': this.analyzeShellDocument.bind(this),\n      'dockerfile': this.analyzeDockerDocument.bind(this),\n      'text': this.analyzeTextDocument.bind(this)\n    };\n    \n    // Update strategy calculators\n    this.updateStrategies = {\n      'preserve-user': this.calculatePreserveUserStrategy.bind(this),\n      'merge-intelligent': this.calculateIntelligentMergeStrategy.bind(this),\n      'overwrite-safe': this.calculateSafeOverwriteStrategy.bind(this),\n      'version-control': this.calculateVersionControlStrategy.bind(this),\n      'incremental': this.calculateIncrementalStrategy.bind(this)\n    };\n    \n    this.isInitialized = false;\n    this.init();\n  }\n  \n  /**\n   * Initialize the document analyzer\n   */\n  async init() {\n    try {\n      // Initialize template registry\n      await this.initializeTemplateRegistry();\n      \n      // Load existing analysis cache if available\n      await this.loadAnalysisCache();\n      \n      this.isInitialized = true;\n      this.emit('initialized', { analyzerReady: true });\n      \n      console.log('AgentOSDocumentAnalyzer initialized successfully');\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to initialize AgentOSDocumentAnalyzer: ${error.message}`));\n      throw error;\n    }\n  }\n  \n  /**\n   * Analyze existing Agent-OS documents in a project\n   * @param {string} projectPath - Path to the project to analyze\n   * @param {object} options - Analysis options\n   */\n  async analyzeExistingDocs(projectPath, options = {}) {\n    const startTime = Date.now();\n    \n    try {\n      // Validate project path\n      if (!projectPath) {\n        throw new Error('Project path is required');\n      }\n      \n      const normalizedPath = path.resolve(projectPath);\n      \n      // Check if path exists\n      try {\n        await fs.access(normalizedPath);\n      } catch (error) {\n        throw new Error(`Project path does not exist: ${normalizedPath}`);\n      }\n      \n      const opts = {\n        recursive: options.recursive !== false, // Default to true\n        includeIgnored: options.includeIgnored || false,\n        analysisDepth: options.analysisDepth || 'full', // 'basic', 'standard', 'full', 'deep'\n        cacheResults: options.cacheResults !== false,\n        detectCustomizations: options.detectCustomizations !== false,\n        ...options\n      };\n      \n      console.log(`Starting document analysis for project: ${normalizedPath}`);\n      \n      // Discover Agent-OS documents\n      const documents = await this.discoverAgentOSDocuments(normalizedPath, opts);\n      \n      console.log(`Found ${documents.length} potential Agent-OS documents`);\n      \n      // Analyze each document\n      const analysisResults = new Map();\n      const analysisPromises = documents.map(async (docPath) => {\n        try {\n          const result = await this.analyzeDocument(docPath, opts);\n          if (result) {\n            analysisResults.set(docPath, result);\n          }\n        } catch (error) {\n          console.warn(`Failed to analyze document ${docPath}:`, error.message);\n          analysisResults.set(docPath, {\n            error: error.message,\n            analyzed: false,\n            path: docPath\n          });\n        }\n      });\n      \n      await Promise.all(analysisPromises);\n      \n      // Generate project-level analysis\n      const projectAnalysis = await this.generateProjectAnalysis(\n        normalizedPath, \n        analysisResults, \n        opts\n      );\n      \n      // Cache results if enabled\n      if (opts.cacheResults && this.sharedMemory) {\n        await this.cacheAnalysisResults(normalizedPath, projectAnalysis);\n      }\n      \n      // Update statistics\n      this.stats.documentsAnalyzed += documents.length;\n      this.stats.analysisTime += Date.now() - startTime;\n      \n      this.emit('analysis-complete', {\n        projectPath: normalizedPath,\n        documentsCount: documents.length,\n        analysisResults: projectAnalysis,\n        duration: Date.now() - startTime\n      });\n      \n      return projectAnalysis;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Detect user customizations in a document\n   * @param {object} doc - Document analysis result\n   * @param {object} options - Detection options\n   */\n  async detectCustomizations(doc, options = {}) {\n    try {\n      if (!doc || !doc.content) {\n        throw new Error('Document content is required for customization detection');\n      }\n      \n      const opts = {\n        useCustomizationManager: options.useCustomizationManager !== false,\n        analyzePatterns: options.analyzePatterns !== false,\n        detectStructuralChanges: options.detectStructuralChanges !== false,\n        analyzeSemanticChanges: options.analyzeSemanticChanges !== false,\n        includeMetadata: options.includeMetadata !== false,\n        ...options\n      };\n      \n      let customizations = [];\n      \n      // Use CustomizationManager if available\n      if (this.customizationManager && opts.useCustomizationManager) {\n        const templateContent = await this.getOriginalTemplate(doc);\n        if (templateContent) {\n          const detectedCustomizations = await this.customizationManager.detectCustomizations(\n            templateContent,\n            doc.content,\n            { filePath: doc.path }\n          );\n          customizations.push(...detectedCustomizations);\n        }\n      }\n      \n      // Analyze Agent-OS specific patterns\n      if (opts.analyzePatterns) {\n        const patternCustomizations = await this.detectAgentOSPatternCustomizations(doc);\n        customizations.push(...patternCustomizations);\n      }\n      \n      // Detect structural changes\n      if (opts.detectStructuralChanges) {\n        const structuralCustomizations = await this.detectStructuralCustomizations(doc);\n        customizations.push(...structuralCustomizations);\n      }\n      \n      // Analyze semantic changes\n      if (opts.analyzeSemanticChanges) {\n        const semanticCustomizations = await this.detectSemanticCustomizations(doc);\n        customizations.push(...semanticCustomizations);\n      }\n      \n      // Deduplicate and rank customizations\n      const uniqueCustomizations = this.deduplicateCustomizations(customizations);\n      const rankedCustomizations = this.rankCustomizations(uniqueCustomizations);\n      \n      // Store results\n      doc.customizations = rankedCustomizations;\n      \n      // Update statistics\n      this.stats.customizationsDetected += rankedCustomizations.length;\n      \n      this.emit('customizations-detected', {\n        document: doc.path,\n        customizations: rankedCustomizations,\n        count: rankedCustomizations.length\n      });\n      \n      return rankedCustomizations;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Calculate update strategy for merging existing document with new template\n   * @param {object} existing - Existing document analysis\n   * @param {object} newTemplate - New template content/analysis\n   * @param {object} options - Strategy options\n   */\n  async calculateUpdateStrategy(existing, newTemplate, options = {}) {\n    try {\n      if (!existing || !newTemplate) {\n        throw new Error('Both existing document and new template are required');\n      }\n      \n      const opts = {\n        strategy: options.strategy || 'merge-intelligent',\n        preserveUserContent: options.preserveUserContent !== false,\n        allowDestructiveUpdates: options.allowDestructiveUpdates || false,\n        versionControl: options.versionControl !== false,\n        generateReport: options.generateReport !== false,\n        riskLevel: options.riskLevel || 'medium', // 'low', 'medium', 'high'\n        ...options\n      };\n      \n      // Analyze differences between existing and new\n      const differences = await this.compareDocuments(existing, newTemplate);\n      \n      // Detect merge conflicts\n      const conflicts = await this.detectMergeConflicts(existing, newTemplate, differences);\n      \n      // Calculate strategy based on analysis\n      const strategyCalculator = this.updateStrategies[opts.strategy] || \n                                 this.updateStrategies['merge-intelligent'];\n      \n      const strategy = await strategyCalculator(existing, newTemplate, {\n        differences,\n        conflicts,\n        ...opts\n      });\n      \n      // Generate merge preview if requested\n      if (opts.generatePreview) {\n        strategy.preview = await this.generateMergePreview(existing, newTemplate, strategy);\n      }\n      \n      // Store strategy for future reference\n      const strategyKey = this.generateStrategyKey(existing.path, newTemplate);\n      this.updateStrategiesCache.set(strategyKey, strategy);\n      \n      // Update statistics\n      this.stats.updateStrategiesGenerated++;\n      if (conflicts.length > 0) {\n        this.stats.mergeConflicts += conflicts.length;\n      }\n      \n      this.emit('strategy-calculated', {\n        document: existing.path,\n        strategy: opts.strategy,\n        conflicts: conflicts.length,\n        riskLevel: strategy.riskLevel\n      });\n      \n      return strategy;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Preserve user content during document updates\n   * @param {object} existing - Existing document with customizations\n   * @param {object} template - New template to merge\n   * @param {object} options - Preservation options\n   */\n  async preserveUserContent(existing, template, options = {}) {\n    try {\n      if (!existing || !template) {\n        throw new Error('Both existing document and template are required');\n      }\n      \n      const opts = {\n        preserveComments: options.preserveComments !== false,\n        preserveCustomSections: options.preserveCustomSections !== false,\n        preserveConfigModifications: options.preserveConfigModifications !== false,\n        preservePersonalAdditions: options.preservePersonalAdditions !== false,\n        preserveOverrides: options.preserveOverrides !== false,\n        generateBackup: options.generateBackup !== false,\n        ...options\n      };\n      \n      // Extract user customizations if not already done\n      if (!existing.customizations) {\n        await this.detectCustomizations(existing);\n      }\n      \n      // Create preservation strategy\n      const preservationStrategy = {\n        customizations: [],\n        insertionPoints: [],\n        conflicts: [],\n        preservedContent: {},\n        strategy: 'preserve-and-merge'\n      };\n      \n      // Process each type of customization\n      for (const customization of existing.customizations || []) {\n        const preserved = await this.preserveCustomization(\n          customization, \n          template, \n          opts\n        );\n        \n        if (preserved) {\n          preservationStrategy.customizations.push(preserved);\n          preservationStrategy.preservedContent[customization.type] = \n            (preservationStrategy.preservedContent[customization.type] || 0) + 1;\n        }\n      }\n      \n      // Find optimal insertion points in new template\n      preservationStrategy.insertionPoints = await this.findInsertionPoints(\n        template,\n        preservationStrategy.customizations\n      );\n      \n      // Apply preservation strategy to create merged content\n      const mergedContent = await this.applyPreservationStrategy(\n        template,\n        preservationStrategy,\n        opts\n      );\n      \n      // Update statistics\n      this.stats.preservedUserContent += preservationStrategy.customizations.length;\n      \n      this.emit('content-preserved', {\n        document: existing.path,\n        customizations: preservationStrategy.customizations.length,\n        preservedTypes: Object.keys(preservationStrategy.preservedContent)\n      });\n      \n      return {\n        mergedContent,\n        preservationStrategy,\n        stats: preservationStrategy.preservedContent\n      };\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Extract custom sections from document content\n   * @param {string} content - Document content to analyze\n   * @param {object} options - Extraction options\n   */\n  async extractCustomSections(content, options = {}) {\n    try {\n      if (!content || typeof content !== 'string') {\n        throw new Error('Content must be a non-empty string');\n      }\n      \n      const opts = {\n        includeComments: options.includeComments !== false,\n        includeMarkedSections: options.includeMarkedSections !== false,\n        includeUserAdditions: options.includeUserAdditions !== false,\n        detectImplicitSections: options.detectImplicitSections || false,\n        ...options\n      };\n      \n      const customSections = [];\n      \n      // Extract explicitly marked custom sections\n      if (opts.includeMarkedSections) {\n        const markedSections = this.extractMarkedCustomSections(content);\n        customSections.push(...markedSections);\n      }\n      \n      // Extract user comments\n      if (opts.includeComments) {\n        const userComments = this.extractUserComments(content);\n        customSections.push(...userComments);\n      }\n      \n      // Extract user additions\n      if (opts.includeUserAdditions) {\n        const userAdditions = this.extractUserAdditions(content);\n        customSections.push(...userAdditions);\n      }\n      \n      // Detect implicit custom sections\n      if (opts.detectImplicitSections) {\n        const implicitSections = await this.detectImplicitCustomSections(content);\n        customSections.push(...implicitSections);\n      }\n      \n      // Sort by position in document\n      customSections.sort((a, b) => (a.position?.start || 0) - (b.position?.start || 0));\n      \n      return customSections;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Compare two documents for differences\n   * @param {object} doc1 - First document\n   * @param {object} doc2 - Second document\n   * @param {object} options - Comparison options\n   */\n  async compareDocuments(doc1, doc2, options = {}) {\n    try {\n      if (!doc1 || !doc2) {\n        throw new Error('Both documents are required for comparison');\n      }\n      \n      const opts = {\n        compareContent: options.compareContent !== false,\n        compareStructure: options.compareStructure !== false,\n        compareMetadata: options.compareMetadata !== false,\n        ignoreWhitespace: options.ignoreWhitespace || false,\n        ignoreComments: options.ignoreComments || false,\n        diffAlgorithm: options.diffAlgorithm || 'intelligent',\n        ...options\n      };\n      \n      const comparison = {\n        contentChanges: [],\n        structuralChanges: [],\n        metadataChanges: [],\n        similarity: 0,\n        changesSummary: {},\n        riskLevel: 'low'\n      };\n      \n      // Compare content\n      if (opts.compareContent) {\n        comparison.contentChanges = await this.compareContent(\n          doc1.content, \n          doc2.content, \n          opts\n        );\n      }\n      \n      // Compare structure\n      if (opts.compareStructure) {\n        comparison.structuralChanges = await this.compareStructure(\n          doc1.structure || await this.analyzeDocumentStructure(doc1),\n          doc2.structure || await this.analyzeDocumentStructure(doc2),\n          opts\n        );\n      }\n      \n      // Compare metadata\n      if (opts.compareMetadata) {\n        comparison.metadataChanges = await this.compareMetadata(\n          doc1.metadata || {},\n          doc2.metadata || {},\n          opts\n        );\n      }\n      \n      // Calculate similarity score\n      comparison.similarity = this.calculateSimilarity(comparison);\n      \n      // Assess risk level\n      comparison.riskLevel = this.assessRiskLevel(comparison);\n      \n      // Generate changes summary\n      comparison.changesSummary = this.summarizeChanges(comparison);\n      \n      return comparison;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Generate comprehensive merge report\n   * @param {object} existing - Existing document\n   * @param {object} template - New template\n   * @param {object} strategy - Update strategy\n   * @param {object} options - Report options\n   */\n  async generateMergeReport(existing, template, strategy, options = {}) {\n    try {\n      const opts = {\n        includePreview: options.includePreview !== false,\n        includeRiskAnalysis: options.includeRiskAnalysis !== false,\n        includeRecommendations: options.includeRecommendations !== false,\n        includeBackupPlan: options.includeBackupPlan !== false,\n        format: options.format || 'detailed', // 'summary', 'detailed', 'technical'\n        ...options\n      };\n      \n      const report = {\n        timestamp: Date.now(),\n        executiveeSummary: {},\n        documentAnalysis: {},\n        updateStrategy: {},\n        riskAssessment: {},\n        recommendations: [],\n        backupPlan: {},\n        preview: null,\n        metadata: {\n          analyzerVersion: '1.0.0',\n          projectPath: existing.projectPath,\n          documentPath: existing.path,\n          reportFormat: opts.format\n        }\n      };\n      \n      // Executive Summary\n      report.executiveSummary = {\n        documentType: existing.type,\n        documentSize: existing.content?.length || 0,\n        customizationsFound: existing.customizations?.length || 0,\n        updateComplexity: strategy.complexity || 'medium',\n        riskLevel: strategy.riskLevel || 'medium',\n        recommendedAction: strategy.recommendedAction || 'proceed-with-caution',\n        estimatedTime: strategy.estimatedTime || 'unknown'\n      };\n      \n      // Document Analysis\n      report.documentAnalysis = {\n        existingDocument: {\n          path: existing.path,\n          type: existing.type,\n          size: existing.content?.length || 0,\n          lastModified: existing.lastModified,\n          isAgentOSManaged: existing.isAgentOSManaged || false,\n          hasCustomizations: (existing.customizations?.length || 0) > 0,\n          customizations: existing.customizations || []\n        },\n        newTemplate: {\n          version: template.version,\n          changes: template.changes || [],\n          newFeatures: template.newFeatures || [],\n          deprecations: template.deprecations || []\n        }\n      };\n      \n      // Update Strategy Details\n      report.updateStrategy = {\n        strategy: strategy.strategy,\n        steps: strategy.steps || [],\n        preservationPlan: strategy.preservationPlan || {},\n        mergeConflicts: strategy.conflicts || [],\n        conflictResolution: strategy.conflictResolution || []\n      };\n      \n      // Risk Assessment\n      if (opts.includeRiskAnalysis) {\n        report.riskAssessment = await this.generateRiskAssessment(\n          existing, \n          template, \n          strategy\n        );\n      }\n      \n      // Recommendations\n      if (opts.includeRecommendations) {\n        report.recommendations = await this.generateRecommendations(\n          existing,\n          template,\n          strategy,\n          report\n        );\n      }\n      \n      // Backup Plan\n      if (opts.includeBackupPlan) {\n        report.backupPlan = await this.generateBackupPlan(existing, strategy);\n      }\n      \n      // Preview\n      if (opts.includePreview) {\n        report.preview = await this.generateMergePreview(existing, template, strategy);\n      }\n      \n      // Store report\n      const reportKey = this.generateReportKey(existing.path, template, strategy);\n      this.mergeReports.set(reportKey, report);\n      \n      this.emit('merge-report-generated', {\n        document: existing.path,\n        reportKey,\n        riskLevel: report.executiveSummary.riskLevel,\n        recommendations: report.recommendations.length\n      });\n      \n      return report;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Discover Agent-OS documents in a project\n   */\n  async discoverAgentOSDocuments(projectPath, options = {}) {\n    const documents = [];\n    \n    try {\n      const entries = await fs.readdir(projectPath, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(projectPath, entry.name);\n        \n        if (entry.isDirectory()) {\n          // Skip certain directories\n          if (this.shouldSkipDirectory(entry.name)) {\n            continue;\n          }\n          \n          // Recurse if enabled\n          if (options.recursive) {\n            const subDocs = await this.discoverAgentOSDocuments(fullPath, options);\n            documents.push(...subDocs);\n          }\n        } else if (entry.isFile()) {\n          // Check if file matches Agent-OS patterns\n          if (await this.isAgentOSDocument(fullPath, entry.name)) {\n            documents.push(fullPath);\n          }\n        }\n      }\n      \n    } catch (error) {\n      console.warn(`Failed to read directory ${projectPath}:`, error.message);\n    }\n    \n    return documents;\n  }\n  \n  /**\n   * Check if a file is an Agent-OS document\n   */\n  async isAgentOSDocument(filePath, fileName) {\n    try {\n      // Check file name patterns\n      const matchesPattern = this.agentOSPatterns.filePatterns.some(pattern => \n        pattern.test(fileName)\n      );\n      \n      if (matchesPattern) {\n        return true;\n      }\n      \n      // Check content signatures for other files\n      try {\n        const content = await fs.readFile(filePath, 'utf-8');\n        const hasSignature = this.agentOSPatterns.contentSignatures.some(signature =>\n          signature.test(content)\n        );\n        \n        return hasSignature;\n      } catch (error) {\n        // If we can't read the file, assume it's not an Agent-OS document\n        return false;\n      }\n      \n    } catch (error) {\n      return false;\n    }\n  }\n  \n  /**\n   * Analyze a single document\n   */\n  async analyzeDocument(docPath, options = {}) {\n    try {\n      const content = await fs.readFile(docPath, 'utf-8');\n      const stats = await fs.stat(docPath);\n      const fileName = path.basename(docPath);\n      const extension = path.extname(docPath).slice(1).toLowerCase();\n      \n      // Determine document type\n      const docType = this.detectDocumentType(fileName, extension, content);\n      \n      // Basic document information\n      const document = {\n        path: docPath,\n        fileName,\n        extension,\n        type: docType,\n        content,\n        size: content.length,\n        lastModified: stats.mtime,\n        createdAt: stats.birthtime || stats.mtime,\n        isAgentOSManaged: false,\n        agentOSVersion: null,\n        templateVersion: null,\n        customizations: [],\n        structure: null,\n        metadata: {},\n        analysis: {\n          complexity: 'unknown',\n          customizationLevel: 'unknown',\n          updateRisk: 'unknown'\n        }\n      };\n      \n      // Use specific analyzer based on document type\n      const analyzer = this.analyzers[docType] || this.analyzers['text'];\n      const analysisResult = await analyzer(document, options);\n      \n      // Merge analysis results\n      Object.assign(document, analysisResult);\n      \n      // Detect customizations if enabled\n      if (options.detectCustomizations) {\n        await this.detectCustomizations(document, options);\n      }\n      \n      // Cache result if enabled\n      if (options.cacheResults) {\n        this.documentCache.set(docPath, document);\n      }\n      \n      return document;\n      \n    } catch (error) {\n      throw new Error(`Failed to analyze document ${docPath}: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Detect document type from various indicators\n   */\n  detectDocumentType(fileName, extension, content) {\n    // Check extension first\n    const typeByExtension = {\n      'md': 'markdown',\n      'json': 'json',\n      'yml': 'yaml',\n      'yaml': 'yaml',\n      'js': 'javascript',\n      'ts': 'javascript',\n      'sh': 'shell',\n      'bash': 'shell',\n      'zsh': 'shell',\n      'dockerfile': 'dockerfile',\n      'txt': 'text'\n    };\n    \n    if (typeByExtension[extension]) {\n      return typeByExtension[extension];\n    }\n    \n    // Check file name patterns\n    if (/dockerfile/i.test(fileName)) {\n      return 'dockerfile';\n    }\n    \n    if (/docker-compose|compose/i.test(fileName)) {\n      return 'yaml';\n    }\n    \n    // Check content patterns\n    if (content.includes('#!/bin/bash') || content.includes('#!/bin/sh')) {\n      return 'shell';\n    }\n    \n    if (content.trim().startsWith('{') && content.trim().endsWith('}')) {\n      return 'json';\n    }\n    \n    if (/^---\\s*$/m.test(content) || /^\\w+:\\s*\\w+/m.test(content)) {\n      return 'yaml';\n    }\n    \n    return 'text';\n  }\n  \n  /**\n   * Analyze Markdown documents\n   */\n  async analyzeMarkdownDocument(document, options = {}) {\n    const analysis = {\n      structure: this.parseMarkdownStructure(document.content),\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      templateMarkers: [],\n      customSections: []\n    };\n    \n    // Check for Agent-OS management markers\n    const agentOSMatch = document.content.match(/# Claude Configuration.*?(?=\\n#|\\n\\n|$)/s);\n    if (agentOSMatch) {\n      analysis.isAgentOSManaged = true;\n      \n      // Extract version info\n      const versionMatch = document.content.match(/Version[:\\s]+([\\d.]+)/i);\n      if (versionMatch) {\n        analysis.agentOSVersion = versionMatch[1];\n      }\n    }\n    \n    // Find template markers\n    for (const pattern of this.agentOSPatterns.templateMarkers) {\n      const matches = [...document.content.matchAll(pattern)];\n      analysis.templateMarkers.push(...matches.map(match => ({\n        marker: match[0],\n        position: match.index,\n        type: 'template-variable'\n      })));\n    }\n    \n    // Extract custom sections\n    analysis.customSections = await this.extractCustomSections(document.content, {\n      documentType: 'markdown'\n    });\n    \n    return analysis;\n  }\n  \n  /**\n   * Analyze JSON documents\n   */\n  async analyzeJSONDocument(document, options = {}) {\n    const analysis = {\n      structure: null,\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      configModifications: [],\n      originalKeys: []\n    };\n    \n    try {\n      const parsed = JSON.parse(document.content);\n      analysis.structure = this.analyzeJSONStructure(parsed);\n      \n      // Check for Agent-OS specific keys\n      if (parsed['agent-os'] || parsed.agentOS || parsed.AGENT_OS_VERSION) {\n        analysis.isAgentOSManaged = true;\n        analysis.agentOSVersion = parsed['agent-os']?.version || \n                                 parsed.agentOS?.version ||\n                                 parsed.AGENT_OS_VERSION;\n      }\n      \n      // Check package.json specifics\n      if (document.fileName === 'package.json') {\n        analysis.packageAnalysis = await this.analyzePackageJSON(parsed);\n      }\n      \n    } catch (error) {\n      console.warn(`Failed to parse JSON in ${document.path}:`, error.message);\n    }\n    \n    return analysis;\n  }\n  \n  /**\n   * Analyze YAML documents\n   */\n  async analyzeYAMLDocument(document, options = {}) {\n    const analysis = {\n      structure: this.parseYAMLStructure(document.content),\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      services: [],\n      volumes: [],\n      networks: []\n    };\n    \n    // Check for Agent-OS markers in comments\n    const agentOSComments = document.content.match(/#.*Agent-OS.*version.*?([\\d.]+)/i);\n    if (agentOSComments) {\n      analysis.isAgentOSManaged = true;\n      analysis.agentOSVersion = agentOSComments[1];\n    }\n    \n    // Analyze Docker Compose specifics\n    if (/compose|docker-compose/i.test(document.fileName)) {\n      analysis.dockerComposeAnalysis = await this.analyzeDockerCompose(document.content);\n    }\n    \n    return analysis;\n  }\n  \n  /**\n   * Analyze JavaScript/TypeScript documents\n   */\n  async analyzeJavaScriptDocument(document, options = {}) {\n    const analysis = {\n      structure: this.parseJavaScriptStructure(document.content),\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      imports: [],\n      exports: [],\n      classes: [],\n      functions: []\n    };\n    \n    // Check for Agent-OS markers in comments\n    const agentOSComment = document.content.match(/\\/\\*.*Agent-OS.*version.*?([\\d.]+).*?\\*\\//s);\n    if (agentOSComment) {\n      analysis.isAgentOSManaged = true;\n      analysis.agentOSVersion = agentOSComment[1];\n    }\n    \n    return analysis;\n  }\n  \n  /**\n   * Analyze Shell script documents\n   */\n  async analyzeShellDocument(document, options = {}) {\n    const analysis = {\n      structure: this.parseShellStructure(document.content),\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      variables: [],\n      functions: [],\n      commands: []\n    };\n    \n    // Check for Agent-OS markers in comments\n    const agentOSComment = document.content.match(/#.*Agent-OS.*version.*?([\\d.]+)/i);\n    if (agentOSComment) {\n      analysis.isAgentOSManaged = true;\n      analysis.agentOSVersion = agentOSComment[1];\n    }\n    \n    return analysis;\n  }\n  \n  /**\n   * Analyze Docker documents\n   */\n  async analyzeDockerDocument(document, options = {}) {\n    const analysis = {\n      structure: this.parseDockerStructure(document.content),\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      baseImage: null,\n      instructions: [],\n      exposedPorts: [],\n      volumes: []\n    };\n    \n    // Check for Agent-OS markers in comments\n    const agentOSComment = document.content.match(/#.*Agent-OS.*version.*?([\\d.]+)/i);\n    if (agentOSComment) {\n      analysis.isAgentOSManaged = true;\n      analysis.agentOSVersion = agentOSComment[1];\n    }\n    \n    // Extract base image\n    const fromMatch = document.content.match(/^FROM\\s+(.+)$/m);\n    if (fromMatch) {\n      analysis.baseImage = fromMatch[1];\n    }\n    \n    return analysis;\n  }\n  \n  /**\n   * Analyze text documents\n   */\n  async analyzeTextDocument(document, options = {}) {\n    const analysis = {\n      structure: this.parseTextStructure(document.content),\n      isAgentOSManaged: false,\n      agentOSVersion: null,\n      lineCount: document.content.split('\\n').length,\n      wordCount: document.content.split(/\\s+/).length,\n      charCount: document.content.length\n    };\n    \n    // Check for any Agent-OS signatures\n    const hasSignature = this.agentOSPatterns.contentSignatures.some(signature =>\n      signature.test(document.content)\n    );\n    \n    if (hasSignature) {\n      analysis.isAgentOSManaged = true;\n    }\n    \n    return analysis;\n  }\n  \n  /**\n   * Helper methods for structure parsing\n   */\n  parseMarkdownStructure(content) {\n    const structure = {\n      headers: [],\n      codeBlocks: [],\n      lists: [],\n      links: [],\n      images: []\n    };\n    \n    const lines = content.split('\\n');\n    \n    lines.forEach((line, index) => {\n      // Headers\n      const headerMatch = line.match(/^(#{1,6})\\s+(.+)$/);\n      if (headerMatch) {\n        structure.headers.push({\n          level: headerMatch[1].length,\n          text: headerMatch[2],\n          line: index\n        });\n      }\n      \n      // Lists\n      const listMatch = line.match(/^(\\s*)[-*+]\\s+(.+)$/);\n      if (listMatch) {\n        structure.lists.push({\n          indent: listMatch[1].length,\n          text: listMatch[2],\n          line: index\n        });\n      }\n      \n      // Links\n      const linkMatches = [...line.matchAll(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g)];\n      linkMatches.forEach(match => {\n        structure.links.push({\n          text: match[1],\n          url: match[2],\n          line: index,\n          position: match.index\n        });\n      });\n    });\n    \n    return structure;\n  }\n  \n  parseJavaScriptStructure(content) {\n    const structure = {\n      functions: [],\n      classes: [],\n      imports: [],\n      exports: [],\n      variables: []\n    };\n    \n    // Simple regex-based parsing (could be enhanced with AST)\n    const functionMatches = [...content.matchAll(/(?:function\\s+(\\w+)|(\\w+)\\s*=\\s*(?:function|\\(.*?\\)\\s*=>))/g)];\n    functionMatches.forEach(match => {\n      structure.functions.push({\n        name: match[1] || match[2],\n        position: match.index\n      });\n    });\n    \n    const classMatches = [...content.matchAll(/class\\s+(\\w+)/g)];\n    classMatches.forEach(match => {\n      structure.classes.push({\n        name: match[1],\n        position: match.index\n      });\n    });\n    \n    return structure;\n  }\n  \n  parseShellStructure(content) {\n    const structure = {\n      functions: [],\n      variables: [],\n      commands: []\n    };\n    \n    // Function definitions\n    const functionMatches = [...content.matchAll(/(\\w+)\\(\\)\\s*\\{/g)];\n    functionMatches.forEach(match => {\n      structure.functions.push({\n        name: match[1],\n        position: match.index\n      });\n    });\n    \n    // Variable assignments\n    const variableMatches = [...content.matchAll(/^(\\w+)=/gm)];\n    variableMatches.forEach(match => {\n      structure.variables.push({\n        name: match[1],\n        position: match.index\n      });\n    });\n    \n    return structure;\n  }\n  \n  parseDockerStructure(content) {\n    const structure = {\n      instructions: [],\n      stages: []\n    };\n    \n    const lines = content.split('\\n');\n    lines.forEach((line, index) => {\n      const instructionMatch = line.match(/^(\\w+)\\s+(.+)$/);\n      if (instructionMatch) {\n        structure.instructions.push({\n          instruction: instructionMatch[1],\n          args: instructionMatch[2],\n          line: index\n        });\n      }\n    });\n    \n    return structure;\n  }\n  \n  parseYAMLStructure(content) {\n    const structure = {\n      keys: [],\n      sections: []\n    };\n    \n    const lines = content.split('\\n');\n    lines.forEach((line, index) => {\n      const keyMatch = line.match(/^(\\s*)([^:]+):\\s*(.*)?$/);\n      if (keyMatch) {\n        structure.keys.push({\n          indent: keyMatch[1].length,\n          key: keyMatch[2].trim(),\n          value: keyMatch[3],\n          line: index\n        });\n      }\n    });\n    \n    return structure;\n  }\n  \n  parseTextStructure(content) {\n    const lines = content.split('\\n');\n    return {\n      lineCount: lines.length,\n      nonEmptyLines: lines.filter(line => line.trim()).length,\n      sections: []\n    };\n  }\n  \n  analyzeJSONStructure(obj) {\n    const structure = {\n      keys: Object.keys(obj),\n      depth: this.calculateJSONDepth(obj),\n      arrays: [],\n      objects: []\n    };\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (Array.isArray(value)) {\n        structure.arrays.push(key);\n      } else if (typeof value === 'object' && value !== null) {\n        structure.objects.push(key);\n      }\n    }\n    \n    return structure;\n  }\n  \n  calculateJSONDepth(obj, depth = 0) {\n    if (typeof obj !== 'object' || obj === null) {\n      return depth;\n    }\n    \n    let maxDepth = depth;\n    for (const value of Object.values(obj)) {\n      if (typeof value === 'object' && value !== null) {\n        maxDepth = Math.max(maxDepth, this.calculateJSONDepth(value, depth + 1));\n      }\n    }\n    \n    return maxDepth;\n  }\n  \n  /**\n   * Additional helper methods\n   */\n  shouldSkipDirectory(dirName) {\n    const skipDirs = [\n      'node_modules',\n      '.git',\n      '.hive-mind',\n      'dist',\n      'build',\n      'coverage',\n      '.nyc_output',\n      'logs',\n      'tmp',\n      'temp'\n    ];\n    \n    return skipDirs.includes(dirName) || dirName.startsWith('.');\n  }\n  \n  deduplicateCustomizations(customizations) {\n    const seen = new Set();\n    return customizations.filter(custom => {\n      const key = `${custom.type}:${custom.position?.start}:${custom.content}`;\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n  \n  rankCustomizations(customizations) {\n    return customizations.sort((a, b) => {\n      // Sort by confidence (higher first), then by position\n      if (a.confidence !== b.confidence) {\n        return b.confidence - a.confidence;\n      }\n      return (a.position?.start || 0) - (b.position?.start || 0);\n    });\n  }\n  \n  generateStrategyKey(docPath, template) {\n    const content = `${docPath}:${template.version || 'unknown'}:${Date.now()}`;\n    return crypto.createHash('md5').update(content).digest('hex').substring(0, 12);\n  }\n  \n  generateReportKey(docPath, template, strategy) {\n    const content = `${docPath}:${template.version}:${strategy.strategy}:${Date.now()}`;\n    return crypto.createHash('md5').update(content).digest('hex').substring(0, 12);\n  }\n  \n  async initializeTemplateRegistry() {\n    // Initialize with common Agent-OS templates\n    this.templateRegistry.set('claude-md', {\n      version: '2.1.0',\n      structure: 'markdown',\n      sections: ['configuration', 'project-analysis', 'technology-stack']\n    });\n    \n    this.templateRegistry.set('package-json', {\n      version: '1.0.0',\n      structure: 'json',\n      requiredKeys: ['name', 'version', 'dependencies']\n    });\n  }\n  \n  async loadAnalysisCache() {\n    if (this.sharedMemory) {\n      try {\n        const cacheKeys = await this.sharedMemory.keys({\n          namespace: this.sharedMemory.namespaces.CACHE,\n          pattern: 'document-analysis:*'\n        });\n        \n        console.log(`Loaded ${cacheKeys.length} cached document analyses`);\n      } catch (error) {\n        console.warn('Failed to load analysis cache:', error.message);\n      }\n    }\n  }\n  \n  /**\n   * Placeholder methods for comprehensive functionality\n   * These can be implemented as the system evolves\n   */\n  \n  async getOriginalTemplate(doc) {\n    // Placeholder: Retrieve original template for comparison\n    return null;\n  }\n  \n  async detectAgentOSPatternCustomizations(doc) {\n    // Placeholder: Detect Agent-OS specific customization patterns\n    return [];\n  }\n  \n  async detectStructuralCustomizations(doc) {\n    // Placeholder: Detect structural modifications\n    return [];\n  }\n  \n  async detectSemanticCustomizations(doc) {\n    // Placeholder: Detect semantic changes in content\n    return [];\n  }\n  \n  async detectMergeConflicts(existing, newTemplate, differences) {\n    // Placeholder: Detect potential merge conflicts\n    return [];\n  }\n  \n  async calculatePreserveUserStrategy(existing, newTemplate, options) {\n    // Placeholder: Calculate preservation-focused strategy\n    return {\n      strategy: 'preserve-user',\n      steps: [],\n      riskLevel: 'low',\n      estimatedTime: '5-10 minutes'\n    };\n  }\n  \n  async calculateIntelligentMergeStrategy(existing, newTemplate, options) {\n    // Placeholder: Calculate intelligent merge strategy\n    return {\n      strategy: 'merge-intelligent',\n      steps: [],\n      riskLevel: 'medium',\n      estimatedTime: '10-15 minutes'\n    };\n  }\n  \n  async calculateSafeOverwriteStrategy(existing, newTemplate, options) {\n    // Placeholder: Calculate safe overwrite strategy\n    return {\n      strategy: 'overwrite-safe',\n      steps: [],\n      riskLevel: 'high',\n      estimatedTime: '2-5 minutes'\n    };\n  }\n  \n  async calculateVersionControlStrategy(existing, newTemplate, options) {\n    // Placeholder: Calculate version control strategy\n    return {\n      strategy: 'version-control',\n      steps: [],\n      riskLevel: 'low',\n      estimatedTime: '15-20 minutes'\n    };\n  }\n  \n  async calculateIncrementalStrategy(existing, newTemplate, options) {\n    // Placeholder: Calculate incremental update strategy\n    return {\n      strategy: 'incremental',\n      steps: [],\n      riskLevel: 'low',\n      estimatedTime: '5-10 minutes'\n    };\n  }\n  \n  async generateProjectAnalysis(projectPath, analysisResults, options) {\n    // Placeholder: Generate comprehensive project-level analysis\n    return {\n      projectPath,\n      totalDocuments: analysisResults.size,\n      agentOSDocuments: Array.from(analysisResults.values()).filter(doc => doc.isAgentOSManaged).length,\n      documentsWithCustomizations: Array.from(analysisResults.values()).filter(doc => doc.customizations?.length > 0).length,\n      analysisResults: Object.fromEntries(analysisResults),\n      recommendations: []\n    };\n  }\n  \n  async cacheAnalysisResults(projectPath, analysis) {\n    if (this.sharedMemory) {\n      const key = `document-analysis:${crypto.createHash('md5').update(projectPath).digest('hex')}`;\n      await this.sharedMemory.set(key, analysis, {\n        namespace: this.sharedMemory.namespaces.CACHE,\n        dataType: this.sharedMemory.dataTypes.CACHED,\n        ttl: 86400000 // 24 hours\n      });\n    }\n  }\n  \n  // Additional placeholder methods for completeness\n  extractMarkedCustomSections(content) { return []; }\n  extractUserComments(content) { return []; }\n  extractUserAdditions(content) { return []; }\n  async detectImplicitCustomSections(content) { return []; }\n  async preserveCustomization(customization, template, options) { return null; }\n  async findInsertionPoints(template, customizations) { return []; }\n  async applyPreservationStrategy(template, strategy, options) { return ''; }\n  async compareContent(content1, content2, options) { return []; }\n  async compareStructure(struct1, struct2, options) { return []; }\n  async compareMetadata(meta1, meta2, options) { return []; }\n  calculateSimilarity(comparison) { return 0.5; }\n  assessRiskLevel(comparison) { return 'medium'; }\n  summarizeChanges(comparison) { return {}; }\n  async generateRiskAssessment(existing, template, strategy) { return {}; }\n  async generateRecommendations(existing, template, strategy, report) { return []; }\n  async generateBackupPlan(existing, strategy) { return {}; }\n  async generateMergePreview(existing, template, strategy) { return null; }\n  async analyzePackageJSON(parsed) { return {}; }\n  async analyzeDockerCompose(content) { return {}; }\n  async analyzeDocumentStructure(doc) { return {}; }\n}\n\nmodule.exports = AgentOSDocumentAnalyzer;",
          "size": 45323,
          "lastModified": "2025-08-13T17:48:09.316Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": true,
          "agentOSVersion": ".",
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "AgentOSDocumentAnalyzer",
                "position": 1291
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/complexity-analyzer.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/complexity-analyzer.js",
          "fileName": "complexity-analyzer.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Project Complexity Analyzer\n * Analyzes project characteristics and calculates complexity score (0-100)\n * Used to determine optimal Claude Flow approach\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\nclass ComplexityAnalyzer {\n  constructor(projectPath = process.cwd()) {\n    this.projectPath = projectPath;\n    this.analysis = {\n      score: 0,\n      factors: {},\n      stage: 'unknown',\n      recommendations: [],\n      confidence: 0\n    };\n  }\n\n  /**\n   * Main analysis function\n   */\n  async analyze() {\n    try {\n      // Detect project stage first\n      this.analysis.stage = await this.detectProjectStage();\n      \n      // Analyze various complexity factors\n      const factors = {\n        size: await this.analyzeProjectSize(),\n        dependencies: await this.analyzeDependencies(),\n        architecture: await this.analyzeArchitecture(),\n        techStack: await this.analyzeTechStack(),\n        features: await this.analyzeFeatures(),\n        team: await this.analyzeTeamIndicators(),\n        deployment: await this.analyzeDeployment(),\n        testing: await this.analyzeTestingComplexity()\n      };\n\n      this.analysis.factors = factors;\n      \n      // Calculate overall complexity score\n      this.analysis.score = this.calculateComplexityScore(factors);\n      \n      // Calculate confidence in analysis\n      this.analysis.confidence = this.calculateConfidence(factors);\n      \n      // Generate recommendations\n      this.analysis.recommendations = this.generateRecommendations();\n      \n      return this.analysis;\n    } catch (error) {\n      console.error('Analysis error:', error);\n      return this.getDefaultAnalysis();\n    }\n  }\n\n  /**\n   * Detect project lifecycle stage\n   */\n  async detectProjectStage() {\n    const files = await this.getProjectFiles();\n    const hasCode = files.some(f => /\\.(js|ts|py|go|java|rs|cpp)$/.test(f));\n    const hasTests = files.some(f => /test|spec/.test(f));\n    const hasDeployment = files.some(f => /dockerfile|docker-compose|k8s|deploy/.test(f.toLowerCase()));\n    const hasCI = files.some(f => /\\.github\\/workflows|\\.gitlab-ci|jenkinsfile/.test(f.toLowerCase()));\n    \n    // Check for documentation only\n    if (!hasCode && files.length < 10) {\n      return 'idea';\n    }\n    \n    // Check for basic structure\n    if (hasCode && files.length < 50 && !hasTests) {\n      return 'early';\n    }\n    \n    // Check for active development\n    if (hasCode && (hasTests || files.length > 50)) {\n      return 'active';\n    }\n    \n    // Check for mature/production\n    if (hasDeployment && hasCI && hasTests) {\n      return 'mature';\n    }\n    \n    return 'active'; // Default to active if unclear\n  }\n\n  /**\n   * Analyze project size\n   */\n  async analyzeProjectSize() {\n    const files = await this.getProjectFiles();\n    const codeFiles = files.filter(f => /\\.(js|ts|py|go|java|rs|cpp|jsx|tsx|vue)$/.test(f));\n    \n    let score = 0;\n    if (codeFiles.length < 10) score = 10;\n    else if (codeFiles.length < 50) score = 30;\n    else if (codeFiles.length < 200) score = 50;\n    else if (codeFiles.length < 500) score = 70;\n    else score = 90;\n    \n    return {\n      fileCount: codeFiles.length,\n      score,\n      description: this.getSizeDescription(codeFiles.length)\n    };\n  }\n\n  /**\n   * Analyze dependencies\n   */\n  async analyzeDependencies() {\n    let dependencyCount = 0;\n    let score = 0;\n    \n    // Check package.json\n    const packageJsonPath = path.join(this.projectPath, 'package.json');\n    if (fs.existsSync(packageJsonPath)) {\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n      const deps = Object.keys(packageJson.dependencies || {});\n      const devDeps = Object.keys(packageJson.devDependencies || {});\n      dependencyCount = deps.length + devDeps.length;\n    }\n    \n    // Check requirements.txt\n    const requirementsPath = path.join(this.projectPath, 'requirements.txt');\n    if (fs.existsSync(requirementsPath)) {\n      const requirements = fs.readFileSync(requirementsPath, 'utf8');\n      dependencyCount += requirements.split('\\n').filter(l => l.trim() && !l.startsWith('#')).length;\n    }\n    \n    // Check go.mod\n    const goModPath = path.join(this.projectPath, 'go.mod');\n    if (fs.existsSync(goModPath)) {\n      const goMod = fs.readFileSync(goModPath, 'utf8');\n      const requires = goMod.match(/require\\s+\\(/);\n      if (requires) {\n        dependencyCount += goMod.match(/\\t[^\\s]+\\s+v/g)?.length || 0;\n      }\n    }\n    \n    // Calculate score based on dependency count\n    if (dependencyCount < 5) score = 10;\n    else if (dependencyCount < 20) score = 30;\n    else if (dependencyCount < 50) score = 50;\n    else if (dependencyCount < 100) score = 70;\n    else score = 90;\n    \n    return {\n      count: dependencyCount,\n      score,\n      description: `${dependencyCount} dependencies detected`\n    };\n  }\n\n  /**\n   * Analyze architecture patterns\n   */\n  async analyzeArchitecture() {\n    const indicators = {\n      microservices: 0,\n      monolith: 0,\n      frontend: 0,\n      backend: 0,\n      fullstack: 0,\n      api: 0,\n      database: 0\n    };\n    \n    const files = await this.getProjectFiles();\n    \n    // Check for microservices patterns\n    if (files.some(f => f.includes('services/') || f.includes('microservices/'))) {\n      indicators.microservices += 30;\n    }\n    if (files.some(f => /docker-compose/.test(f))) {\n      indicators.microservices += 20;\n    }\n    \n    // Check for frontend patterns\n    if (files.some(f => /\\.(jsx|tsx|vue)$/.test(f))) {\n      indicators.frontend += 30;\n    }\n    if (files.some(f => f.includes('components/'))) {\n      indicators.frontend += 20;\n    }\n    \n    // Check for backend patterns\n    if (files.some(f => f.includes('controllers/') || f.includes('routes/'))) {\n      indicators.backend += 30;\n    }\n    if (files.some(f => f.includes('models/') || f.includes('schemas/'))) {\n      indicators.backend += 20;\n      indicators.database += 20;\n    }\n    \n    // Check for API patterns\n    if (files.some(f => f.includes('api/') || /swagger|openapi/.test(f))) {\n      indicators.api += 30;\n    }\n    \n    // Determine architecture complexity\n    const maxIndicator = Math.max(...Object.values(indicators));\n    const architectureTypes = Object.entries(indicators).filter(([k, v]) => v > 20).length;\n    \n    let score = 20; // Base score\n    score += architectureTypes * 15; // Add complexity for each architecture type\n    if (indicators.microservices > 20) score += 20; // Extra complexity for microservices\n    if (indicators.fullstack > 20 || (indicators.frontend > 20 && indicators.backend > 20)) {\n      score += 15; // Extra complexity for fullstack\n    }\n    \n    return {\n      patterns: indicators,\n      score: Math.min(score, 100),\n      primaryArchitecture: Object.entries(indicators).sort((a, b) => b[1] - a[1])[0][0]\n    };\n  }\n\n  /**\n   * Analyze technology stack\n   */\n  async analyzeTechStack() {\n    const stack = {\n      languages: [],\n      frameworks: [],\n      databases: [],\n      tools: [],\n      containerized: false,\n      aiTools: []\n    };\n    \n    const files = await this.getProjectFiles();\n    \n    // Detect languages - expanded support\n    if (files.some(f => /\\.js$|\\.jsx$|\\.mjs$/.test(f))) stack.languages.push('JavaScript');\n    if (files.some(f => /\\.ts$|\\.tsx$/.test(f))) stack.languages.push('TypeScript');\n    if (files.some(f => /\\.py$/.test(f))) stack.languages.push('Python');\n    if (files.some(f => /\\.go$/.test(f))) stack.languages.push('Go');\n    if (files.some(f => /\\.java$/.test(f))) stack.languages.push('Java');\n    if (files.some(f => /\\.rs$/.test(f))) stack.languages.push('Rust');\n    if (files.some(f => /\\.rb$/.test(f))) stack.languages.push('Ruby');\n    if (files.some(f => /\\.cs$/.test(f))) stack.languages.push('C#');\n    if (files.some(f => /\\.swift$/.test(f))) stack.languages.push('Swift');\n    if (files.some(f => /\\.kt$|\\.kts$/.test(f))) stack.languages.push('Kotlin');\n    if (files.some(f => /\\.php$/.test(f))) stack.languages.push('PHP');\n    if (files.some(f => /\\.cpp$|\\.cc$|\\.cxx$/.test(f))) stack.languages.push('C++');\n    if (files.some(f => /\\.c$|\\.h$/.test(f))) stack.languages.push('C');\n    \n    // Check package.json for frameworks\n    const packageJsonPath = path.join(this.projectPath, 'package.json');\n    if (fs.existsSync(packageJsonPath)) {\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n      const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };\n      \n      if (allDeps.react) stack.frameworks.push('React');\n      if (allDeps.vue) stack.frameworks.push('Vue');\n      if (allDeps.angular) stack.frameworks.push('Angular');\n      if (allDeps.express) stack.frameworks.push('Express');\n      if (allDeps.next) stack.frameworks.push('Next.js');\n      if (allDeps.nestjs) stack.frameworks.push('NestJS');\n    }\n    \n    // Check for databases\n    if (files.some(f => /mongodb|mongoose/.test(f.toLowerCase()))) stack.databases.push('MongoDB');\n    if (files.some(f => /postgres|pg/.test(f.toLowerCase()))) stack.databases.push('PostgreSQL');\n    if (files.some(f => /mysql/.test(f.toLowerCase()))) stack.databases.push('MySQL');\n    if (files.some(f => /redis/.test(f.toLowerCase()))) stack.databases.push('Redis');\n    if (files.some(f => /sqlite|\\.db$/.test(f.toLowerCase()))) stack.databases.push('SQLite');\n    if (files.some(f => /elasticsearch/.test(f.toLowerCase()))) stack.databases.push('Elasticsearch');\n    \n    // Check for containerization\n    stack.containerized = files.some(f => /dockerfile|docker-compose|\\.dockerignore/.test(f.toLowerCase()));\n    \n    // Check for AI/ML tools and frameworks\n    if (files.some(f => /\\.claude|claude-code|claude\\.md/i.test(f))) stack.aiTools.push('Claude Code');\n    if (files.some(f => /agent-os|agentOS/i.test(f))) stack.aiTools.push('Agent-OS');\n    if (files.some(f => /claude-flow|hive-mind/i.test(f))) stack.aiTools.push('Claude Flow');\n    if (files.some(f => /tmux-orchestrator/i.test(f))) stack.aiTools.push('TMux Orchestrator');\n    if (files.some(f => /tensorflow|keras/i.test(f))) stack.aiTools.push('TensorFlow');\n    if (files.some(f => /pytorch|torch/i.test(f))) stack.aiTools.push('PyTorch');\n    if (files.some(f => /openai|gpt/i.test(f))) stack.aiTools.push('OpenAI');\n    \n    // Calculate complexity based on tech diversity\n    const diversity = stack.languages.length + stack.frameworks.length + stack.databases.length + stack.aiTools.length;\n    let score = diversity * 10;\n    \n    // Add complexity for certain technologies\n    if (stack.frameworks.includes('NestJS')) score += 15; // Enterprise framework\n    if (stack.databases.length > 1) score += 10; // Multiple databases\n    if (stack.languages.length > 2) score += 15; // Polyglot project\n    \n    return {\n      ...stack,\n      score: Math.min(score, 100),\n      diversity\n    };\n  }\n\n  /**\n   * Analyze features based on code patterns\n   */\n  async analyzeFeatures() {\n    const features = {\n      authentication: false,\n      realtime: false,\n      api: false,\n      database: false,\n      testing: false,\n      ci_cd: false,\n      docker: false,\n      kubernetes: false\n    };\n    \n    const files = await this.getProjectFiles();\n    const fileContents = [];\n    \n    // Read a sample of files to check for features (limit for performance)\n    const sampleFiles = files.slice(0, 20);\n    for (const file of sampleFiles) {\n      if (file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.py')) {\n        try {\n          const content = fs.readFileSync(path.join(this.projectPath, file), 'utf8');\n          fileContents.push(content.toLowerCase());\n        } catch (e) {\n          // Ignore read errors\n        }\n      }\n    }\n    \n    const allContent = fileContents.join('\\n');\n    \n    // Check for features\n    features.authentication = /jwt|auth|login|passport|oauth/.test(allContent);\n    features.realtime = /websocket|socket\\.io|ws:|realtime|pubsub/.test(allContent);\n    features.api = /api|endpoint|route|rest|graphql/.test(allContent);\n    features.database = /database|mongodb|postgres|mysql|redis/.test(allContent);\n    features.testing = files.some(f => /test|spec/.test(f));\n    features.ci_cd = files.some(f => /\\.github\\/workflows|\\.gitlab-ci|jenkinsfile/.test(f.toLowerCase()));\n    features.docker = files.some(f => /dockerfile|docker-compose/.test(f.toLowerCase()));\n    features.kubernetes = files.some(f => /k8s|kubernetes|\\.yaml$|\\.yml$/.test(f.toLowerCase()));\n    \n    // Calculate score based on features\n    const featureCount = Object.values(features).filter(Boolean).length;\n    let score = featureCount * 10;\n    \n    // Add extra complexity for certain features\n    if (features.realtime) score += 15;\n    if (features.kubernetes) score += 20;\n    if (features.authentication && features.api) score += 10;\n    \n    return {\n      detected: features,\n      count: featureCount,\n      score: Math.min(score, 100)\n    };\n  }\n\n  /**\n   * Analyze team indicators\n   */\n  async analyzeTeamIndicators() {\n    const indicators = {\n      multiContributor: false,\n      documentation: false,\n      codeReviews: false,\n      issueTracking: false\n    };\n    \n    const files = await this.getProjectFiles();\n    \n    // Check for team collaboration indicators\n    indicators.documentation = files.some(f => /readme|docs|documentation/i.test(f));\n    indicators.codeReviews = files.some(f => /\\.github\\/pull_request_template/.test(f));\n    indicators.issueTracking = files.some(f => /\\.github\\/issue_template/.test(f));\n    \n    // Check for CONTRIBUTING file\n    if (files.some(f => /contributing/i.test(f))) {\n      indicators.multiContributor = true;\n    }\n    \n    const teamScore = Object.values(indicators).filter(Boolean).length * 10;\n    \n    return {\n      indicators,\n      score: teamScore,\n      isTeamProject: teamScore > 20\n    };\n  }\n\n  /**\n   * Analyze deployment complexity\n   */\n  async analyzeDeployment() {\n    const deployment = {\n      docker: false,\n      kubernetes: false,\n      cicd: false,\n      cloudProvider: null,\n      monitoring: false\n    };\n    \n    const files = await this.getProjectFiles();\n    \n    deployment.docker = files.some(f => /dockerfile|docker-compose/.test(f.toLowerCase()));\n    deployment.kubernetes = files.some(f => /k8s|kubernetes|helm/.test(f.toLowerCase()));\n    deployment.cicd = files.some(f => /\\.github\\/workflows|\\.gitlab-ci|jenkinsfile|\\.circleci/.test(f.toLowerCase()));\n    \n    // Check for cloud providers\n    if (files.some(f => /aws|amplify/.test(f.toLowerCase()))) deployment.cloudProvider = 'AWS';\n    else if (files.some(f => /azure/.test(f.toLowerCase()))) deployment.cloudProvider = 'Azure';\n    else if (files.some(f => /gcp|google-cloud/.test(f.toLowerCase()))) deployment.cloudProvider = 'GCP';\n    else if (files.some(f => /vercel|netlify|heroku/.test(f.toLowerCase()))) deployment.cloudProvider = 'PaaS';\n    \n    deployment.monitoring = files.some(f => /monitoring|prometheus|grafana|datadog|newrelic/.test(f.toLowerCase()));\n    \n    // Calculate deployment complexity\n    let score = 0;\n    if (deployment.docker) score += 20;\n    if (deployment.kubernetes) score += 30;\n    if (deployment.cicd) score += 20;\n    if (deployment.cloudProvider) score += 15;\n    if (deployment.monitoring) score += 15;\n    \n    return {\n      ...deployment,\n      score: Math.min(score, 100)\n    };\n  }\n\n  /**\n   * Analyze testing complexity\n   */\n  async analyzeTestingComplexity() {\n    const files = await this.getProjectFiles();\n    const testFiles = files.filter(f => /test|spec/.test(f));\n    \n    const testing = {\n      hasTests: testFiles.length > 0,\n      testFileCount: testFiles.length,\n      testTypes: {\n        unit: false,\n        integration: false,\n        e2e: false\n      }\n    };\n    \n    // Detect test types\n    testing.testTypes.unit = testFiles.some(f => /unit|\\.test\\.|\\.spec\\./.test(f));\n    testing.testTypes.integration = testFiles.some(f => /integration|api\\.test|api\\.spec/.test(f));\n    testing.testTypes.e2e = testFiles.some(f => /e2e|cypress|playwright|selenium/.test(f));\n    \n    // Calculate testing score\n    let score = 0;\n    if (testing.hasTests) score += 20;\n    if (testing.testTypes.unit) score += 15;\n    if (testing.testTypes.integration) score += 20;\n    if (testing.testTypes.e2e) score += 25;\n    if (testFiles.length > 20) score += 20;\n    \n    return {\n      ...testing,\n      score: Math.min(score, 100)\n    };\n  }\n\n  /**\n   * Calculate overall complexity score\n   */\n  calculateComplexityScore(factors) {\n    const weights = {\n      size: 0.15,\n      dependencies: 0.15,\n      architecture: 0.20,\n      techStack: 0.15,\n      features: 0.15,\n      team: 0.05,\n      deployment: 0.10,\n      testing: 0.05\n    };\n    \n    let weightedScore = 0;\n    for (const [factor, weight] of Object.entries(weights)) {\n      weightedScore += (factors[factor]?.score || 0) * weight;\n    }\n    \n    // Adjust based on project stage\n    switch (this.analysis.stage) {\n      case 'idea':\n        weightedScore = Math.max(5, weightedScore * 0.5); // Ideas are simpler\n        break;\n      case 'early':\n        weightedScore = Math.max(15, weightedScore * 0.7); // Early projects are moderately complex\n        break;\n      case 'mature':\n        weightedScore = Math.min(100, weightedScore * 1.2); // Mature projects are more complex\n        break;\n    }\n    \n    return Math.round(weightedScore);\n  }\n\n  /**\n   * Calculate confidence in analysis\n   */\n  calculateConfidence(factors) {\n    let confidence = 0;\n    let factorCount = 0;\n    \n    // Check how many factors we could analyze\n    for (const factor of Object.values(factors)) {\n      if (factor && factor.score > 0) {\n        confidence += 12.5; // Each factor adds confidence\n        factorCount++;\n      }\n    }\n    \n    // Adjust confidence based on project stage clarity\n    if (this.analysis.stage !== 'unknown') {\n      confidence += 20;\n    }\n    \n    return Math.min(100, Math.round(confidence));\n  }\n\n  /**\n   * Generate recommendations based on analysis\n   */\n  generateRecommendations() {\n    const recommendations = [];\n    const score = this.analysis.score;\n    \n    if (score <= 30) {\n      recommendations.push({\n        approach: 'Simple Swarm',\n        reason: 'Low complexity project suitable for quick, focused AI coordination',\n        confidence: 0.9\n      });\n    } else if (score <= 70) {\n      recommendations.push({\n        approach: 'Hive-Mind',\n        reason: 'Medium complexity requiring multi-agent coordination',\n        confidence: 0.85\n      });\n    } else {\n      recommendations.push({\n        approach: 'Hive-Mind + SPARC',\n        reason: 'High complexity project benefiting from systematic methodology',\n        confidence: 0.95\n      });\n    }\n    \n    // Add stage-specific recommendations\n    switch (this.analysis.stage) {\n      case 'idea':\n        recommendations.push({\n          focus: 'Planning and Architecture',\n          suggestion: 'Focus on specification and design before implementation'\n        });\n        break;\n      case 'early':\n        recommendations.push({\n          focus: 'Foundation Building',\n          suggestion: 'Establish patterns and standards early'\n        });\n        break;\n      case 'active':\n        recommendations.push({\n          focus: 'Feature Development',\n          suggestion: 'Maintain consistency while adding features'\n        });\n        break;\n      case 'mature':\n        recommendations.push({\n          focus: 'Maintenance and Optimization',\n          suggestion: 'Focus on refactoring and performance'\n        });\n        break;\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Get project files recursively\n   */\n  async getProjectFiles() {\n    const files = [];\n    const ignoreDirs = ['node_modules', '.git', 'dist', 'build', '.next', '__pycache__', 'venv', 'env'];\n    \n    function walkDir(dir, prefix = '') {\n      try {\n        const items = fs.readdirSync(dir);\n        for (const item of items) {\n          const fullPath = path.join(dir, item);\n          const relativePath = prefix ? path.join(prefix, item) : item;\n          \n          // Skip ignored directories\n          if (ignoreDirs.includes(item)) continue;\n          \n          const stat = fs.statSync(fullPath);\n          if (stat.isDirectory()) {\n            walkDir(fullPath, relativePath);\n          } else {\n            files.push(relativePath);\n          }\n        }\n      } catch (e) {\n        // Ignore errors\n      }\n    }\n    \n    walkDir(this.projectPath);\n    return files;\n  }\n\n  /**\n   * Get size description\n   */\n  getSizeDescription(fileCount) {\n    if (fileCount < 10) return 'Tiny project';\n    if (fileCount < 50) return 'Small project';\n    if (fileCount < 200) return 'Medium project';\n    if (fileCount < 500) return 'Large project';\n    return 'Very large project';\n  }\n\n  /**\n   * Default analysis for errors\n   */\n  getDefaultAnalysis() {\n    return {\n      score: 50,\n      stage: 'unknown',\n      factors: {},\n      recommendations: [{\n        approach: 'Hive-Mind',\n        reason: 'Default recommendation due to analysis error',\n        confidence: 0.5\n      }],\n      confidence: 0,\n      error: true\n    };\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  const analyzer = new ComplexityAnalyzer(process.argv[2] || process.cwd());\n  analyzer.analyze().then(result => {\n    console.log(JSON.stringify(result, null, 2));\n  });\n}\n\nmodule.exports = ComplexityAnalyzer;",
          "size": 21469,
          "lastModified": "2025-08-12T23:37:55.120Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "walkDir",
                "position": 19872
              }
            ],
            "classes": [
              {
                "name": "ComplexityAnalyzer",
                "position": 244
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/deep-codebase-analyzer.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/deep-codebase-analyzer.js",
          "fileName": "deep-codebase-analyzer.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Deep Codebase Analyzer\n * Phase 3 Implementation - MASTER-WORKFLOW v3.0\n * \n * Advanced codebase analysis system that leverages 10 specialized sub-agents\n * to perform comprehensive pattern extraction, architectural analysis, and\n * deep code understanding.\n * \n * Features:\n * - Pattern extraction (design patterns, architectural patterns, anti-patterns)\n * - Architecture detection (monolithic, microservices, serverless, modular, hybrid)\n * - Business logic extraction (domain models, workflows, validation rules)\n * - API analysis (REST, GraphQL, gRPC, WebSocket endpoints)\n * - Database analysis (schemas, relationships, query patterns)\n * - Test analysis (coverage, patterns, frameworks)\n * - Security scanning (vulnerabilities, best practices)\n * - Performance bottleneck identification\n */\n\nconst EventEmitter = require('events');\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Import existing components from Phase 1-2\nconst SharedMemoryStore = require('./shared-memory');\nconst QueenController = require('./queen-controller');\nconst AgentCommunication = require('./agent-communication');\nconst SubAgentManager = require('./sub-agent-manager');\n\n// Import analysis engines (to be created)\nconst PatternDetectionEngine = require('./analysis-engines/pattern-detection-engine');\nconst ArchitectureDetectionEngine = require('./analysis-engines/architecture-detection-engine');\nconst BusinessLogicExtractor = require('./analysis-engines/business-logic-extractor');\nconst APIAnalysisEngine = require('./analysis-engines/api-analysis-engine');\nconst DatabaseAnalysisEngine = require('./analysis-engines/database-analysis-engine');\nconst TestAnalysisEngine = require('./analysis-engines/test-analysis-engine');\nconst SecurityAnalysisEngine = require('./analysis-engines/security-analysis-engine');\nconst PerformanceAnalysisEngine = require('./analysis-engines/performance-analysis-engine');\n\nclass DeepCodebaseAnalyzer extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Integration with existing Phase 1-2 components\n    this.sharedMemory = options.sharedMemory || new SharedMemoryStore();\n    this.queenController = options.queenController || new QueenController();\n    this.agentCommunication = options.agentCommunication || new AgentCommunication();\n    this.subAgentManager = options.subAgentManager || new SubAgentManager();\n    \n    // Initialize analysis engines\n    this.patternEngine = new PatternDetectionEngine(this.sharedMemory);\n    this.architectureEngine = new ArchitectureDetectionEngine(this.sharedMemory);\n    this.businessLogicEngine = new BusinessLogicExtractor(this.sharedMemory);\n    this.apiEngine = new APIAnalysisEngine(this.sharedMemory);\n    this.databaseEngine = new DatabaseAnalysisEngine(this.sharedMemory);\n    this.testEngine = new TestAnalysisEngine(this.sharedMemory);\n    this.securityEngine = new SecurityAnalysisEngine(this.sharedMemory);\n    this.performanceEngine = new PerformanceAnalysisEngine(this.sharedMemory);\n    \n    // Analysis configuration\n    this.config = {\n      maxConcurrentAgents: 10,\n      analysisTimeout: 300000, // 5 minutes\n      chunkSize: 100, // Files per chunk\n      cacheEnabled: true,\n      cacheTTL: 3600000, // 1 hour\n      ...options.config\n    };\n    \n    // Analysis state\n    this.activeAnalyses = new Map();\n    this.analysisResults = new Map();\n    this.agentAssignments = new Map();\n    \n    this.setupEventHandlers();\n  }\n  \n  /**\n   * Setup event handlers for agent communication\n   */\n  setupEventHandlers() {\n    // Listen for agent results\n    this.agentCommunication.on('analysis-result', this.handleAnalysisResult.bind(this));\n    this.agentCommunication.on('analysis-error', this.handleAnalysisError.bind(this));\n    this.agentCommunication.on('analysis-progress', this.handleAnalysisProgress.bind(this));\n    \n    // Listen for Queen Controller events\n    this.queenController.on('agent-ready', this.handleAgentReady.bind(this));\n    this.queenController.on('task-complete', this.handleTaskComplete.bind(this));\n  }\n  \n  /**\n   * Main entry point for comprehensive codebase analysis\n   */\n  async analyzeComplete(projectPath = process.cwd(), options = {}) {\n    const analysisId = `analysis-${Date.now()}`;\n    \n    try {\n      // Initialize analysis session\n      await this.initializeAnalysis(analysisId, projectPath, options);\n      \n      // Store analysis request in shared memory\n      await this.storeAnalysisRequest(analysisId, projectPath, options);\n      \n      // Execute parallel analysis using all 10 agents\n      const results = await Promise.all([\n        this.extractPatterns(projectPath, analysisId),\n        this.detectArchitecture(projectPath, analysisId),\n        this.extractBusinessLogic(projectPath, analysisId),\n        this.detectAPIs(projectPath, analysisId),\n        this.analyzeDatabases(projectPath, analysisId),\n        this.analyzeTests(projectPath, analysisId),\n        this.scanSecurity(projectPath, analysisId),\n        this.identifyBottlenecks(projectPath, analysisId)\n      ]);\n      \n      // Aggregate and consolidate results\n      const consolidatedResults = await this.consolidateResults(results, analysisId);\n      \n      // Store final results in shared memory\n      await this.storeFinalResults(analysisId, consolidatedResults);\n      \n      // Emit completion event\n      this.emit('analysis-complete', {\n        analysisId,\n        results: consolidatedResults,\n        duration: Date.now() - parseInt(analysisId.split('-')[1])\n      });\n      \n      return consolidatedResults;\n      \n    } catch (error) {\n      this.emit('analysis-error', { analysisId, error });\n      throw error;\n    } finally {\n      // Cleanup\n      this.activeAnalyses.delete(analysisId);\n    }\n  }\n  \n  /**\n   * Initialize analysis session\n   */\n  async initializeAnalysis(analysisId, projectPath, options) {\n    this.activeAnalyses.set(analysisId, {\n      startTime: Date.now(),\n      projectPath,\n      options,\n      status: 'initializing',\n      progress: 0\n    });\n    \n    // Check cache if enabled\n    if (this.config.cacheEnabled) {\n      const cachedResults = await this.checkCache(projectPath);\n      if (cachedResults && !options.forceRefresh) {\n        return cachedResults;\n      }\n    }\n    \n    // Initialize shared memory namespace for this analysis\n    await this.sharedMemory.set(\n      `analysis:${analysisId}:config`,\n      {\n        projectPath,\n        options,\n        startTime: Date.now()\n      },\n      {\n        namespace: this.sharedMemory.namespaces.CROSS_AGENT,\n        dataType: this.sharedMemory.dataTypes.SHARED\n      }\n    );\n  }\n  \n  /**\n   * Store analysis request in shared memory for agents\n   */\n  async storeAnalysisRequest(analysisId, projectPath, options) {\n    const request = {\n      analysisId,\n      projectPath,\n      timestamp: Date.now(),\n      requestedAnalyses: [\n        'patterns', 'architecture', 'businessLogic',\n        'apis', 'databases', 'tests', 'security', 'performance'\n      ],\n      options\n    };\n    \n    await this.sharedMemory.set(\n      `analysis:${analysisId}:request`,\n      request,\n      {\n        namespace: this.sharedMemory.namespaces.CROSS_AGENT,\n        dataType: this.sharedMemory.dataTypes.SHARED,\n        ttl: this.config.analysisTimeout\n      }\n    );\n  }\n  \n  /**\n   * Extract patterns using code-analyzer-agent\n   */\n  async extractPatterns(projectPath, analysisId) {\n    const task = {\n      id: `${analysisId}-patterns`,\n      type: 'pattern-extraction',\n      agent: 'code-analyzer-agent',\n      priority: 'high',\n      payload: {\n        projectPath,\n        patterns: [\n          'design-patterns',\n          'architectural-patterns',\n          'anti-patterns',\n          'coding-patterns'\n        ],\n        algorithms: ['ast-traversal', 'regex-matching', 'ml-classification']\n      }\n    };\n    \n    // Distribute task to code-analyzer agent\n    const agentId = await this.queenController.distributeTask(task);\n    this.agentAssignments.set(task.id, agentId);\n    \n    // Wait for results\n    return await this.waitForAgentResult(task.id);\n  }\n  \n  /**\n   * Detect architecture using multiple agents\n   */\n  async detectArchitecture(projectPath, analysisId) {\n    const architecturalIndicators = {\n      monolithic: await this.scanForMonolithicPatterns(projectPath),\n      microservices: await this.scanForMicroservicePatterns(projectPath),\n      serverless: await this.scanForServerlessPatterns(projectPath),\n      modular: await this.scanForModularPatterns(projectPath),\n      hybrid: await this.scanForHybridPatterns(projectPath)\n    };\n    \n    // Store findings in shared memory\n    await this.sharedMemory.set(\n      `analysis:${analysisId}:architecture`,\n      architecturalIndicators,\n      {\n        namespace: this.sharedMemory.namespaces.TASK_RESULTS,\n        dataType: this.sharedMemory.dataTypes.PERSISTENT\n      }\n    );\n    \n    return this.calculateArchitectureScore(architecturalIndicators);\n  }\n  \n  /**\n   * Extract business logic using specialized agents\n   */\n  async extractBusinessLogic(projectPath, analysisId) {\n    const extractionTasks = [\n      this.extractDomainModels(projectPath, analysisId),\n      this.extractBusinessRules(projectPath, analysisId),\n      this.extractWorkflows(projectPath, analysisId),\n      this.extractValidationLogic(projectPath, analysisId),\n      this.extractDataFlow(projectPath, analysisId)\n    ];\n    \n    const results = await Promise.all(extractionTasks);\n    \n    return {\n      domainModels: results[0],\n      businessRules: results[1],\n      workflows: results[2],\n      validations: results[3],\n      dataFlow: results[4],\n      confidence: this.calculateConfidenceScore(results)\n    };\n  }\n  \n  /**\n   * Detect APIs using api-builder-agent\n   */\n  async detectAPIs(projectPath, analysisId) {\n    const task = {\n      id: `${analysisId}-apis`,\n      type: 'api-discovery',\n      agent: 'api-builder-agent',\n      priority: 'normal',\n      payload: {\n        projectPath,\n        apiTypes: ['REST', 'GraphQL', 'gRPC', 'WebSocket'],\n        extractEndpoints: true,\n        extractSchemas: true,\n        extractAuth: true\n      }\n    };\n    \n    const agentId = await this.queenController.distributeTask(task);\n    this.agentAssignments.set(task.id, agentId);\n    \n    return await this.waitForAgentResult(task.id);\n  }\n  \n  /**\n   * Analyze databases using database-architect-agent\n   */\n  async analyzeDatabases(projectPath, analysisId) {\n    const dbPhases = [\n      { phase: 'schema-discovery', agent: 'database-architect-agent' },\n      { phase: 'relationship-mapping', agent: 'database-architect-agent' },\n      { phase: 'query-analysis', agent: 'code-analyzer-agent' },\n      { phase: 'performance-review', agent: 'performance-optimizer-agent' }\n    ];\n    \n    const results = {};\n    for (const phase of dbPhases) {\n      const task = {\n        id: `${analysisId}-db-${phase.phase}`,\n        type: 'database-analysis',\n        agent: phase.agent,\n        priority: 'normal',\n        payload: {\n          projectPath,\n          phase: phase.phase\n        }\n      };\n      \n      const agentId = await this.queenController.distributeTask(task);\n      results[phase.phase] = await this.waitForAgentResult(task.id);\n    }\n    \n    return this.consolidateDatabaseAnalysis(results);\n  }\n  \n  /**\n   * Analyze tests using test-runner-agent\n   */\n  async analyzeTests(projectPath, analysisId) {\n    const task = {\n      id: `${analysisId}-tests`,\n      type: 'test-analysis',\n      agent: 'test-runner-agent',\n      priority: 'normal',\n      payload: {\n        projectPath,\n        analysisTypes: ['coverage', 'patterns', 'frameworks', 'quality'],\n        includeRecommendations: true,\n        generateReport: true\n      }\n    };\n    \n    const agentId = await this.queenController.distributeTask(task);\n    this.agentAssignments.set(task.id, agentId);\n    \n    const results = await this.waitForAgentResult(task.id);\n    \n    return {\n      coverage: results.coverage || 0,\n      testPatterns: results.patterns || [],\n      frameworks: results.frameworks || [],\n      recommendations: results.recommendations || [],\n      qualityScore: results.qualityScore || 0\n    };\n  }\n  \n  /**\n   * Scan security using security-scanner-agent\n   */\n  async scanSecurity(projectPath, analysisId) {\n    const task = {\n      id: `${analysisId}-security`,\n      type: 'security-audit',\n      agent: 'security-scanner-agent',\n      priority: 'high',\n      payload: {\n        projectPath,\n        scopes: [\n          'vulnerability-scan',\n          'dependency-audit',\n          'code-analysis',\n          'configuration-review',\n          'authentication-audit',\n          'authorization-review'\n        ]\n      }\n    };\n    \n    const agentId = await this.queenController.distributeTask(task);\n    this.agentAssignments.set(task.id, agentId);\n    \n    return await this.waitForAgentResult(task.id);\n  }\n  \n  /**\n   * Identify performance bottlenecks using performance-optimizer-agent\n   */\n  async identifyBottlenecks(projectPath, analysisId) {\n    const performanceTasks = [\n      'algorithm-complexity-analysis',\n      'memory-usage-analysis',\n      'io-bottleneck-detection',\n      'database-query-optimization',\n      'resource-utilization-review'\n    ];\n    \n    const results = {};\n    for (const taskType of performanceTasks) {\n      const task = {\n        id: `${analysisId}-perf-${taskType}`,\n        type: 'performance-analysis',\n        agent: 'performance-optimizer-agent',\n        priority: 'normal',\n        payload: {\n          projectPath,\n          analysisType: taskType\n        }\n      };\n      \n      const agentId = await this.queenController.distributeTask(task);\n      results[taskType] = await this.waitForAgentResult(task.id);\n    }\n    \n    return this.consolidatePerformanceAnalysis(results);\n  }\n  \n  /**\n   * Wait for agent to complete task and return results\n   */\n  async waitForAgentResult(taskId, timeout = this.config.analysisTimeout) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Task ${taskId} timed out after ${timeout}ms`));\n      }, timeout);\n      \n      const checkResult = async () => {\n        const result = await this.sharedMemory.get(\n          `task:${taskId}:result`,\n          { namespace: this.sharedMemory.namespaces.TASK_RESULTS }\n        );\n        \n        if (result) {\n          clearTimeout(timeoutId);\n          resolve(result);\n        } else {\n          setTimeout(checkResult, 100);\n        }\n      };\n      \n      checkResult();\n    });\n  }\n  \n  /**\n   * Consolidate results from all analyses\n   */\n  async consolidateResults(results, analysisId) {\n    const [\n      patterns,\n      architecture,\n      businessLogic,\n      apis,\n      databases,\n      tests,\n      security,\n      performance\n    ] = results;\n    \n    const consolidated = {\n      analysisId,\n      timestamp: Date.now(),\n      patterns,\n      architecture,\n      businessLogic,\n      apis,\n      databases,\n      testing: tests,\n      security,\n      performance,\n      summary: await this.generateSummary(results),\n      recommendations: await this.generateRecommendations(results),\n      confidence: this.calculateOverallConfidence(results)\n    };\n    \n    return consolidated;\n  }\n  \n  /**\n   * Store final results in shared memory\n   */\n  async storeFinalResults(analysisId, results) {\n    await this.sharedMemory.set(\n      `analysis:${analysisId}:final`,\n      results,\n      {\n        namespace: this.sharedMemory.namespaces.TASK_RESULTS,\n        dataType: this.sharedMemory.dataTypes.PERSISTENT,\n        ttl: this.config.cacheTTL\n      }\n    );\n    \n    // Update cache if enabled\n    if (this.config.cacheEnabled) {\n      await this.updateCache(results.projectPath, results);\n    }\n  }\n  \n  // Helper methods for pattern scanning\n  async scanForMonolithicPatterns(projectPath) {\n    // Implementation for monolithic pattern detection\n    return {\n      singleDeploymentUnit: true,\n      sharedDatabase: true,\n      tightCoupling: false,\n      score: 0.7\n    };\n  }\n  \n  async scanForMicroservicePatterns(projectPath) {\n    // Implementation for microservice pattern detection\n    return {\n      multipleServices: false,\n      apiGateway: false,\n      serviceDiscovery: false,\n      score: 0.2\n    };\n  }\n  \n  async scanForServerlessPatterns(projectPath) {\n    // Implementation for serverless pattern detection\n    return {\n      functionAsService: false,\n      eventDriven: false,\n      managedServices: false,\n      score: 0.1\n    };\n  }\n  \n  async scanForModularPatterns(projectPath) {\n    // Implementation for modular pattern detection\n    return {\n      clearModules: true,\n      looseCoupling: true,\n      wellDefinedInterfaces: true,\n      score: 0.8\n    };\n  }\n  \n  async scanForHybridPatterns(projectPath) {\n    // Implementation for hybrid pattern detection\n    return {\n      mixedArchitectures: false,\n      transitionState: false,\n      score: 0.3\n    };\n  }\n  \n  // Helper methods for business logic extraction\n  async extractDomainModels(projectPath, analysisId) {\n    // Implementation for domain model extraction\n    return [];\n  }\n  \n  async extractBusinessRules(projectPath, analysisId) {\n    // Implementation for business rule extraction\n    return [];\n  }\n  \n  async extractWorkflows(projectPath, analysisId) {\n    // Implementation for workflow extraction\n    return [];\n  }\n  \n  async extractValidationLogic(projectPath, analysisId) {\n    // Implementation for validation logic extraction\n    return [];\n  }\n  \n  async extractDataFlow(projectPath, analysisId) {\n    // Implementation for data flow extraction\n    return {};\n  }\n  \n  // Calculation methods\n  calculateArchitectureScore(indicators) {\n    const scores = Object.values(indicators).map(i => i.score || 0);\n    const maxScore = Math.max(...scores);\n    const architecture = Object.keys(indicators).find(\n      key => indicators[key].score === maxScore\n    );\n    \n    return {\n      type: architecture,\n      confidence: maxScore,\n      indicators\n    };\n  }\n  \n  calculateConfidenceScore(results) {\n    const validResults = results.filter(r => r && Object.keys(r).length > 0);\n    return validResults.length / results.length;\n  }\n  \n  calculateOverallConfidence(results) {\n    const confidenceScores = results\n      .filter(r => r && r.confidence)\n      .map(r => r.confidence);\n    \n    if (confidenceScores.length === 0) return 0;\n    \n    return confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length;\n  }\n  \n  consolidateDatabaseAnalysis(results) {\n    return {\n      schemas: results['schema-discovery'] || {},\n      relationships: results['relationship-mapping'] || {},\n      queries: results['query-analysis'] || [],\n      performance: results['performance-review'] || {}\n    };\n  }\n  \n  consolidatePerformanceAnalysis(results) {\n    return {\n      complexity: results['algorithm-complexity-analysis'] || {},\n      memory: results['memory-usage-analysis'] || {},\n      io: results['io-bottleneck-detection'] || {},\n      database: results['database-query-optimization'] || {},\n      resources: results['resource-utilization-review'] || {}\n    };\n  }\n  \n  async generateSummary(results) {\n    // Generate executive summary of analysis\n    return {\n      overview: 'Comprehensive codebase analysis completed',\n      keyFindings: [],\n      strengths: [],\n      weaknesses: [],\n      opportunities: []\n    };\n  }\n  \n  async generateRecommendations(results) {\n    // Generate actionable recommendations\n    return {\n      immediate: [],\n      shortTerm: [],\n      longTerm: []\n    };\n  }\n  \n  // Cache management\n  async checkCache(projectPath) {\n    const cacheKey = `cache:analysis:${projectPath}`;\n    return await this.sharedMemory.get(cacheKey);\n  }\n  \n  async updateCache(projectPath, results) {\n    const cacheKey = `cache:analysis:${projectPath}`;\n    await this.sharedMemory.set(\n      cacheKey,\n      results,\n      {\n        ttl: this.config.cacheTTL\n      }\n    );\n  }\n  \n  // Event handlers\n  handleAnalysisResult(data) {\n    const { taskId, result } = data;\n    this.analysisResults.set(taskId, result);\n    this.emit('task-result', { taskId, result });\n  }\n  \n  handleAnalysisError(data) {\n    const { taskId, error } = data;\n    this.emit('task-error', { taskId, error });\n  }\n  \n  handleAnalysisProgress(data) {\n    const { analysisId, progress } = data;\n    const analysis = this.activeAnalyses.get(analysisId);\n    if (analysis) {\n      analysis.progress = progress;\n      this.emit('progress', { analysisId, progress });\n    }\n  }\n  \n  handleAgentReady(data) {\n    const { agentId, type } = data;\n    this.emit('agent-ready', { agentId, type });\n  }\n  \n  handleTaskComplete(data) {\n    const { taskId, agentId, result } = data;\n    this.emit('task-complete', { taskId, agentId, result });\n  }\n}\n\n// Export for use in other modules\nmodule.exports = DeepCodebaseAnalyzer;\n\n// CLI interface if run directly\nif (require.main === module) {\n  const analyzer = new DeepCodebaseAnalyzer();\n  \n  analyzer.analyzeComplete(process.cwd())\n    .then(results => {\n      console.log('Analysis Complete:', JSON.stringify(results, null, 2));\n      process.exit(0);\n    })\n    .catch(error => {\n      console.error('Analysis Failed:', error);\n      process.exit(1);\n    });\n}",
          "size": 21313,
          "lastModified": "2025-08-13T15:59:30.973Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "DeepCodebaseAnalyzer",
                "position": 1943
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/document-customizer.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/document-customizer.js",
          "fileName": "document-customizer.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\r\n\r\n/**\r\n * Document Customizer\r\n * Generates deeply customized documentation based on project analysis\r\n * Creates tech-stack specific configurations and workflows\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst versionPolicy = require('../lib/version-policy');\r\n\r\nclass DocumentCustomizer {\r\n  constructor(analysis, approach) {\r\n    this.analysis = analysis;\r\n    this.approach = approach;\r\n    this.projectPath = analysis.projectPath || process.cwd();\r\n    this.templates = this.loadTemplates();\r\n  }\r\n\r\n  /**\r\n   * Generate all customized documents\r\n   */\r\n  async generateDocuments() {\r\n    const documents = {\r\n      claude: await this.generateClaudeConfig(),\r\n      agentOS: await this.generateAgentOSInstructions(),\r\n      workflows: await this.generateWorkflows(),\r\n      contributing: await this.generateContributing(),\r\n      deployment: await this.generateDeployment(),\r\n      architecture: await this.generateArchitecture(),\r\n      sparc: this.approach.selected === 'hiveMindSparc' ? await this.generateSPARCPhases() : null,\r\n      agents: await this.generateAgentConfigs(),\r\n      slashCommands: await this.generateSlashCommands()\r\n    };\r\n\r\n    return documents;\r\n  }\r\n\r\n  /**\r\n   * Generate CLAUDE.md with deep customization\r\n   */\r\n  async generateClaudeConfig() {\r\n    const projectInstructionsPath = path.join(this.projectPath, '.ai-dev', 'project-instructions.md');\r\n    let projectInstructions = '';\r\n    try {\r\n      if (fs.existsSync(projectInstructionsPath)) {\r\n        projectInstructions = fs.readFileSync(projectInstructionsPath, 'utf8');\r\n      }\r\n    } catch (e) { /* ignore */ }\r\n\r\n    // Check if running in container\r\n    const isContainer = this.detectContainerEnvironment();\r\n\r\n    // Load MCP registry if present\r\n    const mcpRegistryPath = path.join(this.projectPath, '.ai-workflow', 'configs', 'mcp-registry.json');\r\n    let mcpRegistry = null;\r\n    try {\r\n      if (fs.existsSync(mcpRegistryPath)) {\r\n        mcpRegistry = JSON.parse(fs.readFileSync(mcpRegistryPath, 'utf8'));\r\n      }\r\n    } catch (e) { /* ignore */ }\r\n\r\n    // projectInstructions already loaded above\r\n\r\n    const techStack = this.analysis.factors?.techStack || {};\r\n    const features = this.analysis.factors?.features?.detected || {};\r\n    const architecture = this.analysis.factors?.architecture || {};\r\n    \r\n    const versionName = versionPolicy.getSelectedVersionName({ analysis: this.analysis });\r\n    const isExperimental = versionPolicy.isExperimentalName(versionName);\r\n    const hasAITools = techStack.aiTools && techStack.aiTools.length > 0;\r\n\r\n    let content = `# Claude Configuration - ${this.analysis.stage} Stage Project\r\n\r\n## Project Analysis\r\n- **Complexity Score**: ${this.analysis.score}/100\r\n- **Stage**: ${this.analysis.stage}\r\n - **Selected Approach**: ${this.approach.name}\r\n - **Claude Flow Version**: ${versionName} ${isExperimental ? '(experimental)' : ''}\r\n - **Command**: \\`${this.generateOptimalCommand()}\\`\r\n\r\n## Technology Stack\r\n`;\r\n\r\n    // Add detected languages\r\n    if (techStack.languages?.length > 0) {\r\n      content += `### Languages\\n`;\r\n      techStack.languages.forEach(lang => {\r\n        content += `- ${lang}\\n`;\r\n        content += this.getLanguageGuidelines(lang);\r\n      });\r\n    }\r\n\r\n    // Add detected frameworks\r\n    if (techStack.frameworks?.length > 0) {\r\n      content += `\\n### Frameworks\\n`;\r\n      techStack.frameworks.forEach(framework => {\r\n        content += `- ${framework}\\n`;\r\n        content += this.getFrameworkGuidelines(framework);\r\n      });\r\n    }\r\n\r\n    // Add detected databases\r\n    if (techStack.databases?.length > 0) {\r\n      content += `\\n### Databases\\n`;\r\n      techStack.databases.forEach(db => {\r\n        content += `- ${db}\\n`;\r\n        content += this.getDatabaseGuidelines(db);\r\n      });\r\n    }\r\n\r\n    // Add feature-specific guidelines\r\n    content += `\\n## Feature Guidelines\\n`;\r\n    \r\n    if (features.authentication) {\r\n      content += `\\n### Authentication System\r\n- Use JWT tokens for stateless authentication\r\n- Implement refresh token rotation\r\n- Store passwords using bcrypt with salt rounds >= 10\r\n- Implement rate limiting on auth endpoints\r\n`;\r\n    }\r\n\r\n    if (features.realtime) {\r\n      content += `\\n### Real-time Features\r\n- Use WebSocket connections for bidirectional communication\r\n- Implement connection pooling for scalability\r\n- Add heartbeat mechanism for connection health\r\n- Use rooms/channels for targeted messaging\r\n`;\r\n    }\r\n\r\n    if (features.api) {\r\n      content += `\\n### API Development\r\n- Follow RESTful principles\r\n- Implement proper HTTP status codes\r\n- Add OpenAPI/Swagger documentation\r\n- Use versioning (e.g., /api/v1/)\r\n- Implement pagination for list endpoints\r\n`;\r\n    }\r\n\r\n    // Add architecture-specific guidelines\r\n    if (architecture.primaryArchitecture) {\r\n      content += `\\n## Architecture: ${architecture.primaryArchitecture}\\n`;\r\n      content += this.getArchitectureGuidelines(architecture.primaryArchitecture);\r\n    }\r\n\r\n    // Add stage-specific instructions\r\n    content += `\\n## Stage-Specific Instructions (${this.analysis.stage})\\n`;\r\n    content += this.getStageInstructions(this.analysis.stage);\r\n\r\n    // Project-specific instructions (if provided)\r\n    if (projectInstructions && projectInstructions.trim().length > 0) {\r\n      content += `\\n## Project-Specific Instructions\\n`;\r\n      content += `${projectInstructions}\\n`;\r\n    }\r\n\r\n    // MCP Registry summary\r\n    if (mcpRegistry) {\r\n      content += `\\n## Discovered MCP Servers & Tools\\n`;\r\n      const servers = mcpRegistry.servers || {};\r\n      const tools = mcpRegistry.tools || [];\r\n      const serverNames = Object.keys(servers);\r\n      if (serverNames.length > 0) {\r\n        content += `\\n### Servers\\n`;\r\n        for (const name of serverNames) {\r\n          const s = servers[name];\r\n          content += `- ${name}: ${JSON.stringify(s)}\\n`;\r\n        }\r\n      }\r\n      if (tools.length > 0) {\r\n        content += `\\n### Tools\\n`;\r\n        for (const t of tools) {\r\n          content += `- ${t.name} (${t.type}${t.server ? `:${t.server}` : ''})\\n`;\r\n        }\r\n      }\r\n      // Indicate default server if present\r\n      const defaultServer = Object.entries(servers).find(([_, v]) => v && v.default);\r\n      if (defaultServer) {\r\n        content += `\\nDefault MCP Server: ${defaultServer[0]}\\n`;\r\n      }\r\n    }\r\n\r\n    // Add approach-specific workflow\r\n    content += `\\n## ${this.approach.name} Workflow\\n`;\r\n    content += this.getApproachWorkflow(this.approach.selected);\r\n\r\n    // Version Policy Summary (Phase 3)\r\n    const policy = versionPolicy.getPolicySummary();\r\n    content += `\\n## Version Policy\\n`;\r\n    content += `- Canonical versions: ${policy.canonicalNames.join(', ')}\\n`;\r\n    content += `- Experimental: ${policy.experimental.join(', ')}\\n`;\r\n    content += `- Override via env: ${policy.examples.env}\\n`;\r\n\r\n    return {\r\n      path: '.claude/CLAUDE.md',\r\n      content\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate Agent OS instructions\r\n   */\r\n  async generateAgentOSInstructions() {\r\n    const projectInstructionsPath = path.join(this.projectPath, '.ai-dev', 'project-instructions.md');\r\n    let projectInstructions = '';\r\n    try {\r\n      if (fs.existsSync(projectInstructionsPath)) {\r\n        projectInstructions = fs.readFileSync(projectInstructionsPath, 'utf8');\r\n      }\r\n    } catch (e) { /* ignore */ }\r\n\r\n    const stage = this.analysis.stage;\r\n    const techStack = this.analysis.factors?.techStack || {};\r\n    \r\n    let content = `# Agent OS Instructions\r\n\r\n## Project Context\r\n- **Stage**: ${stage}\r\n- **Complexity**: ${this.analysis.score}/100\r\n- **Primary Language**: ${techStack.languages?.[0] || 'Not detected'}\r\n- **Primary Framework**: ${techStack.frameworks?.[0] || 'Not detected'}\r\n\r\n## Development Standards\r\n`;\r\n\r\n    // Add language-specific standards\r\n    if (techStack.languages?.includes('JavaScript') || techStack.languages?.includes('TypeScript')) {\r\n      content += `\r\n### JavaScript/TypeScript Standards\r\n- Use ES6+ features (arrow functions, destructuring, async/await)\r\n- Prefer functional programming patterns\r\n- Use strict mode\r\n- Implement proper error handling with try/catch\r\n- Use TypeScript for type safety when available\r\n`;\r\n    }\r\n\r\n    if (techStack.languages?.includes('Python')) {\r\n      content += `\r\n### Python Standards\r\n- Follow PEP 8 style guide\r\n- Use type hints for function signatures\r\n- Implement proper exception handling\r\n- Use virtual environments for dependencies\r\n- Write docstrings for all functions and classes\r\n`;\r\n    }\r\n\r\n    if (techStack.languages?.includes('Go')) {\r\n      content += `\r\n### Go Standards\r\n- Follow effective Go guidelines\r\n- Use gofmt for formatting\r\n- Implement proper error handling\r\n- Use goroutines for concurrency\r\n- Write tests alongside code\r\n`;\r\n    }\r\n\r\n    // Add framework-specific instructions\r\n    if (techStack.frameworks?.includes('React')) {\r\n      content += `\r\n### React Development\r\n- Use functional components with hooks\r\n- Implement proper state management (Context API or Redux)\r\n- Optimize with React.memo and useMemo\r\n- Follow component composition patterns\r\n- Write tests with React Testing Library\r\n`;\r\n    }\r\n\r\n    if (techStack.frameworks?.includes('Express')) {\r\n      content += `\r\n### Express Development\r\n- Use middleware for cross-cutting concerns\r\n- Implement proper error handling middleware\r\n- Use route separation for organization\r\n- Implement input validation\r\n- Add security headers (helmet)\r\n`;\r\n    }\r\n\r\n    // Inject project-specific instructions into Agent-OS if provided\r\n    if (projectInstructions && projectInstructions.trim().length > 0) {\r\n      content += `\\n## Project-Specific Instructions\\n`;\r\n      content += `${projectInstructions}\\n`;\r\n    }\r\n\r\n    // Add stage-specific planning\r\n    content += `\r\n## Stage-Specific Instructions (${stage})\r\n`;\r\n    \r\n    switch (stage) {\r\n      case 'idea':\r\n        content += `\r\n- Focus on requirements gathering\r\n- Create detailed specifications\r\n- Design system architecture\r\n- Plan implementation phases\r\n- Define success criteria\r\n`;\r\n        break;\r\n      case 'early':\r\n        content += `\r\n- Establish coding standards\r\n- Set up development environment\r\n- Create foundation components\r\n- Implement core features\r\n- Set up testing framework\r\n`;\r\n        break;\r\n      case 'active':\r\n        content += `\r\n- Maintain code quality\r\n- Add new features systematically\r\n- Refactor when necessary\r\n- Ensure test coverage\r\n- Document APIs and components\r\n`;\r\n        break;\r\n      case 'mature':\r\n        content += `\r\n- Focus on optimization\r\n- Improve performance\r\n- Enhance security\r\n- Update documentation\r\n- Plan for scaling\r\n`;\r\n        break;\r\n    }\r\n\r\n    return {\r\n      path: '.agent-os/instructions/instructions.md',\r\n      content\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate custom workflows based on tech stack\r\n   */\r\n  async generateWorkflows() {\r\n    const workflows = [];\r\n    const techStack = this.analysis.factors?.techStack || {};\r\n    const features = this.analysis.factors?.features?.detected || {};\r\n\r\n    // Generate tech-specific workflows\r\n    if (techStack.frameworks?.includes('React')) {\r\n      workflows.push({\r\n        path: '.ai-dev/workflows/add-react-component.json',\r\n        content: JSON.stringify({\r\n          name: 'add-react-component',\r\n          description: 'Create a new React component',\r\n          steps: [\r\n            {\r\n              type: 'create-file',\r\n              template: 'react-component',\r\n              path: 'src/components/${componentName}/${componentName}.jsx'\r\n            },\r\n            {\r\n              type: 'create-file',\r\n              template: 'react-component-test',\r\n              path: 'src/components/${componentName}/${componentName}.test.jsx'\r\n            },\r\n            {\r\n              type: 'create-file',\r\n              template: 'react-component-styles',\r\n              path: 'src/components/${componentName}/${componentName}.module.css'\r\n            }\r\n          ]\r\n        }, null, 2)\r\n      });\r\n    }\r\n\r\n    if (techStack.frameworks?.includes('Express')) {\r\n      workflows.push({\r\n        path: '.ai-dev/workflows/add-api-endpoint.json',\r\n        content: JSON.stringify({\r\n          name: 'add-api-endpoint',\r\n          description: 'Create a new API endpoint',\r\n          steps: [\r\n            {\r\n              type: 'create-file',\r\n              template: 'express-controller',\r\n              path: 'src/controllers/${resourceName}Controller.js'\r\n            },\r\n            {\r\n              type: 'create-file',\r\n              template: 'express-route',\r\n              path: 'src/routes/${resourceName}.js'\r\n            },\r\n            {\r\n              type: 'create-file',\r\n              template: 'express-model',\r\n              path: 'src/models/${resourceName}.js'\r\n            },\r\n            {\r\n              type: 'create-file',\r\n              template: 'api-test',\r\n              path: 'tests/api/${resourceName}.test.js'\r\n            }\r\n          ]\r\n        }, null, 2)\r\n      });\r\n    }\r\n\r\n    // Add feature-specific workflows\r\n    if (features.authentication) {\r\n      workflows.push({\r\n        path: '.ai-dev/workflows/setup-auth.json',\r\n        content: JSON.stringify({\r\n          name: 'setup-authentication',\r\n          description: 'Set up authentication system',\r\n          steps: [\r\n            { type: 'install-packages', packages: ['jsonwebtoken', 'bcrypt', 'passport'] },\r\n            { type: 'create-middleware', name: 'auth' },\r\n            { type: 'create-routes', name: 'auth' },\r\n            { type: 'create-models', name: 'user' },\r\n            { type: 'create-tests', name: 'auth' }\r\n          ]\r\n        }, null, 2)\r\n      });\r\n    }\r\n\r\n    return workflows;\r\n  }\r\n\r\n  /**\r\n   * Generate CONTRIBUTING.md\r\n   */\r\n  async generateContributing() {\r\n    const techStack = this.analysis.factors?.techStack || {};\r\n    const stage = this.analysis.stage;\r\n    \r\n    let content = `# Contributing Guidelines\r\n\r\n## Development Setup\r\n\r\n### Prerequisites\r\n`;\r\n\r\n    // Add language-specific prerequisites\r\n    if (techStack.languages?.includes('JavaScript') || techStack.languages?.includes('TypeScript')) {\r\n      content += `- Node.js v18+ and npm/yarn\\n`;\r\n    }\r\n    if (techStack.languages?.includes('Python')) {\r\n      content += `- Python 3.8+ and pip\\n`;\r\n    }\r\n    if (techStack.languages?.includes('Go')) {\r\n      content += `- Go 1.19+\\n`;\r\n    }\r\n    if (techStack.databases?.includes('PostgreSQL')) {\r\n      content += `- PostgreSQL 13+\\n`;\r\n    }\r\n    if (techStack.databases?.includes('MongoDB')) {\r\n      content += `- MongoDB 5.0+\\n`;\r\n    }\r\n\r\n    content += `\r\n### Installation\r\n\r\n\\`\\`\\`bash\r\n# Clone the repository\r\ngit clone <repository-url>\r\ncd <project-name>\r\n\r\n`;\r\n\r\n    // Add language-specific installation\r\n    if (techStack.languages?.includes('JavaScript')) {\r\n      content += `# Install dependencies\r\nnpm install\r\n# or\r\nyarn install\r\n\r\n`;\r\n    }\r\n    if (techStack.languages?.includes('Python')) {\r\n      content += `# Create virtual environment\r\npython -m venv venv\r\nsource venv/bin/activate  # On Windows: venv\\\\Scripts\\\\activate\r\n\r\n# Install dependencies\r\npip install -r requirements.txt\r\n\r\n`;\r\n    }\r\n\r\n    content += `\\`\\`\\`\r\n\r\n## Development Workflow\r\n\r\n### Using AI Development OS\r\nThis project uses the Intelligent Workflow Decision System.\r\n\r\n- **Approach**: ${this.approach.name}\r\n- **Command**: \\`${this.approach.command}\\`\r\n\r\n### Code Standards\r\n`;\r\n\r\n    // Add detected patterns\r\n    const patterns = this.getDetectedPatterns();\r\n    patterns.forEach(pattern => {\r\n      content += `- ${pattern}\\n`;\r\n    });\r\n\r\n    content += `\r\n### Testing\r\n`;\r\n\r\n    if (this.analysis.factors?.testing?.hasTests) {\r\n      content += `Run tests with: \\`npm test\\` or \\`pytest\\`\\n`;\r\n    } else {\r\n      content += `Tests should be added for all new features.\\n`;\r\n    }\r\n\r\n    // Add stage-specific contribution guidelines\r\n    if (stage === 'idea' || stage === 'early') {\r\n      content += `\r\n## Current Focus (${stage} Stage)\r\n- Establishing project structure\r\n- Defining coding standards\r\n- Creating foundational components\r\n- Setting up development environment\r\n`;\r\n    } else if (stage === 'active') {\r\n      content += `\r\n## Current Focus (${stage} Stage)\r\n- Adding new features\r\n- Maintaining code quality\r\n- Improving test coverage\r\n- Updating documentation\r\n`;\r\n    } else if (stage === 'mature') {\r\n      content += `\r\n## Current Focus (${stage} Stage)\r\n- Performance optimization\r\n- Security enhancements\r\n- Bug fixes\r\n- Documentation updates\r\n`;\r\n    }\r\n\r\n    return {\r\n      path: 'CONTRIBUTING.md',\r\n      content\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate DEPLOYMENT.md\r\n   */\r\n  async generateDeployment() {\r\n    const deployment = this.analysis.factors?.deployment || {};\r\n    const techStack = this.analysis.factors?.techStack || {};\r\n    \r\n    let content = `# Deployment Guide\r\n\r\n## Deployment Configuration\r\n`;\r\n\r\n    if (deployment.docker) {\r\n      content += `\r\n### Docker Deployment\r\n\r\n\\`\\`\\`bash\r\n# Build the image\r\ndocker build -t app-name .\r\n\r\n# Run the container\r\ndocker run -p 3000:3000 app-name\r\n\\`\\`\\`\r\n`;\r\n    }\r\n\r\n    if (deployment.kubernetes) {\r\n      content += `\r\n### Kubernetes Deployment\r\n\r\n\\`\\`\\`bash\r\n# Apply configurations\r\nkubectl apply -f k8s/\r\n\r\n# Check deployment status\r\nkubectl get pods\r\nkubectl get services\r\n\\`\\`\\`\r\n`;\r\n    }\r\n\r\n    if (deployment.cloudProvider) {\r\n      content += `\r\n### Cloud Provider: ${deployment.cloudProvider}\r\n\r\n`;\r\n      switch (deployment.cloudProvider) {\r\n        case 'AWS':\r\n          content += `Deploy using AWS ECS, Lambda, or Elastic Beanstalk\\n`;\r\n          break;\r\n        case 'Azure':\r\n          content += `Deploy using Azure App Service or Container Instances\\n`;\r\n          break;\r\n        case 'GCP':\r\n          content += `Deploy using Google App Engine or Cloud Run\\n`;\r\n          break;\r\n        case 'PaaS':\r\n          content += `Deploy using Vercel, Netlify, or Heroku\\n`;\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Add environment variables section\r\n    content += `\r\n## Environment Variables\r\n\r\nCreate a \\`.env\\` file with the following variables:\r\n\r\n\\`\\`\\`env\r\nNODE_ENV=production\r\n`;\r\n\r\n    if (techStack.databases?.includes('PostgreSQL')) {\r\n      content += `DATABASE_URL=postgresql://user:password@host:5432/dbname\\n`;\r\n    }\r\n    if (techStack.databases?.includes('MongoDB')) {\r\n      content += `MONGODB_URI=mongodb://localhost:27017/dbname\\n`;\r\n    }\r\n    if (techStack.databases?.includes('Redis')) {\r\n      content += `REDIS_URL=redis://localhost:6379\\n`;\r\n    }\r\n    if (this.analysis.factors?.features?.detected?.authentication) {\r\n      content += `JWT_SECRET=your-secret-key\\n`;\r\n    }\r\n\r\n    content += `\\`\\`\\`\r\n\r\n## Production Checklist\r\n\r\n- [ ] Environment variables configured\r\n- [ ] Database migrations run\r\n- [ ] SSL certificates installed\r\n- [ ] Security headers configured\r\n- [ ] Rate limiting enabled\r\n- [ ] Monitoring set up\r\n- [ ] Backup strategy implemented\r\n- [ ] CI/CD pipeline configured\r\n`;\r\n\r\n    return {\r\n      path: 'DEPLOYMENT.md',\r\n      content\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate ARCHITECTURE.md\r\n   */\r\n  async generateArchitecture() {\r\n    const architecture = this.analysis.factors?.architecture || {};\r\n    const techStack = this.analysis.factors?.techStack || {};\r\n    \r\n    let content = `# System Architecture\r\n\r\n## Overview\r\n- **Architecture Type**: ${architecture.primaryArchitecture || 'Not determined'}\r\n- **Complexity Score**: ${this.analysis.score}/100\r\n- **Development Stage**: ${this.analysis.stage}\r\n\r\n## Technology Stack\r\n`;\r\n\r\n    // List all technologies\r\n    if (techStack.languages?.length > 0) {\r\n      content += `\\n### Languages\\n`;\r\n      techStack.languages.forEach(lang => {\r\n        content += `- ${lang}\\n`;\r\n      });\r\n    }\r\n\r\n    if (techStack.frameworks?.length > 0) {\r\n      content += `\\n### Frameworks\\n`;\r\n      techStack.frameworks.forEach(fw => {\r\n        content += `- ${fw}\\n`;\r\n      });\r\n    }\r\n\r\n    if (techStack.databases?.length > 0) {\r\n      content += `\\n### Databases\\n`;\r\n      techStack.databases.forEach(db => {\r\n        content += `- ${db}\\n`;\r\n      });\r\n    }\r\n\r\n    // Add architecture diagram placeholder\r\n    content += `\r\n## Architecture Diagram\r\n\r\n\\`\\`\\`\r\n`;\r\n\r\n    if (architecture.primaryArchitecture === 'fullstack' || \r\n        (architecture.patterns?.frontend > 20 && architecture.patterns?.backend > 20)) {\r\n      content += `┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\r\n│   Frontend      │────▶│    Backend      │────▶│    Database     │\r\n│   (React/Vue)   │     │   (Express)     │     │  (PostgreSQL)   │\r\n└─────────────────┘     └─────────────────┘     └─────────────────┘\r\n`;\r\n    } else if (architecture.primaryArchitecture === 'microservices') {\r\n      content += `┌─────────────────┐\r\n│   API Gateway   │\r\n└────────┬────────┘\r\n         │\r\n    ┌────┴────┐\r\n    │         │\r\n┌───▼──┐  ┌──▼───┐\r\n│ Svc1 │  │ Svc2 │\r\n└──────┘  └──────┘\r\n`;\r\n    } else {\r\n      content += `┌─────────────────┐\r\n│   Application   │\r\n└────────┬────────┘\r\n         │\r\n    ┌────▼────┐\r\n    │Database │\r\n    └─────────┘\r\n`;\r\n    }\r\n\r\n    content += `\\`\\`\\`\r\n\r\n## Key Components\r\n`;\r\n\r\n    // Describe detected components\r\n    if (architecture.patterns?.frontend > 20) {\r\n      content += `\r\n### Frontend Layer\r\n- Component-based architecture\r\n- State management system\r\n- Routing configuration\r\n- API integration layer\r\n`;\r\n    }\r\n\r\n    if (architecture.patterns?.backend > 20) {\r\n      content += `\r\n### Backend Layer\r\n- RESTful API endpoints\r\n- Business logic layer\r\n- Data access layer\r\n- Authentication/Authorization\r\n`;\r\n    }\r\n\r\n    if (architecture.patterns?.database > 20) {\r\n      content += `\r\n### Data Layer\r\n- Database schema design\r\n- Data models/entities\r\n- Migration system\r\n- Caching strategy\r\n`;\r\n    }\r\n\r\n    return {\r\n      path: 'ARCHITECTURE.md',\r\n      content\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate SPARC methodology phases\r\n   */\r\n  async generateSPARCPhases() {\r\n    const phases = [];\r\n    const projectName = path.basename(this.projectPath);\r\n    \r\n    // Specification Phase\r\n    phases.push({\r\n      path: '.claude-flow/sparc-phases/1-specification.md',\r\n      content: `# SPARC Phase 1: Specification\r\n\r\n## Project: ${projectName}\r\n## Complexity Score: ${this.analysis.score}/100\r\n\r\n### Requirements Analysis\r\n${this.generateRequirements()}\r\n\r\n### Success Criteria\r\n${this.generateSuccessCriteria()}\r\n\r\n### Constraints\r\n${this.generateConstraints()}\r\n`\r\n    });\r\n\r\n    // Pseudocode Phase\r\n    phases.push({\r\n      path: '.claude-flow/sparc-phases/2-pseudocode.md',\r\n      content: `# SPARC Phase 2: Pseudocode\r\n\r\n## Core Algorithms\r\n${this.generatePseudocode()}\r\n\r\n## Data Structures\r\n${this.generateDataStructures()}\r\n`\r\n    });\r\n\r\n    // Architecture Phase\r\n    phases.push({\r\n      path: '.claude-flow/sparc-phases/3-architecture.md',\r\n      content: `# SPARC Phase 3: Architecture\r\n\r\n## System Design\r\n${this.generateSystemDesign()}\r\n\r\n## Component Breakdown\r\n${this.generateComponentBreakdown()}\r\n`\r\n    });\r\n\r\n    // Refinement Phase\r\n    phases.push({\r\n      path: '.claude-flow/sparc-phases/4-refinement.md',\r\n      content: `# SPARC Phase 4: Refinement\r\n\r\n## Optimization Opportunities\r\n${this.generateOptimizations()}\r\n\r\n## Code Quality Improvements\r\n${this.generateQualityImprovements()}\r\n`\r\n    });\r\n\r\n    // Completion Phase\r\n    phases.push({\r\n      path: '.claude-flow/sparc-phases/5-completion.md',\r\n      content: `# SPARC Phase 5: Completion\r\n\r\n## Implementation Checklist\r\n${this.generateImplementationChecklist()}\r\n\r\n## Testing Strategy\r\n${this.generateTestingStrategy()}\r\n\r\n## Deployment Plan\r\n${this.generateDeploymentPlan()}\r\n`\r\n    });\r\n\r\n    return phases;\r\n  }\r\n\r\n  // Helper methods for language/framework specific guidelines\r\n  getLanguageGuidelines(language) {\r\n    const guidelines = {\r\n      'JavaScript': `  - Use ES6+ features\r\n  - Async/await for asynchronous code\r\n  - Proper error handling\r\n`,\r\n      'TypeScript': `  - Strict type checking\r\n  - Interface definitions\r\n  - Generic types where appropriate\r\n`,\r\n      'Python': `  - PEP 8 compliance\r\n  - Type hints\r\n  - Virtual environments\r\n`,\r\n      'Go': `  - Effective Go principles\r\n  - Error handling patterns\r\n  - Goroutines for concurrency\r\n`\r\n    };\r\n    return guidelines[language] || '';\r\n  }\r\n\r\n  getFrameworkGuidelines(framework) {\r\n    const guidelines = {\r\n      'React': `  - Functional components with hooks\r\n  - Component composition\r\n  - State management patterns\r\n`,\r\n      'Vue': `  - Composition API\r\n  - Component organization\r\n  - Vuex for state management\r\n`,\r\n      'Express': `  - Middleware architecture\r\n  - Route organization\r\n  - Error handling middleware\r\n`,\r\n      'Django': `  - MVT pattern\r\n  - Django REST framework\r\n  - Model migrations\r\n`,\r\n      'FastAPI': `  - Type-driven development\r\n  - Async endpoints\r\n  - OpenAPI documentation\r\n`\r\n    };\r\n    return guidelines[framework] || '';\r\n  }\r\n\r\n  getDatabaseGuidelines(database) {\r\n    const guidelines = {\r\n      'MongoDB': `  - Document design patterns\r\n  - Indexing strategy\r\n  - Aggregation pipelines\r\n`,\r\n      'PostgreSQL': `  - Normalized schema design\r\n  - ACID compliance\r\n  - Query optimization\r\n`,\r\n      'MySQL': `  - Table relationships\r\n  - Query optimization\r\n  - Replication setup\r\n`,\r\n      'Redis': `  - Caching strategies\r\n  - Data expiration\r\n  - Pub/sub patterns\r\n`\r\n    };\r\n    return guidelines[database] || '';\r\n  }\r\n\r\n  getArchitectureGuidelines(architecture) {\r\n    const guidelines = {\r\n      'microservices': `- Service boundaries and responsibilities\r\n- Inter-service communication (REST/gRPC)\r\n- Service discovery and load balancing\r\n- Distributed tracing and monitoring\r\n- Circuit breaker patterns\r\n`,\r\n      'monolith': `- Clear module separation\r\n- Layered architecture (presentation, business, data)\r\n- Dependency injection\r\n- Single deployment unit\r\n`,\r\n      'frontend': `- Component-based architecture\r\n- State management patterns\r\n- Client-side routing\r\n- API integration layer\r\n`,\r\n      'backend': `- RESTful API design\r\n- Service layer pattern\r\n- Repository pattern for data access\r\n- Authentication and authorization\r\n`,\r\n      'fullstack': `- Clear frontend/backend separation\r\n- API contract definition\r\n- Shared type definitions\r\n- End-to-end testing\r\n`\r\n    };\r\n    return guidelines[architecture] || '';\r\n  }\r\n\r\n  getStageInstructions(stage) {\r\n    const instructions = {\r\n      'idea': `- Focus on comprehensive planning and specification\r\n- Define clear requirements and success criteria\r\n- Design system architecture before implementation\r\n- Create detailed implementation roadmap\r\n`,\r\n      'early': `- Establish coding standards and patterns\r\n- Build foundational components first\r\n- Set up development and testing environment\r\n- Create initial documentation\r\n`,\r\n      'active': `- Maintain consistent code quality\r\n- Add features systematically\r\n- Ensure adequate test coverage\r\n- Keep documentation up to date\r\n`,\r\n      'mature': `- Focus on optimization and performance\r\n- Enhance security measures\r\n- Improve monitoring and logging\r\n- Plan for scaling and maintenance\r\n`\r\n    };\r\n    return instructions[stage] || '';\r\n  }\r\n\r\n  getApproachWorkflow(approach) {\r\n    const workflows = {\r\n      'simpleSwarm': `1. Quick task analysis\r\n2. Single-agent coordination\r\n3. Focused implementation\r\n4. Rapid iteration\r\n`,\r\n      'hiveMind': `1. Multi-agent task distribution\r\n2. Parallel development streams\r\n3. Cross-agent coordination\r\n4. Integrated testing\r\n5. Consolidated deployment\r\n`,\r\n      'hiveMindSparc': `1. SPARC Phase 1: Specification\r\n2. SPARC Phase 2: Pseudocode\r\n3. SPARC Phase 3: Architecture\r\n4. SPARC Phase 4: Refinement\r\n5. SPARC Phase 5: Completion\r\n6. Multi-agent implementation\r\n7. Systematic testing\r\n8. Enterprise deployment\r\n`\r\n    };\r\n    return workflows[approach] || '';\r\n  }\r\n\r\n  getDetectedPatterns() {\r\n    const patterns = [];\r\n    const analysis = this.analysis;\r\n    \r\n    // Add detected patterns from analysis\r\n    if (analysis.factors?.size?.fileCount < 50) {\r\n      patterns.push('Small codebase - focus on simplicity');\r\n    } else {\r\n      patterns.push('Large codebase - maintain clear organization');\r\n    }\r\n    \r\n    if (analysis.factors?.testing?.hasTests) {\r\n      patterns.push('Test-driven development practices');\r\n    }\r\n    \r\n    if (analysis.factors?.features?.detected?.authentication) {\r\n      patterns.push('Security-first development');\r\n    }\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  // SPARC helper methods\r\n  generateRequirements() {\r\n    const features = this.analysis.factors?.features?.detected || {};\r\n    let requirements = '';\r\n    \r\n    if (features.authentication) {\r\n      requirements += '- User authentication and authorization system\\n';\r\n    }\r\n    if (features.api) {\r\n      requirements += '- RESTful API with proper documentation\\n';\r\n    }\r\n    if (features.realtime) {\r\n      requirements += '- Real-time communication capabilities\\n';\r\n    }\r\n    if (features.database) {\r\n      requirements += '- Persistent data storage and retrieval\\n';\r\n    }\r\n    \r\n    return requirements || '- To be determined based on project requirements\\n';\r\n  }\r\n\r\n  generateSuccessCriteria() {\r\n    return `- All tests passing\r\n- Code coverage > 80%\r\n- Performance benchmarks met\r\n- Security audit passed\r\n- Documentation complete\r\n`;\r\n  }\r\n\r\n  generateConstraints() {\r\n    return `- Technology stack: ${this.analysis.factors?.techStack?.languages?.join(', ') || 'Not specified'}\r\n- Timeline: Based on complexity score (${this.analysis.score}/100)\r\n- Resources: ${this.approach.agentCount} agents allocated\r\n`;\r\n  }\r\n\r\n  generatePseudocode() {\r\n    return `// Core application flow\r\nfunction main() {\r\n  initialize_application()\r\n  setup_middleware()\r\n  configure_routes()\r\n  connect_to_database()\r\n  start_server()\r\n}\r\n`;\r\n  }\r\n\r\n  generateDataStructures() {\r\n    return `- User Model\r\n- Session Management\r\n- Request/Response Objects\r\n- Configuration Objects\r\n`;\r\n  }\r\n\r\n  generateSystemDesign() {\r\n    return `- Layered architecture\r\n- Service-oriented design\r\n- Event-driven components\r\n- Scalable infrastructure\r\n`;\r\n  }\r\n\r\n  generateComponentBreakdown() {\r\n    return `- Frontend components\r\n- Backend services\r\n- Data access layer\r\n- External integrations\r\n`;\r\n  }\r\n\r\n  generateOptimizations() {\r\n    return `- Code refactoring opportunities\r\n- Performance bottleneck resolution\r\n- Memory usage optimization\r\n- Query optimization\r\n`;\r\n  }\r\n\r\n  generateQualityImprovements() {\r\n    return `- Code review findings\r\n- Test coverage gaps\r\n- Documentation updates\r\n- Security enhancements\r\n`;\r\n  }\r\n\r\n  generateImplementationChecklist() {\r\n    return `- [ ] Core features implemented\r\n- [ ] Tests written and passing\r\n- [ ] Documentation updated\r\n- [ ] Code reviewed\r\n- [ ] Performance tested\r\n- [ ] Security validated\r\n`;\r\n  }\r\n\r\n  generateTestingStrategy() {\r\n    return `- Unit tests for all components\r\n- Integration tests for APIs\r\n- End-to-end tests for critical paths\r\n- Performance testing\r\n- Security testing\r\n`;\r\n  }\r\n\r\n  generateDeploymentPlan() {\r\n    return `- Environment setup\r\n- Database migrations\r\n- Configuration management\r\n- Monitoring setup\r\n- Rollback procedures\r\n`;\r\n  }\r\n\r\n  loadTemplates() {\r\n    // In a real implementation, these would be loaded from template files\r\n    return {\r\n      'react-component': `import React from 'react';\r\n\r\nconst {{componentName}} = () => {\r\n  return (\r\n    <div>\r\n      {{componentName}} Component\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default {{componentName}};`,\r\n      'express-controller': `const {{resourceName}}Service = require('../services/{{resourceName}}Service');\r\n\r\nexports.getAll = async (req, res) => {\r\n  try {\r\n    const items = await {{resourceName}}Service.findAll();\r\n    res.json(items);\r\n  } catch (error) {\r\n    res.status(500).json({ error: error.message });\r\n  }\r\n};`\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate agent configurations based on project complexity\r\n   */\r\n  async generateAgentConfigs() {\r\n    const configs = {};\r\n    const complexity = this.analysis.score || 0;\r\n    \r\n    // Always include orchestrator\r\n    configs['workflow-orchestrator'] = true;\r\n    \r\n    // Add agents based on complexity\r\n    if (complexity > 20) {\r\n      configs['complexity-analyzer-agent'] = true;\r\n      configs['approach-selector-agent'] = true;\r\n    }\r\n    \r\n    if (complexity > 40) {\r\n      configs['document-customizer-agent'] = true;\r\n      configs['integration-coordinator-agent'] = true;\r\n    }\r\n    \r\n    if (complexity > 70) {\r\n      configs['sparc-methodology-agent'] = true;\r\n    }\r\n    \r\n    // Generate agent config files\r\n    const agentFiles = {};\r\n    const agentTemplateDir = path.join(__dirname, '..', 'agent-templates');\r\n    \r\n    for (const agentName of Object.keys(configs)) {\r\n      const templatePath = path.join(agentTemplateDir, `${agentName}.md`);\r\n      if (fs.existsSync(templatePath)) {\r\n        const template = fs.readFileSync(templatePath, 'utf8');\r\n        \r\n        // Customize template based on project\r\n        let customized = template;\r\n        \r\n        // Add project-specific context\r\n        customized = customized.replace(/\\[Project Name\\]/g, this.analysis.projectName || 'Project');\r\n        customized = customized.replace(/\\[complexity\\]/g, complexity);\r\n        customized = customized.replace(/\\[approach\\]/g, this.approach.name);\r\n        \r\n        agentFiles[`${agentName}.md`] = customized;\r\n      }\r\n    }\r\n    \r\n    return {\r\n      enabled: Object.keys(configs),\r\n      files: agentFiles,\r\n      orchestration: {\r\n        master: 'workflow-orchestrator',\r\n        complexity,\r\n        approach: this.approach.selected\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect if running in container environment\r\n   */\r\n  detectContainerEnvironment() {\r\n    // Check for common container indicators\r\n    if (process.env.CONTAINER || \r\n        fs.existsSync('/.dockerenv') || \r\n        fs.existsSync('/run/.containerenv') ||\r\n        process.env.KUBERNETES_SERVICE_HOST) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for devcontainer\r\n    if (process.env.REMOTE_CONTAINERS || \r\n        process.env.CODESPACES ||\r\n        fs.existsSync('/workspaces/.devcontainer')) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Generate optimal command based on environment and analysis\r\n   */\r\n  generateOptimalCommand() {\r\n    const score = this.analysis.score || 50;\r\n    const versionName = versionPolicy.getSelectedVersionName({ analysis: this.analysis });\r\n    const isContainer = this.detectContainerEnvironment();\r\n    const hasYolo = process.env.YOLO_MODE === 'true';\r\n    \r\n    let command = 'npx claude-flow';\r\n    command += versionPolicy.suffixFor(versionName);\r\n    \r\n    if (score <= 30) {\r\n      command += ' swarm';\r\n    } else if (score <= 70) {\r\n      command += ' hive-mind spawn --agents 4';\r\n    } else {\r\n      command += ' hive-mind spawn --sparc --agents 8';\r\n    }\r\n    \r\n    // Add appropriate Claude command\r\n    command += hasYolo ? ' --yolo' : ' --claude';\r\n    \r\n    // Add container-specific flags if needed\r\n    if (isContainer) {\r\n      command += ' --container-mode';\r\n    }\r\n    \r\n    command += ` \"MASTER-WORKFLOW\"`;\r\n    \r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * Generate slash commands for workflow control\r\n   */\r\n  async generateSlashCommands() {\r\n    const commands = {};\r\n    const commandTemplateDir = path.join(__dirname, '..', 'slash-commands');\r\n    \r\n    // Core commands always included\r\n    const coreCommands = ['workflow', 'analyze', 'agents'];\r\n    \r\n    // Add SPARC command if high complexity\r\n    if (this.analysis.score > 70 || this.approach.selected === 'hiveMindSparc') {\r\n      coreCommands.push('sparc');\r\n    }\r\n    \r\n    // Add quick command for simple projects\r\n    if (this.analysis.score < 50) {\r\n      coreCommands.push('quick');\r\n    }\r\n    \r\n    // Generate command files\r\n    for (const cmdName of coreCommands) {\r\n      const templatePath = path.join(commandTemplateDir, `${cmdName}.md`);\r\n      if (fs.existsSync(templatePath)) {\r\n        const template = fs.readFileSync(templatePath, 'utf8');\r\n        \r\n        // Customize based on project\r\n        let customized = template;\r\n        const versionName = versionPolicy.getSelectedVersionName({ analysis: this.analysis });\r\n        customized = customized.replace(/\\[version\\]/g, versionName);\r\n        customized = customized.replace(/\\[project\\]/g, this.analysis.projectName || 'project');\r\n        \r\n        commands[`${cmdName}.md`] = customized;\r\n      }\r\n    }\r\n    \r\n    return {\r\n      enabled: coreCommands,\r\n      files: commands,\r\n      defaultCommand: this.analysis.score > 70 ? 'sparc' : 'workflow'\r\n    };\r\n  }\r\n}\r\n\r\n// CLI execution\r\nif (require.main === module) {\r\n  const analysisPath = process.argv[2];\r\n  const approachPath = process.argv[3];\r\n  \r\n  if (!analysisPath || !approachPath) {\r\n    console.error('Usage: document-customizer.js <analysis.json> <approach.json>');\r\n    process.exit(1);\r\n  }\r\n  \r\n  try {\r\n    const analysis = JSON.parse(fs.readFileSync(analysisPath, 'utf8'));\r\n    const approach = JSON.parse(fs.readFileSync(approachPath, 'utf8'));\r\n    \r\n    const customizer = new DocumentCustomizer(analysis, approach);\r\n    customizer.generateDocuments().then(documents => {\r\n      console.log(JSON.stringify(documents, null, 2));\r\n    });\r\n  } catch (error) {\r\n    console.error('Error:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nmodule.exports = DocumentCustomizer;",
          "size": 37470,
          "lastModified": "2025-08-12T23:39:17.646Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": true,
          "agentOSVersion": "30",
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "signatures",
                "position": 8404
              },
              {
                "name": "main",
                "position": 29699
              }
            ],
            "classes": [
              {
                "name": "DocumentCustomizer",
                "position": 309
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/install-dependencies.sh": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/install-dependencies.sh",
          "fileName": "install-dependencies.sh",
          "extension": "sh",
          "type": "shell",
          "content": "#!/bin/bash\n\n# SharedMemoryStore Dependencies Installation Script\n# This script installs necessary dependencies for the SharedMemoryStore implementation\n\necho \"🔧 Installing SharedMemoryStore dependencies...\"\n\n# Change to the project root directory\ncd \"$(dirname \"$0\")/..\"\n\n# Install SQLite3 for Node.js (optional, will fallback to file-based storage if fails)\necho \"📦 Installing sqlite3 module...\"\nif npm install sqlite3; then\n    echo \"✅ sqlite3 installed successfully\"\nelse\n    echo \"⚠️ sqlite3 installation failed, SharedMemoryStore will use file-based fallback\"\n    echo \"   This is not critical - the system will work with reduced performance\"\nfi\n\n# Install any other optional dependencies\necho \"📦 Installing optional performance dependencies...\"\n\n# Try to install better-sqlite3 as an alternative (faster SQLite driver)\nif npm install better-sqlite3 --optional; then\n    echo \"✅ better-sqlite3 installed (performance boost available)\"\nelse\n    echo \"ℹ️ better-sqlite3 not installed (optional)\"\nfi\n\n# Ensure .hive-mind directory exists\necho \"📁 Setting up .hive-mind directory structure...\"\nmkdir -p .hive-mind/backups\nmkdir -p .hive-mind/sessions\n\n# Create initial database files if they don't exist\nif [ ! -f \".hive-mind/hive.db\" ]; then\n    echo \"🗃️ Creating initial hive.db...\"\n    touch .hive-mind/hive.db\nfi\n\nif [ ! -f \".hive-mind/memory.db\" ]; then\n    echo \"🗃️ Creating initial memory.db...\"\n    touch .hive-mind/memory.db\nfi\n\n# Set appropriate permissions\nchmod 755 .hive-mind\nchmod 644 .hive-mind/*.db 2>/dev/null || true\nchmod 755 .hive-mind/backups\nchmod 755 .hive-mind/sessions\n\necho \"🧪 Running basic functionality test...\"\n\n# Test the SharedMemoryStore\nnode -e \"\nconst SharedMemoryStore = require('./intelligence-engine/shared-memory');\nconsole.log('✅ SharedMemoryStore module loads correctly');\n\n// Quick initialization test\nconst memory = new SharedMemoryStore({\n  projectRoot: process.cwd(),\n  maxMemorySize: 10 * 1024 * 1024, // 10MB for test\n  maxEntries: 1000,\n  gcInterval: 60000 // 1 minute for test\n});\n\nmemory.once('initialized', () => {\n  console.log('✅ SharedMemoryStore initializes correctly');\n  \n  // Quick functionality test\n  memory.set('test-key', { message: 'Hello, World!' }, { agentId: 'test' })\n    .then(() => memory.get('test-key'))\n    .then((value) => {\n      if (value && value.message === 'Hello, World!') {\n        console.log('✅ Basic read/write operations work correctly');\n      } else {\n        console.log('❌ Basic operations failed');\n      }\n      \n      const stats = memory.getStats();\n      console.log('📊 Memory Stats:', {\n        entries: stats.entryCount,\n        memory: stats.memoryUsage,\n        dbAvailable: stats.dbStatus.available\n      });\n      \n      return memory.shutdown();\n    })\n    .then(() => {\n      console.log('✅ SharedMemoryStore test completed successfully');\n      process.exit(0);\n    })\n    .catch((error) => {\n      console.error('❌ SharedMemoryStore test failed:', error.message);\n      process.exit(1);\n    });\n});\n\nmemory.on('error', (error) => {\n  console.error('❌ SharedMemoryStore error:', error.message);\n  process.exit(1);\n});\n\" || echo \"⚠️ Basic test failed, but installation may still be functional\"\n\necho \"\"\necho \"🎉 SharedMemoryStore installation completed!\"\necho \"\"\necho \"📋 Installation Summary:\"\necho \"   ✅ SharedMemoryStore module ready\"\necho \"   ✅ .hive-mind directory structure created\"\necho \"   📁 Database files: .hive-mind/hive.db, .hive-mind/memory.db\"\necho \"   📁 Backup directory: .hive-mind/backups/\"\necho \"   📁 Sessions directory: .hive-mind/sessions/\"\necho \"\"\necho \"🚀 Usage:\"\necho \"   const SharedMemoryStore = require('./intelligence-engine/shared-memory');\"\necho \"   const memory = new SharedMemoryStore({ projectRoot: process.cwd() });\"\necho \"\"\necho \"📖 Documentation: ./intelligence-engine/SHARED-MEMORY-README.md\"\necho \"🧪 Testing: node ./intelligence-engine/test-shared-memory.js\"\necho \"💡 Integration Example: node ./intelligence-engine/memory-integration-example.js\"\necho \"\"\n\nif command -v sqlite3 >/dev/null 2>&1; then\n    echo \"🗃️ SQLite CLI available: sqlite3 .hive-mind/memory.db\"\nelse\n    echo \"ℹ️ Install sqlite3 CLI for database inspection: apt-get install sqlite3\"\nfi\n\necho \"✨ Ready for production use!\"",
          "size": 4242,
          "lastModified": "2025-08-13T02:15:58.411Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "variables": [],
            "commands": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "variables": [],
          "functions": [],
          "commands": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/document-generator-v2.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/document-generator-v2.js",
          "fileName": "document-generator-v2.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Document Generator v2\n * Phase 3 Implementation - MASTER-WORKFLOW v3.0\n * \n * Advanced document generation system with interactive updates,\n * diff preview, and customization preservation.\n * \n * Features:\n * - Interactive update mode (update/skip/preview per document)\n * - Diff preview showing exact changes\n * - Customization preservation (preserves user modifications)\n * - Document versioning with rollback capability\n * - Agent-OS document generation\n * - Integration with specialized doc-generator-agent\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst readline = require('readline');\nconst chalk = require('chalk');\nconst diff = require('diff');\nconst EventEmitter = require('events');\n\n// Import existing components\nconst DocumentCustomizer = require('./document-customizer');\nconst SharedMemoryStore = require('./shared-memory');\nconst QueenController = require('./queen-controller');\nconst AgentCommunication = require('./agent-communication');\n\n// Import supporting components\nconst InteractiveDocumentUpdater = require('./interactive-updater');\nconst CustomizationManager = require('./customization-manager');\nconst DocumentVersioning = require('./document-versioning');\nconst EnhancedTemplateEngine = require('./enhanced-template-engine');\n\nclass DocumentGeneratorV2 extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Integration with existing systems\n    this.queenController = options.queenController || new QueenController();\n    this.sharedMemory = options.sharedMemory || new SharedMemoryStore();\n    this.agentCommunication = options.agentCommunication || new AgentCommunication();\n    \n    // Core components\n    this.interactiveUpdater = new InteractiveDocumentUpdater(this.sharedMemory);\n    this.customizationManager = new CustomizationManager(this.sharedMemory);\n    this.versionManager = new DocumentVersioning(this.sharedMemory);\n    this.templateEngine = new EnhancedTemplateEngine(this.sharedMemory);\n    \n    // Inherit from existing DocumentCustomizer\n    this.documentCustomizer = null; // Will be initialized with analysis\n    \n    // Configuration\n    this.config = {\n      interactive: true,\n      preserveCustomizations: true,\n      showDiff: true,\n      autoBackup: true,\n      batchSimilar: true,\n      maxVersions: 10,\n      ...options.config\n    };\n    \n    // State management\n    this.pendingUpdates = new Map();\n    this.customizations = new Map();\n    this.documentVersions = new Map();\n    this.userPreferences = new Map();\n    \n    // Setup readline interface for interactive mode\n    this.rl = null;\n    \n    this.setupEventHandlers();\n  }\n  \n  /**\n   * Setup event handlers for agent communication\n   */\n  setupEventHandlers() {\n    this.agentCommunication.on('doc-generation-request', this.handleGenerationRequest.bind(this));\n    this.agentCommunication.on('doc-update-request', this.handleUpdateRequest.bind(this));\n    this.agentCommunication.on('customization-detected', this.handleCustomizationDetected.bind(this));\n  }\n  \n  /**\n   * Main entry point for interactive document generation\n   */\n  async generateDocumentsInteractive(analysis, approach, options = {}) {\n    const generationId = `doc-gen-${Date.now()}`;\n    \n    try {\n      // Initialize document customizer with analysis\n      this.documentCustomizer = new DocumentCustomizer(analysis, approach);\n      \n      // Store generation request in shared memory\n      await this.storeGenerationRequest(generationId, analysis, approach, options);\n      \n      // Check for existing documents\n      const existingDocs = await this.scanForExistingDocuments();\n      \n      if (existingDocs.length > 0 && this.config.interactive) {\n        // Interactive update mode\n        return await this.interactiveUpdateMode(existingDocs, analysis, approach, options);\n      } else {\n        // Fresh generation\n        return await this.generateFreshDocuments(analysis, approach, options);\n      }\n      \n    } catch (error) {\n      this.emit('generation-error', { generationId, error });\n      throw error;\n    } finally {\n      // Cleanup\n      if (this.rl) {\n        this.rl.close();\n      }\n    }\n  }\n  \n  /**\n   * Interactive update mode for existing documents\n   */\n  async interactiveUpdateMode(existingDocs, analysis, approach, options) {\n    console.log(chalk.cyan('\\n📄 Document Update Mode'));\n    console.log(chalk.gray('Found existing documents. How would you like to proceed?\\n'));\n    \n    // Group similar documents for batch operations\n    const documentGroups = this.config.batchSimilar ? \n      await this.groupSimilarDocuments(existingDocs) : \n      existingDocs.map(doc => [doc]);\n    \n    const updateResults = {\n      updated: [],\n      skipped: [],\n      preserved: [],\n      errors: []\n    };\n    \n    for (const group of documentGroups) {\n      const updatePlan = await this.createUpdatePlan(group, analysis, approach);\n      \n      // Present options to user\n      const choice = await this.presentUpdateOptions(updatePlan);\n      \n      switch (choice) {\n        case 'update':\n          await this.updateDocuments(updatePlan, updateResults);\n          break;\n          \n        case 'skip':\n          updateResults.skipped.push(...group);\n          break;\n          \n        case 'preview':\n          await this.showDiffPreview(updatePlan);\n          // Re-ask after preview\n          const postPreviewChoice = await this.presentUpdateOptions(updatePlan);\n          if (postPreviewChoice === 'update') {\n            await this.updateDocuments(updatePlan, updateResults);\n          } else {\n            updateResults.skipped.push(...group);\n          }\n          break;\n          \n        case 'customize':\n          await this.customizeUpdate(updatePlan, updateResults);\n          break;\n      }\n    }\n    \n    // Generate summary report\n    const report = await this.generateUpdateReport(updateResults);\n    \n    // Store results in shared memory\n    await this.storeUpdateResults(updateResults);\n    \n    return report;\n  }\n  \n  /**\n   * Generate fresh documents (no existing documents)\n   */\n  async generateFreshDocuments(analysis, approach, options) {\n    console.log(chalk.green('\\n🚀 Generating new documents...'));\n    \n    const documents = await this.documentCustomizer.generateAllDocuments();\n    \n    // Create document versions\n    for (const doc of documents) {\n      await this.versionManager.createSnapshot(doc.path, doc.content);\n    }\n    \n    // Write documents to disk\n    for (const doc of documents) {\n      await this.writeDocument(doc.path, doc.content);\n    }\n    \n    console.log(chalk.green(`✅ Generated ${documents.length} documents successfully!`));\n    \n    return {\n      generated: documents.length,\n      documents: documents.map(d => d.path)\n    };\n  }\n  \n  /**\n   * Create update plan for documents\n   */\n  async createUpdatePlan(documents, analysis, approach) {\n    const plan = {\n      documents: [],\n      customizations: [],\n      changes: []\n    };\n    \n    for (const docPath of documents) {\n      // Read existing document\n      const existingContent = await this.readDocument(docPath);\n      \n      // Generate new content\n      const newContent = await this.generateDocumentContent(docPath, analysis, approach);\n      \n      // Detect customizations\n      const customizations = await this.customizationManager.detectCustomizations(\n        existingContent, \n        newContent\n      );\n      \n      // Create diff\n      const diff = this.createDiff(existingContent, newContent);\n      \n      plan.documents.push({\n        path: docPath,\n        existing: existingContent,\n        new: newContent,\n        customizations,\n        diff\n      });\n    }\n    \n    return plan;\n  }\n  \n  /**\n   * Present update options to user\n   */\n  async presentUpdateOptions(updatePlan) {\n    const docCount = updatePlan.documents.length;\n    const customCount = updatePlan.documents.reduce(\n      (sum, doc) => sum + doc.customizations.length, \n      0\n    );\n    \n    console.log(chalk.yellow(`\\n📝 ${docCount} document(s) have updates available`));\n    \n    if (customCount > 0) {\n      console.log(chalk.magenta(`   ${customCount} customization(s) detected and will be preserved`));\n    }\n    \n    console.log('\\nOptions:');\n    console.log('  1) Update - Apply updates while preserving customizations');\n    console.log('  2) Skip - Keep existing documents unchanged');\n    console.log('  3) Preview - Show diff of changes');\n    console.log('  4) Customize - Choose specific changes to apply');\n    \n    const choice = await this.getUserChoice(['1', '2', '3', '4']);\n    \n    const choices = {\n      '1': 'update',\n      '2': 'skip',\n      '3': 'preview',\n      '4': 'customize'\n    };\n    \n    return choices[choice];\n  }\n  \n  /**\n   * Show diff preview of changes\n   */\n  async showDiffPreview(updatePlan) {\n    console.log(chalk.cyan('\\n📊 Document Changes Preview:'));\n    console.log(chalk.gray('=' .repeat(80)));\n    \n    for (const doc of updatePlan.documents) {\n      console.log(chalk.bold(`\\n📄 ${doc.path}`));\n      console.log(chalk.gray('-'.repeat(40)));\n      \n      // Show diff with colors\n      const changes = diff.diffLines(doc.existing, doc.new);\n      \n      changes.forEach(part => {\n        if (part.added) {\n          console.log(chalk.green('+' + part.value));\n        } else if (part.removed) {\n          console.log(chalk.red('-' + part.value));\n        } else {\n          // Show context lines (first and last 2 lines of unchanged parts)\n          const lines = part.value.split('\\n');\n          if (lines.length > 4) {\n            console.log(chalk.gray(lines.slice(0, 2).join('\\n')));\n            console.log(chalk.gray('  ...'));\n            console.log(chalk.gray(lines.slice(-2).join('\\n')));\n          } else {\n            console.log(chalk.gray(part.value));\n          }\n        }\n      });\n      \n      // Show preserved customizations\n      if (doc.customizations.length > 0) {\n        console.log(chalk.magenta('\\n✨ Preserved Customizations:'));\n        doc.customizations.forEach(custom => {\n          console.log(chalk.magenta(`  - ${custom.type}: ${custom.description}`));\n        });\n      }\n    }\n    \n    console.log(chalk.gray('\\n' + '='.repeat(80)));\n  }\n  \n  /**\n   * Update documents with customization preservation\n   */\n  async updateDocuments(updatePlan, results) {\n    console.log(chalk.cyan('\\n🔄 Updating documents...'));\n    \n    for (const doc of updatePlan.documents) {\n      try {\n        // Backup existing document\n        if (this.config.autoBackup) {\n          await this.versionManager.createSnapshot(doc.path, doc.existing);\n        }\n        \n        // Merge with customizations\n        const mergedContent = await this.customizationManager.mergeWithCustomizations(\n          doc.new,\n          doc.customizations\n        );\n        \n        // Write updated document\n        await this.writeDocument(doc.path, mergedContent);\n        \n        results.updated.push(doc.path);\n        results.preserved.push(...doc.customizations);\n        \n        console.log(chalk.green(`  ✅ Updated: ${doc.path}`));\n        \n      } catch (error) {\n        console.error(chalk.red(`  ❌ Error updating ${doc.path}: ${error.message}`));\n        results.errors.push({ path: doc.path, error });\n      }\n    }\n  }\n  \n  /**\n   * Customize specific updates\n   */\n  async customizeUpdate(updatePlan, results) {\n    console.log(chalk.cyan('\\n🎨 Customization Mode'));\n    \n    for (const doc of updatePlan.documents) {\n      console.log(chalk.bold(`\\n📄 ${doc.path}`));\n      \n      // Show each change and ask for confirmation\n      const changes = diff.diffLines(doc.existing, doc.new);\n      const acceptedChanges = [];\n      \n      for (const change of changes) {\n        if (change.added || change.removed) {\n          console.log(chalk.yellow('\\nChange:'));\n          \n          if (change.removed) {\n            console.log(chalk.red('-' + change.value));\n          }\n          if (change.added) {\n            console.log(chalk.green('+' + change.value));\n          }\n          \n          const accept = await this.askYesNo('Accept this change?');\n          if (accept) {\n            acceptedChanges.push(change);\n          }\n        } else {\n          acceptedChanges.push(change); // Keep unchanged parts\n        }\n      }\n      \n      // Apply accepted changes\n      const customizedContent = this.applySelectedChanges(doc.existing, acceptedChanges);\n      \n      // Write customized document\n      await this.writeDocument(doc.path, customizedContent);\n      results.updated.push(doc.path);\n    }\n  }\n  \n  /**\n   * Group similar documents for batch operations\n   */\n  async groupSimilarDocuments(documents) {\n    const groups = new Map();\n    \n    for (const doc of documents) {\n      const type = this.getDocumentType(doc);\n      \n      if (!groups.has(type)) {\n        groups.set(type, []);\n      }\n      \n      groups.get(type).push(doc);\n    }\n    \n    return Array.from(groups.values());\n  }\n  \n  /**\n   * Get document type for grouping\n   */\n  getDocumentType(docPath) {\n    const basename = path.basename(docPath);\n    \n    if (basename === 'CLAUDE.md') return 'claude-config';\n    if (basename === 'Agent-OS.md') return 'agent-os';\n    if (basename.endsWith('.rules')) return 'rules';\n    if (basename.endsWith('.md')) return 'documentation';\n    if (basename.endsWith('.json')) return 'config';\n    \n    return 'other';\n  }\n  \n  /**\n   * Generate document content based on path\n   */\n  async generateDocumentContent(docPath, analysis, approach) {\n    const basename = path.basename(docPath);\n    \n    // Use appropriate generator based on document type\n    switch (basename) {\n      case 'CLAUDE.md':\n        return await this.generateClaudeMd(analysis, approach);\n        \n      case 'Agent-OS.md':\n        return await this.generateAgentOS(analysis, approach);\n        \n      case '.cursorrules':\n      case '.clinerules':\n        return await this.generateRules(analysis, basename);\n        \n      default:\n        return await this.documentCustomizer.generateDocument(basename, analysis);\n    }\n  }\n  \n  /**\n   * Scan for existing documents\n   */\n  async scanForExistingDocuments() {\n    const documentsToCheck = [\n      'CLAUDE.md',\n      'Agent-OS.md',\n      '.cursorrules',\n      '.clinerules',\n      'README.md',\n      'IMPROVEMENTS-v3.0.md'\n    ];\n    \n    const existing = [];\n    \n    for (const doc of documentsToCheck) {\n      try {\n        await fs.access(doc);\n        existing.push(doc);\n      } catch {\n        // Document doesn't exist\n      }\n    }\n    \n    return existing;\n  }\n  \n  /**\n   * Read document from disk\n   */\n  async readDocument(docPath) {\n    try {\n      return await fs.readFile(docPath, 'utf8');\n    } catch {\n      return '';\n    }\n  }\n  \n  /**\n   * Write document to disk\n   */\n  async writeDocument(docPath, content) {\n    await fs.writeFile(docPath, content, 'utf8');\n  }\n  \n  /**\n   * Create diff between two strings\n   */\n  createDiff(oldContent, newContent) {\n    return diff.createPatch('document', oldContent, newContent);\n  }\n  \n  /**\n   * Apply selected changes to content\n   */\n  applySelectedChanges(originalContent, acceptedChanges) {\n    let result = '';\n    \n    for (const change of acceptedChanges) {\n      if (!change.removed) {\n        result += change.value;\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get user choice from options\n   */\n  async getUserChoice(options) {\n    if (!this.rl) {\n      this.rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n      });\n    }\n    \n    return new Promise(resolve => {\n      this.rl.question(`Choose option (${options.join('/')}): `, answer => {\n        if (options.includes(answer)) {\n          resolve(answer);\n        } else {\n          console.log(chalk.red('Invalid option. Please try again.'));\n          resolve(this.getUserChoice(options));\n        }\n      });\n    });\n  }\n  \n  /**\n   * Ask yes/no question\n   */\n  async askYesNo(question) {\n    const answer = await this.getUserChoice(['y', 'n']);\n    return answer === 'y';\n  }\n  \n  /**\n   * Generate update report\n   */\n  async generateUpdateReport(results) {\n    const report = {\n      timestamp: new Date().toISOString(),\n      summary: {\n        updated: results.updated.length,\n        skipped: results.skipped.length,\n        preserved: results.preserved.length,\n        errors: results.errors.length\n      },\n      details: results\n    };\n    \n    // Display summary\n    console.log(chalk.cyan('\\n📊 Update Summary:'));\n    console.log(chalk.green(`  ✅ Updated: ${report.summary.updated} documents`));\n    console.log(chalk.yellow(`  ⏭️  Skipped: ${report.summary.skipped} documents`));\n    console.log(chalk.magenta(`  ✨ Preserved: ${report.summary.preserved} customizations`));\n    \n    if (report.summary.errors > 0) {\n      console.log(chalk.red(`  ❌ Errors: ${report.summary.errors}`));\n    }\n    \n    return report;\n  }\n  \n  /**\n   * Store generation request in shared memory\n   */\n  async storeGenerationRequest(generationId, analysis, approach, options) {\n    await this.sharedMemory.set(\n      `doc-gen:${generationId}:request`,\n      {\n        generationId,\n        analysis,\n        approach,\n        options,\n        timestamp: Date.now()\n      },\n      {\n        namespace: this.sharedMemory.namespaces.CROSS_AGENT,\n        dataType: this.sharedMemory.dataTypes.SHARED\n      }\n    );\n  }\n  \n  /**\n   * Store update results in shared memory\n   */\n  async storeUpdateResults(results) {\n    await this.sharedMemory.set(\n      `doc-gen:results:${Date.now()}`,\n      results,\n      {\n        namespace: this.sharedMemory.namespaces.TASK_RESULTS,\n        dataType: this.sharedMemory.dataTypes.PERSISTENT\n      }\n    );\n  }\n  \n  /**\n   * Generate CLAUDE.md content\n   */\n  async generateClaudeMd(analysis, approach) {\n    // This will be implemented by claude-md-generator.js\n    // For now, return a placeholder\n    return `# Claude Configuration\\n\\nGenerated by Document Generator v2\\n`;\n  }\n  \n  /**\n   * Generate Agent-OS.md content\n   */\n  async generateAgentOS(analysis, approach) {\n    return this.documentCustomizer.generateAgentOS();\n  }\n  \n  /**\n   * Generate rules files\n   */\n  async generateRules(analysis, filename) {\n    return this.documentCustomizer.generateRules(filename);\n  }\n  \n  // Event handlers\n  handleGenerationRequest(data) {\n    const { analysis, approach, options } = data;\n    this.generateDocumentsInteractive(analysis, approach, options);\n  }\n  \n  handleUpdateRequest(data) {\n    const { documents, options } = data;\n    this.interactiveUpdateMode(documents, null, null, options);\n  }\n  \n  handleCustomizationDetected(data) {\n    const { docPath, customizations } = data;\n    this.customizations.set(docPath, customizations);\n  }\n}\n\n// Export for use in other modules\nmodule.exports = DocumentGeneratorV2;\n\n// CLI interface if run directly\nif (require.main === module) {\n  const generator = new DocumentGeneratorV2();\n  \n  // Example usage\n  const analysis = {\n    complexity: { score: 45 },\n    patterns: {},\n    architecture: { type: 'modular' }\n  };\n  \n  const approach = 'hive-mind';\n  \n  generator.generateDocumentsInteractive(analysis, approach)\n    .then(report => {\n      console.log('Document generation complete:', report);\n      process.exit(0);\n    })\n    .catch(error => {\n      console.error('Document generation failed:', error);\n      process.exit(1);\n    });\n}",
          "size": 19439,
          "lastModified": "2025-08-13T16:16:43.951Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": true,
          "agentOSVersion": ".",
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "DocumentGeneratorV2",
                "position": 1310
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/memory-integration-example.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/memory-integration-example.js",
          "fileName": "memory-integration-example.js",
          "extension": "js",
          "type": "javascript",
          "content": "/**\n * SharedMemoryStore Integration Example\n * \n * This example demonstrates how the SharedMemoryStore integrates with the\n * existing Hive-Mind architecture, particularly with the Queen Controller\n * to provide seamless cross-agent data sharing and context preservation.\n * \n * @author Claude Code\n * @date August 2025\n * @version 2.1.0\n */\n\nconst SharedMemoryStore = require('./shared-memory');\nconst QueenController = require('./queen-controller');\nconst EventEmitter = require('events');\n\nclass HiveMindIntegration extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    this.projectRoot = options.projectRoot || process.cwd();\n    this.maxConcurrentAgents = options.maxConcurrentAgents || 10;\n    \n    // Initialize shared memory store\n    this.memory = new SharedMemoryStore({\n      projectRoot: this.projectRoot,\n      maxMemorySize: 500 * 1024 * 1024, // 500MB\n      maxEntries: 100000,\n      gcInterval: 300000 // 5 minutes\n    });\n    \n    // Initialize queen controller with memory integration\n    this.queen = new QueenController({\n      projectRoot: this.projectRoot,\n      maxConcurrent: this.maxConcurrentAgents,\n      sharedMemory: this.memory\n    });\n    \n    // Integration state\n    this.isInitialized = false;\n    this.agentContexts = new Map();\n    this.crossAgentChannels = new Map();\n    \n    // Initialize integration\n    this.initialize();\n  }\n  \n  /**\n   * Initialize the integration\n   */\n  async initialize() {\n    try {\n      console.log('🚀 Initializing Hive-Mind integration...');\n      \n      // Wait for memory store to initialize\n      await new Promise((resolve) => {\n        this.memory.once('initialized', resolve);\n      });\n      \n      // Set up event handlers\n      this.setupEventHandlers();\n      \n      // Initialize cross-agent communication channels\n      await this.initializeCommunicationChannels();\n      \n      // Load persistent agent contexts\n      await this.loadAgentContexts();\n      \n      this.isInitialized = true;\n      \n      console.log('✅ Hive-Mind integration initialized successfully');\n      this.emit('integration-ready');\n      \n    } catch (error) {\n      console.error('❌ Failed to initialize Hive-Mind integration:', error);\n      this.emit('integration-error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Set up event handlers for integration\n   */\n  setupEventHandlers() {\n    // Memory store events\n    this.memory.on('memory-set', (event) => {\n      this.handleMemoryUpdate(event);\n    });\n    \n    this.memory.on('memory-delete', (event) => {\n      this.handleMemoryDeletion(event);\n    });\n    \n    // Queen controller events\n    this.queen.on('agent-spawned', (event) => {\n      this.handleAgentSpawned(event);\n    });\n    \n    this.queen.on('agent-completed', (event) => {\n      this.handleAgentCompleted(event);\n    });\n    \n    this.queen.on('agent-error', (event) => {\n      this.handleAgentError(event);\n    });\n  }\n  \n  /**\n   * Initialize communication channels between agents\n   */\n  async initializeCommunicationChannels() {\n    const channels = [\n      'task-coordination',\n      'result-sharing',\n      'error-reporting',\n      'status-updates',\n      'context-sync'\n    ];\n    \n    for (const channel of channels) {\n      await this.memory.set(`channel:${channel}`, {\n        type: 'communication-channel',\n        participants: [],\n        messages: [],\n        created: Date.now()\n      }, {\n        namespace: this.memory.namespaces.CROSS_AGENT,\n        dataType: this.memory.dataTypes.PERSISTENT\n      });\n      \n      this.crossAgentChannels.set(channel, {\n        subscribers: new Set(),\n        messageHistory: []\n      });\n    }\n    \n    console.log(`📡 Initialized ${channels.length} communication channels`);\n  }\n  \n  /**\n   * Load persistent agent contexts from previous sessions\n   */\n  async loadAgentContexts() {\n    try {\n      const contextKeys = await this.memory.keys({\n        namespace: this.memory.namespaces.AGENT_CONTEXT,\n        pattern: 'agent-context-.*'\n      });\n      \n      let loadedContexts = 0;\n      \n      for (const key of contextKeys) {\n        const context = await this.memory.get(key, { includeMetadata: true });\n        \n        if (context && context.found) {\n          const agentId = context.metadata.agentId;\n          this.agentContexts.set(agentId, {\n            ...context.value,\n            lastLoaded: Date.now(),\n            persistent: true\n          });\n          loadedContexts++;\n        }\n      }\n      \n      console.log(`📂 Loaded ${loadedContexts} persistent agent contexts`);\n      \n    } catch (error) {\n      console.warn('⚠️ Failed to load some agent contexts:', error.message);\n    }\n  }\n  \n  /**\n   * Spawn an agent with enhanced memory integration\n   */\n  async spawnAgent(agentType, task, options = {}) {\n    try {\n      // Prepare enhanced context with memory access\n      const enhancedContext = {\n        ...options.context,\n        memoryStore: this.memory,\n        communicationChannels: Array.from(this.crossAgentChannels.keys()),\n        sharedNamespaces: this.memory.namespaces,\n        agentId: options.agentId || `${agentType}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      };\n      \n      // Load previous context if exists\n      const persistentContext = this.agentContexts.get(enhancedContext.agentId);\n      if (persistentContext) {\n        enhancedContext.previousSession = persistentContext;\n        console.log(`🔄 Restored context for agent ${enhancedContext.agentId}`);\n      }\n      \n      // Spawn agent through queen controller\n      const agentId = await this.queen.spawnSubAgent(agentType, task, enhancedContext);\n      \n      if (agentId) {\n        // Initialize agent memory space\n        await this.initializeAgentMemorySpace(agentId, agentType, task);\n        \n        // Subscribe agent to relevant communication channels\n        await this.subscribeAgentToChannels(agentId, agentType);\n        \n        console.log(`🤖 Spawned agent ${agentId} with memory integration`);\n      }\n      \n      return agentId;\n      \n    } catch (error) {\n      console.error('❌ Failed to spawn agent with memory integration:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Initialize memory space for a new agent\n   */\n  async initializeAgentMemorySpace(agentId, agentType, task) {\n    const contextKey = `agent-context-${agentId}`;\n    const resultsKey = `agent-results-${agentId}`;\n    \n    // Initialize agent context\n    await this.memory.set(contextKey, {\n      agentId,\n      agentType,\n      task,\n      status: 'initializing',\n      startTime: Date.now(),\n      tokenUsage: 0,\n      memoryUsage: 0,\n      contextWindow: [],\n      intermediateResults: [],\n      communicationLog: []\n    }, {\n      namespace: this.memory.namespaces.AGENT_CONTEXT,\n      dataType: this.memory.dataTypes.PERSISTENT,\n      agentId\n    });\n    \n    // Initialize results storage\n    await this.memory.set(resultsKey, {\n      agentId,\n      taskId: task.id,\n      results: [],\n      status: 'pending',\n      created: Date.now()\n    }, {\n      namespace: this.memory.namespaces.TASK_RESULTS,\n      dataType: this.memory.dataTypes.PERSISTENT,\n      agentId\n    });\n    \n    // Store in local tracking\n    this.agentContexts.set(agentId, {\n      agentType,\n      task,\n      memoryKeys: [contextKey, resultsKey],\n      channels: [],\n      status: 'active'\n    });\n  }\n  \n  /**\n   * Subscribe agent to relevant communication channels\n   */\n  async subscribeAgentToChannels(agentId, agentType) {\n    // Determine relevant channels based on agent type\n    const channelMap = {\n      'code-analyzer': ['task-coordination', 'result-sharing'],\n      'test-runner': ['task-coordination', 'result-sharing', 'error-reporting'],\n      'doc-generator': ['result-sharing', 'status-updates'],\n      'api-builder': ['task-coordination', 'result-sharing', 'error-reporting'],\n      'database-architect': ['task-coordination', 'result-sharing'],\n      'security-scanner': ['result-sharing', 'error-reporting'],\n      'performance-optimizer': ['result-sharing', 'status-updates'],\n      'deployment-engineer': ['task-coordination', 'status-updates', 'error-reporting'],\n      'frontend-specialist': ['task-coordination', 'result-sharing'],\n      'recovery-specialist': ['error-reporting', 'status-updates']\n    };\n    \n    const relevantChannels = channelMap[agentType] || ['task-coordination'];\n    \n    for (const channel of relevantChannels) {\n      const channelData = this.crossAgentChannels.get(channel);\n      if (channelData) {\n        channelData.subscribers.add(agentId);\n        \n        // Update persistent channel data\n        await this.memory.atomic(`channel:${channel}`, (currentData) => {\n          if (currentData && currentData.participants) {\n            currentData.participants.push(agentId);\n            currentData.lastUpdated = Date.now();\n          }\n          return currentData;\n        });\n      }\n    }\n    \n    // Update agent context\n    const agentContext = this.agentContexts.get(agentId);\n    if (agentContext) {\n      agentContext.channels = relevantChannels;\n    }\n    \n    console.log(`📡 Subscribed agent ${agentId} to channels: ${relevantChannels.join(', ')}`);\n  }\n  \n  /**\n   * Share data between agents\n   */\n  async shareDataBetweenAgents(fromAgentId, toAgentId, data, options = {}) {\n    const shareKey = `shared-data-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    \n    await this.memory.set(shareKey, {\n      fromAgent: fromAgentId,\n      toAgent: toAgentId,\n      data,\n      timestamp: Date.now(),\n      type: options.type || 'data-share',\n      priority: options.priority || 'normal'\n    }, {\n      namespace: this.memory.namespaces.CROSS_AGENT,\n      dataType: this.memory.dataTypes.PERSISTENT,\n      ttl: options.ttl || (24 * 60 * 60 * 1000), // 24 hours default\n      agentId: fromAgentId,\n      metadata: {\n        sharedWith: toAgentId,\n        shareType: options.type\n      }\n    });\n    \n    // Notify target agent\n    await this.sendChannelMessage('result-sharing', {\n      type: 'data-share-notification',\n      fromAgent: fromAgentId,\n      toAgent: toAgentId,\n      shareKey,\n      data: options.includeData ? data : null\n    });\n    \n    console.log(`🔄 Shared data from ${fromAgentId} to ${toAgentId} (key: ${shareKey})`);\n    return shareKey;\n  }\n  \n  /**\n   * Send message to communication channel\n   */\n  async sendChannelMessage(channelName, message) {\n    const channel = this.crossAgentChannels.get(channelName);\n    if (!channel) {\n      throw new Error(`Unknown communication channel: ${channelName}`);\n    }\n    \n    const messageEnvelope = {\n      id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      channel: channelName,\n      message,\n      timestamp: Date.now(),\n      subscribers: Array.from(channel.subscribers)\n    };\n    \n    // Store in channel history\n    channel.messageHistory.push(messageEnvelope);\n    \n    // Update persistent channel data\n    await this.memory.atomic(`channel:${channelName}`, (currentData) => {\n      if (currentData && currentData.messages) {\n        currentData.messages.push(messageEnvelope);\n        currentData.lastMessage = Date.now();\n        \n        // Keep only last 100 messages\n        if (currentData.messages.length > 100) {\n          currentData.messages = currentData.messages.slice(-100);\n        }\n      }\n      return currentData;\n    });\n    \n    // Notify subscribers\n    for (const subscriberId of channel.subscribers) {\n      await this.notifyAgent(subscriberId, 'channel-message', messageEnvelope);\n    }\n    \n    return messageEnvelope.id;\n  }\n  \n  /**\n   * Notify an agent of an event\n   */\n  async notifyAgent(agentId, eventType, data) {\n    const notificationKey = `notification-${agentId}-${Date.now()}`;\n    \n    await this.memory.set(notificationKey, {\n      agentId,\n      eventType,\n      data,\n      timestamp: Date.now(),\n      status: 'pending'\n    }, {\n      namespace: this.memory.namespaces.TEMP,\n      dataType: this.memory.dataTypes.TRANSIENT,\n      ttl: 60000, // 1 minute\n      agentId: 'system'\n    });\n  }\n  \n  /**\n   * Update agent context\n   */\n  async updateAgentContext(agentId, updates) {\n    const contextKey = `agent-context-${agentId}`;\n    \n    await this.memory.atomic(contextKey, (currentContext) => {\n      if (currentContext) {\n        return {\n          ...currentContext,\n          ...updates,\n          lastUpdated: Date.now()\n        };\n      }\n      return currentContext;\n    }, { agentId });\n    \n    // Update local tracking\n    const localContext = this.agentContexts.get(agentId);\n    if (localContext) {\n      Object.assign(localContext, updates);\n    }\n  }\n  \n  /**\n   * Get aggregated results from all agents\n   */\n  async getAggregatedResults() {\n    const resultKeys = await this.memory.keys({\n      namespace: this.memory.namespaces.TASK_RESULTS,\n      pattern: 'agent-results-.*'\n    });\n    \n    const results = [];\n    \n    for (const key of resultKeys) {\n      const result = await this.memory.get(key, { includeMetadata: true });\n      if (result && result.found) {\n        results.push({\n          key,\n          agentId: result.metadata.agentId,\n          data: result.value,\n          metadata: result.metadata\n        });\n      }\n    }\n    \n    return {\n      totalResults: results.length,\n      results,\n      aggregatedAt: Date.now(),\n      memoryStats: this.memory.getStats()\n    };\n  }\n  \n  /**\n   * Handle memory update events\n   */\n  handleMemoryUpdate(event) {\n    console.log(`📝 Memory updated: ${event.key} by ${event.agentId}`);\n    \n    // Broadcast to interested agents if it's cross-agent data\n    if (event.namespace === this.memory.namespaces.CROSS_AGENT) {\n      this.broadcastCrossAgentUpdate(event);\n    }\n  }\n  \n  /**\n   * Handle memory deletion events\n   */\n  handleMemoryDeletion(event) {\n    console.log(`🗑️ Memory deleted: ${event.key} by ${event.agentId}`);\n  }\n  \n  /**\n   * Handle agent spawned events\n   */\n  async handleAgentSpawned(event) {\n    console.log(`🤖 Agent spawned: ${event.agentId} (${event.type})`);\n    \n    // Update agent status in memory\n    await this.updateAgentContext(event.agentId, {\n      status: 'active',\n      spawnedAt: event.timestamp\n    });\n  }\n  \n  /**\n   * Handle agent completed events\n   */\n  async handleAgentCompleted(event) {\n    console.log(`✅ Agent completed: ${event.agentId} (${event.type})`);\n    \n    // Update agent status and preserve results\n    await this.updateAgentContext(event.agentId, {\n      status: 'completed',\n      completedAt: Date.now(),\n      finalResults: event.results,\n      performance: {\n        runtime: event.runtime,\n        tokenUsage: event.tokenUsage\n      }\n    });\n    \n    // Clean up transient data but preserve important results\n    await this.cleanupAgentMemory(event.agentId, false);\n  }\n  \n  /**\n   * Handle agent error events\n   */\n  async handleAgentError(event) {\n    console.error(`❌ Agent error: ${event.agentId} (${event.type}) - ${event.error}`);\n    \n    // Update agent status with error information\n    await this.updateAgentContext(event.agentId, {\n      status: 'error',\n      error: event.error,\n      errorAt: Date.now()\n    });\n    \n    // Broadcast error to error reporting channel\n    await this.sendChannelMessage('error-reporting', {\n      type: 'agent-error',\n      agentId: event.agentId,\n      agentType: event.type,\n      error: event.error,\n      task: event.task\n    });\n  }\n  \n  /**\n   * Broadcast cross-agent update\n   */\n  async broadcastCrossAgentUpdate(event) {\n    await this.sendChannelMessage('context-sync', {\n      type: 'memory-update',\n      key: event.key,\n      namespace: event.namespace,\n      updatedBy: event.agentId,\n      timestamp: Date.now()\n    });\n  }\n  \n  /**\n   * Clean up agent memory\n   */\n  async cleanupAgentMemory(agentId, fullCleanup = false) {\n    const agentContext = this.agentContexts.get(agentId);\n    \n    if (agentContext) {\n      // Remove from communication channels\n      for (const channelName of agentContext.channels) {\n        const channel = this.crossAgentChannels.get(channelName);\n        if (channel) {\n          channel.subscribers.delete(agentId);\n        }\n      }\n      \n      if (fullCleanup) {\n        // Delete all agent memory\n        for (const memoryKey of agentContext.memoryKeys) {\n          await this.memory.delete(memoryKey, { agentId });\n        }\n        \n        this.agentContexts.delete(agentId);\n      } else {\n        // Mark as inactive but preserve context\n        agentContext.status = 'inactive';\n        agentContext.cleanedAt = Date.now();\n      }\n    }\n  }\n  \n  /**\n   * Get system status\n   */\n  getSystemStatus() {\n    return {\n      integration: {\n        initialized: this.isInitialized,\n        activeAgents: this.agentContexts.size,\n        communicationChannels: this.crossAgentChannels.size\n      },\n      memory: this.memory.getStats(),\n      queen: this.queen.getStatus(),\n      channels: Object.fromEntries(\n        Array.from(this.crossAgentChannels.entries()).map(([name, channel]) => [\n          name,\n          {\n            subscribers: channel.subscribers.size,\n            messageCount: channel.messageHistory.length\n          }\n        ])\n      )\n    };\n  }\n  \n  /**\n   * Shutdown the integration\n   */\n  async shutdown() {\n    console.log('🔄 Shutting down Hive-Mind integration...');\n    \n    try {\n      // Clean up all agents\n      for (const agentId of this.agentContexts.keys()) {\n        await this.cleanupAgentMemory(agentId, false); // Preserve contexts\n      }\n      \n      // Shutdown queen controller\n      await this.queen.shutdown();\n      \n      // Shutdown memory store\n      await this.memory.shutdown();\n      \n      console.log('✅ Hive-Mind integration shutdown complete');\n      this.emit('integration-shutdown');\n      \n    } catch (error) {\n      console.error('❌ Error during shutdown:', error);\n      throw error;\n    }\n  }\n}\n\nmodule.exports = HiveMindIntegration;\n\n// Example usage\nif (require.main === module) {\n  async function demonstrateIntegration() {\n    console.log('🚀 Starting Hive-Mind Integration Demonstration\\n');\n    \n    const integration = new HiveMindIntegration({\n      projectRoot: process.cwd(),\n      maxConcurrentAgents: 5\n    });\n    \n    // Wait for initialization\n    await new Promise((resolve) => {\n      integration.once('integration-ready', resolve);\n    });\n    \n    console.log('✅ Integration ready, demonstrating features...\\n');\n    \n    try {\n      // Spawn multiple agents\n      const analyzer = await integration.spawnAgent('code-analyzer', {\n        id: 'analyze-codebase',\n        description: 'Analyze the entire codebase for patterns'\n      });\n      \n      const tester = await integration.spawnAgent('test-runner', {\n        id: 'run-tests',\n        description: 'Execute all test suites'\n      });\n      \n      console.log(`🤖 Spawned agents: ${analyzer}, ${tester}\\n`);\n      \n      // Demonstrate cross-agent data sharing\n      await integration.shareDataBetweenAgents(analyzer, tester, {\n        analysisResults: {\n          complexity: 'medium',\n          testCoverage: 0.75,\n          issues: ['missing-tests-in-module-x']\n        }\n      }, { type: 'analysis-results' });\n      \n      // Send channel messages\n      await integration.sendChannelMessage('task-coordination', {\n        type: 'coordination-request',\n        from: analyzer,\n        message: 'Analysis complete, ready for testing phase'\n      });\n      \n      // Get system status\n      const status = integration.getSystemStatus();\n      console.log('📊 System Status:', JSON.stringify(status, null, 2));\n      \n      // Get aggregated results\n      const results = await integration.getAggregatedResults();\n      console.log(`📋 Aggregated Results: ${results.totalResults} result sets\\n`);\n      \n      console.log('✅ Demonstration complete!');\n      \n    } catch (error) {\n      console.error('❌ Demonstration failed:', error);\n    } finally {\n      // Shutdown\n      await integration.shutdown();\n    }\n  }\n  \n  demonstrateIntegration().catch(console.error);\n}",
          "size": 20043,
          "lastModified": "2025-08-13T02:13:54.645Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "demonstrateIntegration",
                "position": 17988
              }
            ],
            "classes": [
              {
                "name": "HiveMindIntegration",
                "position": 494
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/integration-checker.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/integration-checker.js",
          "fileName": "integration-checker.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\r\n\r\n/**\r\n * Integration Checker\r\n * Verifies all workflow components are properly integrated\r\n * Container-aware with fallback mechanisms\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { execSync } = require('child_process');\r\n\r\nclass IntegrationChecker {\r\n  constructor(projectPath = process.cwd()) {\r\n    this.projectPath = projectPath;\r\n    this.isContainer = this.detectContainer();\r\n    this.results = {\r\n      core: {},\r\n      integrations: {},\r\n      connectivity: {},\r\n      health: {},\r\n      recommendations: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Run complete integration check\r\n   */\r\n  async checkAll() {\r\n    console.log('🔍 Running Integration Checks...\\n');\r\n    \r\n    // Check core components\r\n    await this.checkCoreComponents();\r\n    \r\n    // Check external integrations\r\n    await this.checkExternalIntegrations();\r\n    \r\n    // Check connectivity\r\n    await this.checkConnectivity();\r\n    \r\n    // Generate health report\r\n    this.generateHealthReport();\r\n    \r\n    return this.results;\r\n  }\r\n\r\n  /**\r\n   * Check core workflow components\r\n   */\r\n  async checkCoreComponents() {\r\n    console.log('📦 Checking Core Components...');\r\n    \r\n    // Check workflow runner\r\n    this.results.core.workflowRunner = fs.existsSync(\r\n      path.join(this.projectPath, 'workflow-runner.js')\r\n    ) || fs.existsSync(\r\n      path.join(this.projectPath, '.ai-workflow', 'workflow-runner.js')\r\n    );\r\n    \r\n    // Check intelligence engine\r\n    this.results.core.intelligenceEngine = fs.existsSync(\r\n      path.join(this.projectPath, 'intelligence-engine')\r\n    );\r\n    \r\n    // Check complexity analyzer\r\n    this.results.core.complexityAnalyzer = fs.existsSync(\r\n      path.join(this.projectPath, 'intelligence-engine', 'complexity-analyzer.js')\r\n    );\r\n    \r\n    // Check document customizer\r\n    this.results.core.documentCustomizer = fs.existsSync(\r\n      path.join(this.projectPath, 'intelligence-engine', 'document-customizer.js')\r\n    );\r\n    \r\n    // Check engine API\r\n    this.results.core.engineAPI = await this.checkEngineAPI();\r\n    \r\n    console.log(`  ✓ Core components: ${Object.values(this.results.core).filter(Boolean).length}/${Object.keys(this.results.core).length}`);\r\n  }\r\n\r\n  /**\r\n   * Check external tool integrations\r\n   */\r\n  async checkExternalIntegrations() {\r\n    console.log('🔗 Checking External Integrations...');\r\n    \r\n    // Check Claude Code\r\n    this.results.integrations.claudeCode = await this.checkClaudeCode();\r\n    \r\n    // Check Agent-OS\r\n    this.results.integrations.agentOS = await this.checkAgentOS();\r\n    \r\n    // Check Claude Flow\r\n    this.results.integrations.claudeFlow = await this.checkClaudeFlow();\r\n    \r\n    // Check TMux Orchestrator\r\n    this.results.integrations.tmux = await this.checkTMux();\r\n    \r\n    // Check MCP servers\r\n    this.results.integrations.mcp = await this.checkMCPServers();\r\n    \r\n    console.log(`  ✓ Integrations: ${Object.values(this.results.integrations).filter(Boolean).length}/${Object.keys(this.results.integrations).length}`);\r\n  }\r\n\r\n  /**\r\n   * Check connectivity between components\r\n   */\r\n  async checkConnectivity() {\r\n    console.log('🌐 Checking Connectivity...');\r\n    \r\n    // Check API connectivity\r\n    this.results.connectivity.api = await this.checkAPIConnectivity();\r\n    \r\n    // Check port availability\r\n    this.results.connectivity.ports = await this.checkPorts();\r\n    \r\n    // Check file permissions\r\n    this.results.connectivity.permissions = await this.checkPermissions();\r\n    \r\n    // Check container-host bridge if in container\r\n    if (this.isContainer) {\r\n      this.results.connectivity.containerBridge = await this.checkContainerBridge();\r\n    }\r\n    \r\n    console.log(`  ✓ Connectivity: ${Object.values(this.results.connectivity).filter(Boolean).length}/${Object.keys(this.results.connectivity).length}`);\r\n  }\r\n\r\n  /**\r\n   * Check if Claude Code is available\r\n   */\r\n  async checkClaudeCode() {\r\n    // Check for Claude settings\r\n    const hasSettings = fs.existsSync(path.join(this.projectPath, '.claude', 'settings.json'));\r\n    \r\n    // Check for agents\r\n    const hasAgents = fs.existsSync(path.join(this.projectPath, '.claude', 'agents'));\r\n    \r\n    // Check for CLAUDE.md\r\n    const hasClaudeMd = fs.existsSync(path.join(this.projectPath, '.claude', 'CLAUDE.md')) ||\r\n                        fs.existsSync(path.join(this.projectPath, 'CLAUDE.md'));\r\n    \r\n    // Try to detect Claude command availability\r\n    let hasCommand = false;\r\n    try {\r\n      if (this.isContainer) {\r\n        // In container, check if host has Claude\r\n        hasCommand = process.env.CLAUDE_AVAILABLE === 'true';\r\n      } else {\r\n        execSync('which claude', { stdio: 'pipe' });\r\n        hasCommand = true;\r\n      }\r\n    } catch (e) {\r\n      // Claude command not found\r\n    }\r\n    \r\n    const isAvailable = hasSettings || hasAgents || hasClaudeMd || hasCommand;\r\n    \r\n    if (!isAvailable && !this.isContainer) {\r\n      this.results.recommendations.push('Install Claude Code for enhanced AI assistance');\r\n    }\r\n    \r\n    return isAvailable;\r\n  }\r\n\r\n  /**\r\n   * Check if Agent-OS is available\r\n   */\r\n  async checkAgentOS() {\r\n    const hasConfig = fs.existsSync(path.join(this.projectPath, '.agent-os', 'agentOS-config.json'));\r\n    const hasInstructions = fs.existsSync(path.join(this.projectPath, '.agent-os', 'instructions'));\r\n    \r\n    const isAvailable = hasConfig || hasInstructions;\r\n    \r\n    if (!isAvailable) {\r\n      this.results.recommendations.push('Configure Agent-OS for enhanced orchestration');\r\n    }\r\n    \r\n    return isAvailable;\r\n  }\r\n\r\n  /**\r\n   * Check if Claude Flow is available\r\n   */\r\n  async checkClaudeFlow() {\r\n    const hasConfig = fs.existsSync(path.join(this.projectPath, '.claude-flow'));\r\n    const hasHiveMind = fs.existsSync(path.join(this.projectPath, '.hive-mind'));\r\n    \r\n    // Check if npx claude-flow works\r\n    let hasCommand = false;\r\n    try {\r\n      execSync('npx claude-flow@alpha --version', { stdio: 'pipe', timeout: 5000 });\r\n      hasCommand = true;\r\n    } catch (e) {\r\n      // Command not available\r\n    }\r\n    \r\n    const isAvailable = hasConfig || hasHiveMind || hasCommand;\r\n    \r\n    if (!isAvailable) {\r\n      this.results.recommendations.push('Claude Flow 2.0 not detected - workflow orchestration limited');\r\n    }\r\n    \r\n    return isAvailable;\r\n  }\r\n\r\n  /**\r\n   * Check if TMux is available\r\n   */\r\n  async checkTMux() {\r\n    const hasConfig = fs.existsSync(path.join(this.projectPath, '.tmux-orchestrator'));\r\n    \r\n    // Check tmux command\r\n    let hasCommand = false;\r\n    try {\r\n      execSync('which tmux', { stdio: 'pipe' });\r\n      hasCommand = true;\r\n    } catch (e) {\r\n      // TMux not installed\r\n    }\r\n    \r\n    return hasConfig || hasCommand;\r\n  }\r\n\r\n  /**\r\n   * Check MCP server availability\r\n   */\r\n  async checkMCPServers() {\r\n    const mcpRegistry = path.join(this.projectPath, '.ai-workflow', 'configs', 'mcp-registry.json');\r\n    \r\n    if (fs.existsSync(mcpRegistry)) {\r\n      try {\r\n        const registry = JSON.parse(fs.readFileSync(mcpRegistry, 'utf8'));\r\n        return registry.servers && Object.keys(registry.servers).length > 0;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check Engine API health\r\n   */\r\n  async checkEngineAPI() {\r\n    const port = process.env.MW_ENGINE_PORT || 13800;\r\n    \r\n    try {\r\n      // Simple check if port is in use\r\n      execSync(`lsof -i:${port}`, { stdio: 'pipe' });\r\n      return true;\r\n    } catch (e) {\r\n      // Port not in use, API likely not running\r\n      this.results.recommendations.push(`Start Engine API: cd engine && npm start (port ${port})`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check API connectivity\r\n   */\r\n  async checkAPIConnectivity() {\r\n    const port = process.env.MW_ENGINE_PORT || 13800;\r\n    \r\n    try {\r\n      const response = await fetch(`http://localhost:${port}/health`);\r\n      return response.ok;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check port availability\r\n   */\r\n  async checkPorts() {\r\n    const ports = {\r\n      engine: 13800,\r\n      dashboard: 8787\r\n    };\r\n    \r\n    let allAvailable = true;\r\n    \r\n    for (const [service, port] of Object.entries(ports)) {\r\n      try {\r\n        execSync(`lsof -i:${port}`, { stdio: 'pipe' });\r\n        // Port is in use (good if it's our service)\r\n      } catch (e) {\r\n        // Port is free\r\n        if (service === 'engine') {\r\n          allAvailable = false;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return allAvailable;\r\n  }\r\n\r\n  /**\r\n   * Check file permissions\r\n   */\r\n  async checkPermissions() {\r\n    const criticalPaths = [\r\n      'workflow-runner.js',\r\n      'ai-workflow',\r\n      'intelligence-engine/complexity-analyzer.js'\r\n    ];\r\n    \r\n    for (const file of criticalPaths) {\r\n      const fullPath = path.join(this.projectPath, file);\r\n      if (fs.existsSync(fullPath)) {\r\n        try {\r\n          fs.accessSync(fullPath, fs.constants.R_OK | fs.constants.X_OK);\r\n        } catch (e) {\r\n          this.results.recommendations.push(`Fix permissions for ${file}: chmod +x ${file}`);\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check container-host bridge\r\n   */\r\n  async checkContainerBridge() {\r\n    // Check if we can communicate with host\r\n    const canReachHost = process.env.HOST_AVAILABLE === 'true';\r\n    \r\n    if (!canReachHost) {\r\n      this.results.recommendations.push('Configure host-container bridge for full integration');\r\n    }\r\n    \r\n    return canReachHost;\r\n  }\r\n\r\n  /**\r\n   * Detect if running in container\r\n   */\r\n  detectContainer() {\r\n    return process.env.CONTAINER === 'true' ||\r\n           fs.existsSync('/.dockerenv') ||\r\n           fs.existsSync('/run/.containerenv') ||\r\n           process.env.REMOTE_CONTAINERS === 'true' ||\r\n           process.env.CODESPACES === 'true';\r\n  }\r\n\r\n  /**\r\n   * Generate health report\r\n   */\r\n  generateHealthReport() {\r\n    const coreHealth = Object.values(this.results.core).filter(Boolean).length / Object.keys(this.results.core).length;\r\n    const integrationHealth = Object.values(this.results.integrations).filter(Boolean).length / Object.keys(this.results.integrations).length;\r\n    const connectivityHealth = Object.values(this.results.connectivity).filter(Boolean).length / Object.keys(this.results.connectivity).length;\r\n    \r\n    this.results.health = {\r\n      overall: Math.round((coreHealth + integrationHealth + connectivityHealth) / 3 * 100),\r\n      core: Math.round(coreHealth * 100),\r\n      integrations: Math.round(integrationHealth * 100),\r\n      connectivity: Math.round(connectivityHealth * 100),\r\n      status: this.getHealthStatus((coreHealth + integrationHealth + connectivityHealth) / 3)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get health status description\r\n   */\r\n  getHealthStatus(score) {\r\n    if (score >= 0.9) return 'Excellent';\r\n    if (score >= 0.7) return 'Good';\r\n    if (score >= 0.5) return 'Fair';\r\n    if (score >= 0.3) return 'Poor';\r\n    return 'Critical';\r\n  }\r\n\r\n  /**\r\n   * Print report to console\r\n   */\r\n  printReport() {\r\n    console.log('\\n' + '='.repeat(50));\r\n    console.log('INTEGRATION HEALTH REPORT');\r\n    console.log('='.repeat(50));\r\n    \r\n    console.log(`\\n📊 Overall Health: ${this.results.health.overall}% (${this.results.health.status})`);\r\n    console.log(`  Core Systems: ${this.results.health.core}%`);\r\n    console.log(`  Integrations: ${this.results.health.integrations}%`);\r\n    console.log(`  Connectivity: ${this.results.health.connectivity}%`);\r\n    \r\n    if (this.isContainer) {\r\n      console.log('\\n🐳 Running in Container Environment');\r\n    }\r\n    \r\n    if (this.results.recommendations.length > 0) {\r\n      console.log('\\n💡 Recommendations:');\r\n      this.results.recommendations.forEach(rec => {\r\n        console.log(`  • ${rec}`);\r\n      });\r\n    }\r\n    \r\n    console.log('\\n' + '='.repeat(50));\r\n  }\r\n}\r\n\r\n// CLI execution\r\nif (require.main === module) {\r\n  const checker = new IntegrationChecker();\r\n  \r\n  checker.checkAll().then(results => {\r\n    checker.printReport();\r\n    \r\n    // Output JSON if requested\r\n    if (process.argv.includes('--json')) {\r\n      console.log('\\nJSON Output:');\r\n      console.log(JSON.stringify(results, null, 2));\r\n    }\r\n    \r\n    // Exit with error if health is poor\r\n    if (results.health.overall < 50) {\r\n      process.exit(1);\r\n    }\r\n  });\r\n}\r\n\r\nmodule.exports = IntegrationChecker;",
          "size": 12473,
          "lastModified": "2025-08-12T23:40:41.159Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": true,
          "agentOSVersion": "5000",
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "IntegrationChecker",
                "position": 273
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/queen-controller.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/queen-controller.js",
          "fileName": "queen-controller.js",
          "extension": "js",
          "type": "javascript",
          "content": "/**\n * Queen Controller - Hierarchical Sub-Agent Architecture\n * \n * This is the master controller for managing multiple sub-agents with independent \n * context windows. It orchestrates task distribution, monitors agent health,\n * and aggregates results from concurrent agent operations.\n * \n * Features:\n * - Manages up to 10 concurrent sub-agents\n * - Tracks 200k token context windows per agent\n * - Handles inter-agent communication\n * - Provides shared memory for cross-agent data\n * - Monitors resource usage and performance\n */\n\nconst EventEmitter = require('events');\nconst path = require('path');\nconst fs = require('fs').promises;\n\nclass QueenController extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Core configuration\n    this.maxConcurrent = options.maxConcurrent || 10;\n    this.contextWindowSize = options.contextWindowSize || 200000; // 200k tokens\n    this.projectRoot = options.projectRoot || process.cwd();\n    \n    // Agent management\n    this.subAgents = new Map();\n    this.activeAgents = new Set();\n    this.taskQueue = [];\n    this.pendingTasks = new Map();\n    this.completedTasks = new Map();\n    \n    // Enhanced shared memory with SharedMemoryStore integration\n    this.sharedMemoryStore = options.sharedMemory || null;\n    \n    // Legacy in-memory storage (for backward compatibility)\n    this.sharedMemory = new Map();\n    this.sharedMemory.set('global_context', {});\n    this.sharedMemory.set('agent_results', new Map());\n    this.sharedMemory.set('dependencies', new Map());\n    \n    // Performance tracking\n    this.metrics = {\n      agentsSpawned: 0,\n      tasksDistributed: 0,\n      tasksCompleted: 0,\n      averageCompletionTime: 0,\n      contextUsage: new Map(),\n      errors: []\n    };\n    \n    // Agent type registry\n    this.agentTypes = new Map([\n      ['code-analyzer', { template: 'code-analyzer-agent.md', capabilities: ['analysis', 'pattern-detection'] }],\n      ['test-runner', { template: 'test-runner-agent.md', capabilities: ['testing', 'validation'] }],\n      ['doc-generator', { template: 'doc-generator-agent.md', capabilities: ['documentation', 'markdown'] }],\n      ['api-builder', { template: 'api-builder-agent.md', capabilities: ['api', 'endpoints'] }],\n      ['database-architect', { template: 'database-architect-agent.md', capabilities: ['database', 'schema'] }],\n      ['security-scanner', { template: 'security-scanner-agent.md', capabilities: ['security', 'audit'] }],\n      ['performance-optimizer', { template: 'performance-optimizer-agent.md', capabilities: ['performance', 'optimization'] }],\n      ['deployment-engineer', { template: 'deployment-engineer-agent.md', capabilities: ['deployment', 'ci-cd'] }],\n      ['frontend-specialist', { template: 'frontend-specialist-agent.md', capabilities: ['frontend', 'ui'] }],\n      ['recovery-specialist', { template: 'recovery-specialist-agent.md', capabilities: ['recovery', 'fixes'] }]\n    ]);\n    \n    // Initialize monitoring\n    this.startMonitoring();\n  }\n  \n  /**\n   * Spawn a new sub-agent with specific type and context\n   * @param {string} type - Agent type from registry\n   * @param {object} task - Task to assign to agent\n   * @param {object} context - Initial context for agent\n   */\n  async spawnSubAgent(type, task, context = {}) {\n    // Check concurrent limit\n    if (this.activeAgents.size >= this.maxConcurrent) {\n      this.emit('queue-full', { \n        active: this.activeAgents.size, \n        max: this.maxConcurrent,\n        queued: this.taskQueue.length \n      });\n      \n      // Queue the task for later\n      this.taskQueue.push({ type, task, context });\n      return null;\n    }\n    \n    // Generate unique agent ID\n    const agentId = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Get agent configuration\n    const agentConfig = this.agentTypes.get(type);\n    if (!agentConfig) {\n      throw new Error(`Unknown agent type: ${type}`);\n    }\n    \n    // Create agent instance\n    const agent = {\n      id: agentId,\n      type: type,\n      task: task,\n      context: {\n        ...context,\n        sharedMemory: await this.getSharedContext(),\n        sharedMemoryStore: this.sharedMemoryStore,\n        projectRoot: this.projectRoot,\n        queenId: this.id,\n        maxTokens: this.contextWindowSize\n      },\n      status: 'initializing',\n      startTime: Date.now(),\n      tokenUsage: 0,\n      capabilities: agentConfig.capabilities,\n      template: agentConfig.template\n    };\n    \n    // Register agent\n    this.subAgents.set(agentId, agent);\n    this.activeAgents.add(agentId);\n    \n    // Update metrics\n    this.metrics.agentsSpawned++;\n    this.metrics.contextUsage.set(agentId, 0);\n    \n    // Emit spawn event\n    this.emit('agent-spawned', {\n      agentId,\n      type,\n      task: task.id || task.name,\n      timestamp: Date.now()\n    });\n    \n    // Initialize agent (simulate async spawn)\n    await this.initializeAgent(agent);\n    \n    return agentId;\n  }\n  \n  /**\n   * Initialize a spawned agent\n   */\n  async initializeAgent(agent) {\n    agent.status = 'active';\n    \n    // Load agent template if exists\n    const templatePath = path.join(this.projectRoot, '.claude/agents', agent.template);\n    try {\n      const templateContent = await fs.readFile(templatePath, 'utf-8');\n      agent.instructions = templateContent;\n    } catch (error) {\n      // Template doesn't exist yet, will be created in Phase 2\n      agent.instructions = this.generateDefaultInstructions(agent.type);\n    }\n    \n    this.emit('agent-ready', {\n      agentId: agent.id,\n      type: agent.type\n    });\n  }\n  \n  /**\n   * Distribute a task to appropriate agents with dependency management\n   * @param {object} task - Task to distribute\n   * @param {array} dependencies - Task dependencies\n   */\n  async distributeTask(task, dependencies = []) {\n    // Validate dependencies are complete\n    for (const dep of dependencies) {\n      if (!this.completedTasks.has(dep)) {\n        this.pendingTasks.set(task.id, { task, dependencies });\n        this.emit('task-pending', { \n          taskId: task.id, \n          waitingFor: dependencies.filter(d => !this.completedTasks.has(d))\n        });\n        return null;\n      }\n    }\n    \n    // Determine best agent type for task\n    const agentType = this.selectAgentType(task);\n    \n    // Gather dependency results as context\n    const dependencyContext = {};\n    for (const dep of dependencies) {\n      const result = this.completedTasks.get(dep);\n      if (result) {\n        dependencyContext[dep] = result;\n      }\n    }\n    \n    // Spawn agent for task\n    const agentId = await this.spawnSubAgent(agentType, task, {\n      dependencies: dependencyContext,\n      taskMetadata: {\n        priority: task.priority || 'normal',\n        estimatedTokens: task.estimatedTokens || 50000,\n        timeout: task.timeout || 300000 // 5 minutes default\n      }\n    });\n    \n    if (agentId) {\n      this.metrics.tasksDistributed++;\n      this.emit('task-distributed', {\n        taskId: task.id,\n        agentId,\n        agentType\n      });\n    }\n    \n    return agentId;\n  }\n  \n  /**\n   * Monitor active agents and handle lifecycle\n   */\n  async monitorAgents() {\n    const monitoring = [];\n    \n    for (const agentId of this.activeAgents) {\n      const agent = this.subAgents.get(agentId);\n      if (!agent) continue;\n      \n      // Check agent health\n      const health = await this.checkAgentHealth(agent);\n      \n      if (health.status === 'completed') {\n        await this.handleAgentCompletion(agent);\n      } else if (health.status === 'error') {\n        await this.handleAgentError(agent, health.error);\n      } else if (health.tokenUsage > this.contextWindowSize * 0.9) {\n        // Agent approaching context limit\n        this.emit('agent-context-warning', {\n          agentId,\n          usage: health.tokenUsage,\n          limit: this.contextWindowSize\n        });\n      }\n      \n      monitoring.push({\n        agentId,\n        type: agent.type,\n        status: health.status,\n        tokenUsage: health.tokenUsage,\n        runtime: Date.now() - agent.startTime\n      });\n    }\n    \n    return monitoring;\n  }\n  \n  /**\n   * Check health status of an agent\n   */\n  async checkAgentHealth(agent) {\n    // Simulate health check - in production would check actual process\n    const health = {\n      status: agent.status,\n      tokenUsage: agent.tokenUsage,\n      memory: process.memoryUsage().heapUsed,\n      runtime: Date.now() - agent.startTime\n    };\n    \n    // Update token usage tracking\n    this.metrics.contextUsage.set(agent.id, health.tokenUsage);\n    \n    return health;\n  }\n  \n  /**\n   * Aggregate results from multiple agents\n   * @param {array} agentIds - IDs of agents to aggregate from\n   */\n  async aggregateResults(agentIds = []) {\n    const results = new Map();\n    const targetAgents = agentIds.length > 0 ? agentIds : Array.from(this.activeAgents);\n    \n    for (const agentId of targetAgents) {\n      const agent = this.subAgents.get(agentId);\n      if (!agent) continue;\n      \n      // Get results from shared memory\n      const agentResults = this.sharedMemory.get('agent_results').get(agentId);\n      if (agentResults) {\n        results.set(agentId, {\n          type: agent.type,\n          task: agent.task,\n          results: agentResults,\n          metrics: {\n            tokenUsage: agent.tokenUsage,\n            runtime: Date.now() - agent.startTime,\n            status: agent.status\n          }\n        });\n      }\n    }\n    \n    // Combine results by type\n    const aggregated = {\n      byType: new Map(),\n      byTask: new Map(),\n      overall: {\n        totalAgents: results.size,\n        successCount: 0,\n        errorCount: 0,\n        totalTokens: 0,\n        averageRuntime: 0\n      }\n    };\n    \n    let totalRuntime = 0;\n    for (const [agentId, data] of results) {\n      // Group by type\n      if (!aggregated.byType.has(data.type)) {\n        aggregated.byType.set(data.type, []);\n      }\n      aggregated.byType.get(data.type).push(data);\n      \n      // Group by task\n      const taskId = data.task.id || data.task.name;\n      aggregated.byTask.set(taskId, data);\n      \n      // Update overall metrics\n      if (data.metrics.status === 'completed') {\n        aggregated.overall.successCount++;\n      } else if (data.metrics.status === 'error') {\n        aggregated.overall.errorCount++;\n      }\n      aggregated.overall.totalTokens += data.metrics.tokenUsage;\n      totalRuntime += data.metrics.runtime;\n    }\n    \n    aggregated.overall.averageRuntime = totalRuntime / results.size || 0;\n    \n    return aggregated;\n  }\n  \n  /**\n   * Handle inter-agent communication\n   * @param {string} fromAgent - Source agent ID\n   * @param {string} toAgent - Target agent ID (or 'broadcast')\n   * @param {object} message - Message to send\n   */\n  async handleInterAgentCommunication(fromAgent, toAgent, message) {\n    const timestamp = Date.now();\n    \n    // Validate source agent\n    if (!this.subAgents.has(fromAgent)) {\n      throw new Error(`Unknown source agent: ${fromAgent}`);\n    }\n    \n    // Create message envelope\n    const envelope = {\n      id: `msg-${timestamp}-${Math.random().toString(36).substr(2, 9)}`,\n      from: fromAgent,\n      to: toAgent,\n      timestamp,\n      type: message.type || 'data',\n      payload: message.payload || message,\n      routing: message.routing || 'direct'\n    };\n    \n    // Handle broadcast\n    if (toAgent === 'broadcast' || toAgent === '*') {\n      for (const agentId of this.activeAgents) {\n        if (agentId !== fromAgent) {\n          await this.deliverMessage(agentId, envelope);\n        }\n      }\n      this.emit('message-broadcast', envelope);\n    } \n    // Handle targeted message\n    else if (this.subAgents.has(toAgent)) {\n      await this.deliverMessage(toAgent, envelope);\n      this.emit('message-sent', envelope);\n    }\n    // Handle unknown target\n    else {\n      this.emit('message-failed', { \n        ...envelope, \n        error: `Unknown target agent: ${toAgent}` \n      });\n      return false;\n    }\n    \n    // Store in shared memory for persistence\n    const messageHistory = this.sharedMemory.get('message_history') || [];\n    messageHistory.push(envelope);\n    this.sharedMemory.set('message_history', messageHistory);\n    \n    return true;\n  }\n  \n  /**\n   * Deliver message to specific agent\n   */\n  async deliverMessage(agentId, message) {\n    const agent = this.subAgents.get(agentId);\n    if (!agent) return;\n    \n    // Add to agent's message queue\n    if (!agent.messageQueue) {\n      agent.messageQueue = [];\n    }\n    agent.messageQueue.push(message);\n    \n    // Update agent context with new message\n    agent.context.latestMessage = message;\n    \n    this.emit('message-delivered', {\n      agentId,\n      messageId: message.id\n    });\n  }\n  \n  /**\n   * Handle agent completion\n   */\n  async handleAgentCompletion(agent) {\n    const agentId = agent.id;\n    \n    // Get agent results\n    const results = this.sharedMemory.get('agent_results').get(agentId) || {};\n    \n    // Mark task as completed\n    if (agent.task && agent.task.id) {\n      this.completedTasks.set(agent.task.id, results);\n      this.metrics.tasksCompleted++;\n    }\n    \n    // Calculate average completion time\n    const runtime = Date.now() - agent.startTime;\n    this.metrics.averageCompletionTime = \n      (this.metrics.averageCompletionTime * (this.metrics.tasksCompleted - 1) + runtime) / \n      this.metrics.tasksCompleted;\n    \n    // Clean up agent\n    this.activeAgents.delete(agentId);\n    agent.status = 'completed';\n    agent.endTime = Date.now();\n    \n    this.emit('agent-completed', {\n      agentId,\n      type: agent.type,\n      runtime,\n      tokenUsage: agent.tokenUsage,\n      results\n    });\n    \n    // Check for pending tasks that can now run\n    await this.processPendingTasks();\n    \n    // Process queued tasks if any\n    if (this.taskQueue.length > 0 && this.activeAgents.size < this.maxConcurrent) {\n      const queued = this.taskQueue.shift();\n      await this.spawnSubAgent(queued.type, queued.task, queued.context);\n    }\n  }\n  \n  /**\n   * Handle agent errors\n   */\n  async handleAgentError(agent, error) {\n    const agentId = agent.id;\n    \n    // Log error\n    this.metrics.errors.push({\n      agentId,\n      type: agent.type,\n      error: error.message || error,\n      timestamp: Date.now()\n    });\n    \n    // Update agent status\n    agent.status = 'error';\n    agent.error = error;\n    agent.endTime = Date.now();\n    \n    // Clean up\n    this.activeAgents.delete(agentId);\n    \n    this.emit('agent-error', {\n      agentId,\n      type: agent.type,\n      error,\n      task: agent.task\n    });\n    \n    // Attempt recovery\n    if (agent.task && agent.task.retryOnError) {\n      await this.retryTask(agent.task, agent.type);\n    }\n  }\n  \n  /**\n   * Process pending tasks that were waiting on dependencies\n   */\n  async processPendingTasks() {\n    for (const [taskId, pending] of this.pendingTasks) {\n      const { task, dependencies } = pending;\n      \n      // Check if all dependencies are now complete\n      const allComplete = dependencies.every(dep => this.completedTasks.has(dep));\n      \n      if (allComplete) {\n        this.pendingTasks.delete(taskId);\n        await this.distributeTask(task, dependencies);\n      }\n    }\n  }\n  \n  /**\n   * Retry a failed task\n   */\n  async retryTask(task, agentType) {\n    task.retryCount = (task.retryCount || 0) + 1;\n    \n    if (task.retryCount <= 3) {\n      this.emit('task-retry', {\n        taskId: task.id,\n        attempt: task.retryCount\n      });\n      \n      // Add back to queue with delay\n      setTimeout(() => {\n        this.taskQueue.push({\n          type: agentType,\n          task,\n          context: { isRetry: true, attempt: task.retryCount }\n        });\n      }, 5000 * task.retryCount); // Exponential backoff\n    } else {\n      this.emit('task-failed', {\n        taskId: task.id,\n        reason: 'Max retries exceeded'\n      });\n    }\n  }\n  \n  /**\n   * Select appropriate agent type for a task\n   */\n  selectAgentType(task) {\n    // Task type mapping\n    const typeMapping = {\n      'analysis': 'code-analyzer',\n      'testing': 'test-runner',\n      'documentation': 'doc-generator',\n      'api': 'api-builder',\n      'database': 'database-architect',\n      'security': 'security-scanner',\n      'performance': 'performance-optimizer',\n      'deployment': 'deployment-engineer',\n      'frontend': 'frontend-specialist',\n      'recovery': 'recovery-specialist'\n    };\n    \n    // Check explicit type\n    if (task.agentType) {\n      return task.agentType;\n    }\n    \n    // Check task category\n    if (task.category && typeMapping[task.category]) {\n      return typeMapping[task.category];\n    }\n    \n    // Analyze task description for keywords\n    const description = (task.description || task.name || '').toLowerCase();\n    for (const [keyword, type] of Object.entries(typeMapping)) {\n      if (description.includes(keyword)) {\n        return type;\n      }\n    }\n    \n    // Default to code analyzer\n    return 'code-analyzer';\n  }\n  \n  /**\n   * Get shared context for agents (enhanced with SharedMemoryStore)\n   */\n  async getSharedContext() {\n    const baseContext = {\n      globalContext: this.sharedMemory.get('global_context'),\n      completedTasks: Array.from(this.completedTasks.keys()),\n      activeAgents: Array.from(this.activeAgents),\n      projectMetadata: {\n        root: this.projectRoot,\n        timestamp: Date.now()\n      }\n    };\n\n    // Enhance with SharedMemoryStore data if available\n    if (this.sharedMemoryStore) {\n      try {\n        const memoryStats = this.sharedMemoryStore.getStats();\n        \n        baseContext.sharedMemoryStore = {\n          available: true,\n          stats: memoryStats,\n          namespaces: this.sharedMemoryStore.namespaces,\n          dataTypes: this.sharedMemoryStore.dataTypes\n        };\n        \n        // Get cross-agent data\n        const crossAgentKeys = await this.sharedMemoryStore.keys({\n          namespace: this.sharedMemoryStore.namespaces.CROSS_AGENT\n        });\n        \n        baseContext.crossAgentData = crossAgentKeys;\n        \n      } catch (error) {\n        console.warn('Failed to get enhanced shared context:', error.message);\n        baseContext.sharedMemoryStore = { available: false, error: error.message };\n      }\n    } else {\n      baseContext.sharedMemoryStore = { available: false, reason: 'not_configured' };\n    }\n\n    return baseContext;\n  }\n  \n  /**\n   * Generate default instructions for agent types\n   */\n  generateDefaultInstructions(type) {\n    const defaults = {\n      'code-analyzer': 'Analyze code structure, patterns, and quality.',\n      'test-runner': 'Execute tests and validate functionality.',\n      'doc-generator': 'Generate documentation and markdown files.',\n      'api-builder': 'Build and configure API endpoints.',\n      'database-architect': 'Design database schemas and queries.',\n      'security-scanner': 'Scan for security vulnerabilities.',\n      'performance-optimizer': 'Optimize performance and efficiency.',\n      'deployment-engineer': 'Handle deployment and CI/CD.',\n      'frontend-specialist': 'Build frontend components and UI.',\n      'recovery-specialist': 'Recover from errors and fix issues.'\n    };\n    \n    return defaults[type] || 'Perform assigned tasks efficiently.';\n  }\n  \n  /**\n   * Start monitoring loop\n   */\n  startMonitoring() {\n    this.monitoringInterval = setInterval(async () => {\n      const status = await this.monitorAgents();\n      this.emit('monitoring-update', status);\n    }, 5000); // Monitor every 5 seconds\n  }\n  \n  /**\n   * Terminate an agent\n   */\n  async terminateAgent(agentId, reason = 'manual') {\n    const agent = this.subAgents.get(agentId);\n    if (!agent) return false;\n    \n    // Clean up\n    this.activeAgents.delete(agentId);\n    agent.status = 'terminated';\n    agent.endTime = Date.now();\n    agent.terminationReason = reason;\n    \n    this.emit('agent-terminated', {\n      agentId,\n      type: agent.type,\n      reason\n    });\n    \n    // Process any queued tasks\n    if (this.taskQueue.length > 0 && this.activeAgents.size < this.maxConcurrent) {\n      const queued = this.taskQueue.shift();\n      await this.spawnSubAgent(queued.type, queued.task, queued.context);\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Shutdown Queen Controller\n   */\n  async shutdown() {\n    // Stop monitoring\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n    }\n    \n    // Terminate all active agents\n    for (const agentId of this.activeAgents) {\n      await this.terminateAgent(agentId, 'shutdown');\n    }\n    \n    // Save metrics\n    const metricsPath = path.join(this.projectRoot, '.hive-mind', 'queen-metrics.json');\n    try {\n      await fs.writeFile(metricsPath, JSON.stringify(this.metrics, null, 2));\n    } catch (error) {\n      console.error('Failed to save metrics:', error);\n    }\n    \n    this.emit('shutdown-complete');\n  }\n  \n  /**\n   * Get current status\n   */\n  getStatus() {\n    return {\n      active: this.activeAgents.size,\n      queued: this.taskQueue.length,\n      pending: this.pendingTasks.size,\n      completed: this.completedTasks.size,\n      maxConcurrent: this.maxConcurrent,\n      metrics: this.metrics,\n      agents: Array.from(this.subAgents.values()).map(agent => ({\n        id: agent.id,\n        type: agent.type,\n        status: agent.status,\n        tokenUsage: agent.tokenUsage,\n        runtime: agent.endTime ? agent.endTime - agent.startTime : Date.now() - agent.startTime\n      }))\n    };\n  }\n}\n\nmodule.exports = QueenController;",
          "size": 21571,
          "lastModified": "2025-08-13T02:15:29.274Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "QueenController",
                "position": 642
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/shared-memory.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/shared-memory.js",
          "fileName": "shared-memory.js",
          "extension": "js",
          "type": "javascript",
          "content": "/**\n * Shared Memory Store - Production-Ready Cross-Agent Data Sharing\n * \n * This implementation provides a comprehensive shared memory system for the\n * Hive-Mind architecture, enabling cross-agent data sharing, context preservation,\n * result caching, and state synchronization with SQLite persistence.\n * \n * Features:\n * - Dual-layer architecture: In-memory cache + SQLite persistence\n * - Atomic operations for concurrent access\n * - Memory versioning and conflict resolution\n * - Pub/Sub event system for real-time updates\n * - Garbage collection for expired data\n * - Performance optimization for high-frequency access\n * - Cross-agent result sharing and context preservation\n * - Memory limits and intelligent cleanup\n * \n * @author Claude Code\n * @date August 2025\n * @version 2.1.0\n */\n\nconst EventEmitter = require('events');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass SharedMemoryStore extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Core configuration\n    this.projectRoot = options.projectRoot || process.cwd();\n    this.hiveMindPath = path.join(this.projectRoot, '.hive-mind');\n    this.maxMemorySize = options.maxMemorySize || 500 * 1024 * 1024; // 500MB default\n    this.maxEntries = options.maxEntries || 100000;\n    this.gcInterval = options.gcInterval || 300000; // 5 minutes\n    this.compressionThreshold = options.compressionThreshold || 1024 * 1024; // 1MB\n    \n    // In-memory storage layers\n    this.memoryCache = new Map(); // Fast access cache\n    this.persistentStore = new Map(); // Persistent data store\n    this.versionStore = new Map(); // Version tracking\n    this.metadataStore = new Map(); // Entry metadata\n    this.subscriberStore = new Map(); // Pub/Sub subscribers\n    this.lockStore = new Map(); // Atomic operation locks\n    \n    // Performance tracking\n    this.stats = {\n      reads: 0,\n      writes: 0,\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      gcRuns: 0,\n      totalMemoryUsed: 0,\n      averageReadTime: 0,\n      averageWriteTime: 0,\n      concurrentOperations: 0\n    };\n    \n    // Memory management\n    this.memoryUsage = 0;\n    this.entryCount = 0;\n    this.isInitialized = false;\n    this.gcTimer = null;\n    this.operationQueue = [];\n    this.processingQueue = false;\n    \n    // SQLite integration paths\n    this.dbPaths = {\n      hive: path.join(this.hiveMindPath, 'hive.db'),\n      memory: path.join(this.hiveMindPath, 'memory.db'),\n      sessions: path.join(this.hiveMindPath, 'sessions')\n    };\n    \n    // Namespaces for different data types\n    this.namespaces = {\n      AGENT_CONTEXT: 'agent_context',\n      TASK_RESULTS: 'task_results', \n      SHARED_STATE: 'shared_state',\n      CROSS_AGENT: 'cross_agent',\n      CACHE: 'cache',\n      TEMP: 'temp',\n      CONFIG: 'config',\n      METRICS: 'metrics'\n    };\n    \n    // Data types with different persistence strategies\n    this.dataTypes = {\n      PERSISTENT: 'persistent',     // Survive process restarts\n      TRANSIENT: 'transient',       // Memory-only, cleared on restart\n      CACHED: 'cached',             // LRU cache with TTL\n      VERSIONED: 'versioned',       // Version controlled with history\n      SHARED: 'shared',             // Cross-agent shared data\n      LOCKED: 'locked'              // Requires exclusive access\n    };\n    \n    // Initialize immediately\n    this.init().catch(error => {\n      this.emit('error', new Error(`Failed to initialize SharedMemoryStore: ${error.message}`));\n    });\n  }\n  \n  /**\n   * Initialize the shared memory store\n   */\n  async init() {\n    try {\n      // Ensure .hive-mind directory exists\n      await this.ensureDirectoryStructure();\n      \n      // Initialize SQLite integration (if possible)\n      await this.initializeSQLiteIntegration();\n      \n      // Load persistent data\n      await this.loadPersistentData();\n      \n      // Start garbage collection\n      this.startGarbageCollection();\n      \n      // Mark as initialized\n      this.isInitialized = true;\n      \n      this.emit('initialized', {\n        memoryEntries: this.entryCount,\n        memoryUsage: this.memoryUsage,\n        dbStatus: this.dbStatus\n      });\n      \n      console.log('SharedMemoryStore initialized successfully');\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Ensure directory structure exists\n   */\n  async ensureDirectoryStructure() {\n    try {\n      await fs.mkdir(this.hiveMindPath, { recursive: true });\n      await fs.mkdir(this.dbPaths.sessions, { recursive: true });\n      \n      // Create backup directory\n      const backupPath = path.join(this.hiveMindPath, 'backups');\n      await fs.mkdir(backupPath, { recursive: true });\n      \n    } catch (error) {\n      throw new Error(`Failed to create directory structure: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Initialize SQLite integration (graceful fallback if SQLite unavailable)\n   */\n  async initializeSQLiteIntegration() {\n    this.dbStatus = { available: false, reason: 'not_initialized' };\n    \n    try {\n      // Try to load sqlite3 module\n      const sqlite3 = require('sqlite3');\n      this.sqlite3 = sqlite3;\n      \n      // Initialize databases\n      await this.initializeMemoryDB();\n      await this.initializeHiveDB();\n      \n      this.dbStatus = { available: true, version: sqlite3.VERSION };\n      \n    } catch (error) {\n      // Fallback to file-based persistence\n      this.dbStatus = { \n        available: false, \n        reason: 'sqlite_unavailable',\n        fallback: 'file_based',\n        error: error.message\n      };\n      \n      console.warn('SQLite unavailable, using file-based persistence:', error.message);\n    }\n  }\n  \n  /**\n   * Initialize memory-specific SQLite database\n   */\n  async initializeMemoryDB() {\n    return new Promise((resolve, reject) => {\n      this.memoryDB = new this.sqlite3.Database(this.dbPaths.memory, (err) => {\n        if (err) {\n          reject(new Error(`Failed to open memory.db: ${err.message}`));\n          return;\n        }\n        \n        // Create tables if they don't exist\n        const createTables = `\n          CREATE TABLE IF NOT EXISTS shared_memory (\n            key TEXT PRIMARY KEY,\n            namespace TEXT NOT NULL,\n            data_type TEXT NOT NULL,\n            value TEXT NOT NULL,\n            metadata TEXT,\n            version INTEGER DEFAULT 1,\n            created_at INTEGER NOT NULL,\n            updated_at INTEGER NOT NULL,\n            expires_at INTEGER,\n            size_bytes INTEGER DEFAULT 0,\n            access_count INTEGER DEFAULT 0,\n            last_accessed INTEGER\n          );\n          \n          CREATE TABLE IF NOT EXISTS memory_versions (\n            key TEXT NOT NULL,\n            version INTEGER NOT NULL,\n            value TEXT NOT NULL,\n            metadata TEXT,\n            created_at INTEGER NOT NULL,\n            PRIMARY KEY (key, version)\n          );\n          \n          CREATE TABLE IF NOT EXISTS memory_locks (\n            key TEXT PRIMARY KEY,\n            agent_id TEXT NOT NULL,\n            lock_type TEXT NOT NULL,\n            acquired_at INTEGER NOT NULL,\n            expires_at INTEGER NOT NULL\n          );\n          \n          CREATE INDEX IF NOT EXISTS idx_namespace ON shared_memory(namespace);\n          CREATE INDEX IF NOT EXISTS idx_data_type ON shared_memory(data_type);\n          CREATE INDEX IF NOT EXISTS idx_expires_at ON shared_memory(expires_at);\n          CREATE INDEX IF NOT EXISTS idx_last_accessed ON shared_memory(last_accessed);\n        `;\n        \n        this.memoryDB.exec(createTables, (err) => {\n          if (err) {\n            reject(new Error(`Failed to create memory tables: ${err.message}`));\n            return;\n          }\n          resolve();\n        });\n      });\n    });\n  }\n  \n  /**\n   * Initialize hive-specific SQLite database\n   */\n  async initializeHiveDB() {\n    return new Promise((resolve, reject) => {\n      this.hiveDB = new this.sqlite3.Database(this.dbPaths.hive, (err) => {\n        if (err) {\n          reject(new Error(`Failed to open hive.db: ${err.message}`));\n          return;\n        }\n        \n        // Create additional tables for cross-agent coordination\n        const createTables = `\n          CREATE TABLE IF NOT EXISTS agent_memory (\n            agent_id TEXT NOT NULL,\n            memory_key TEXT NOT NULL,\n            access_type TEXT NOT NULL,\n            timestamp INTEGER NOT NULL,\n            PRIMARY KEY (agent_id, memory_key)\n          );\n          \n          CREATE TABLE IF NOT EXISTS memory_events (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            event_type TEXT NOT NULL,\n            memory_key TEXT NOT NULL,\n            agent_id TEXT,\n            timestamp INTEGER NOT NULL,\n            data TEXT\n          );\n          \n          CREATE INDEX IF NOT EXISTS idx_agent_memory ON agent_memory(agent_id);\n          CREATE INDEX IF NOT EXISTS idx_memory_events_key ON memory_events(memory_key);\n          CREATE INDEX IF NOT EXISTS idx_memory_events_timestamp ON memory_events(timestamp);\n        `;\n        \n        this.hiveDB.exec(createTables, (err) => {\n          if (err) {\n            reject(new Error(`Failed to create hive tables: ${err.message}`));\n            return;\n          }\n          resolve();\n        });\n      });\n    });\n  }\n  \n  /**\n   * Load persistent data from storage\n   */\n  async loadPersistentData() {\n    if (this.dbStatus.available) {\n      await this.loadFromSQLite();\n    } else {\n      await this.loadFromFiles();\n    }\n  }\n  \n  /**\n   * Load data from SQLite\n   */\n  async loadFromSQLite() {\n    return new Promise((resolve, reject) => {\n      if (!this.memoryDB) {\n        resolve();\n        return;\n      }\n      \n      const query = `\n        SELECT key, namespace, data_type, value, metadata, version, \n               created_at, updated_at, expires_at, access_count \n        FROM shared_memory \n        WHERE expires_at IS NULL OR expires_at > ?\n      `;\n      \n      this.memoryDB.all(query, [Date.now()], (err, rows) => {\n        if (err) {\n          reject(new Error(`Failed to load from SQLite: ${err.message}`));\n          return;\n        }\n        \n        let loadedCount = 0;\n        let totalSize = 0;\n        \n        for (const row of rows) {\n          try {\n            const value = JSON.parse(row.value);\n            const metadata = row.metadata ? JSON.parse(row.metadata) : {};\n            \n            // Load into appropriate store based on data type\n            if (row.data_type === this.dataTypes.TRANSIENT) {\n              // Skip transient data on reload\n              continue;\n            }\n            \n            this.persistentStore.set(row.key, value);\n            this.metadataStore.set(row.key, {\n              namespace: row.namespace,\n              dataType: row.data_type,\n              version: row.version,\n              createdAt: row.created_at,\n              updatedAt: row.updated_at,\n              expiresAt: row.expires_at,\n              accessCount: row.access_count,\n              ...metadata\n            });\n            \n            if (row.version > 1) {\n              this.versionStore.set(row.key, row.version);\n            }\n            \n            loadedCount++;\n            totalSize += (row.value?.length || 0);\n            \n          } catch (error) {\n            console.warn(`Failed to load memory entry ${row.key}:`, error.message);\n          }\n        }\n        \n        this.entryCount = loadedCount;\n        this.memoryUsage = totalSize;\n        \n        console.log(`Loaded ${loadedCount} memory entries from SQLite (${totalSize} bytes)`);\n        resolve();\n      });\n    });\n  }\n  \n  /**\n   * Load data from files (fallback)\n   */\n  async loadFromFiles() {\n    try {\n      const memoryFile = path.join(this.hiveMindPath, 'shared-memory.json');\n      \n      try {\n        const data = await fs.readFile(memoryFile, 'utf-8');\n        const parsed = JSON.parse(data);\n        \n        if (parsed.entries && parsed.metadata) {\n          for (const [key, value] of Object.entries(parsed.entries)) {\n            const metadata = parsed.metadata[key];\n            \n            // Skip expired entries\n            if (metadata?.expiresAt && metadata.expiresAt < Date.now()) {\n              continue;\n            }\n            \n            // Skip transient data\n            if (metadata?.dataType === this.dataTypes.TRANSIENT) {\n              continue;\n            }\n            \n            this.persistentStore.set(key, value);\n            if (metadata) {\n              this.metadataStore.set(key, metadata);\n            }\n            \n            this.entryCount++;\n            this.memoryUsage += JSON.stringify(value).length;\n          }\n          \n          console.log(`Loaded ${this.entryCount} memory entries from file`);\n        }\n        \n      } catch (error) {\n        // File doesn't exist or is invalid, start fresh\n        console.log('No existing memory file found, starting fresh');\n      }\n      \n    } catch (error) {\n      console.warn('Failed to load from files:', error.message);\n    }\n  }\n  \n  /**\n   * Set a value in shared memory with full feature support\n   * @param {string} key - Unique key for the data\n   * @param {any} value - Data to store\n   * @param {object} options - Storage options\n   */\n  async set(key, value, options = {}) {\n    const startTime = Date.now();\n    \n    try {\n      // Validate inputs\n      if (!key || typeof key !== 'string') {\n        throw new Error('Key must be a non-empty string');\n      }\n      \n      // Normalize options\n      const opts = {\n        namespace: options.namespace || this.namespaces.SHARED_STATE,\n        dataType: options.dataType || this.dataTypes.PERSISTENT,\n        ttl: options.ttl, // Time to live in milliseconds\n        version: options.version,\n        metadata: options.metadata || {},\n        agentId: options.agentId,\n        compress: options.compress || false,\n        lock: options.lock || false\n      };\n      \n      // Handle locking\n      if (opts.lock) {\n        await this.acquireLock(key, opts.agentId || 'system');\n      }\n      \n      // Serialize value\n      const serializedValue = JSON.stringify(value);\n      const valueSize = serializedValue.length;\n      \n      // Check memory limits\n      await this.checkMemoryLimits(valueSize);\n      \n      // Handle versioning\n      const currentVersion = this.versionStore.get(key) || 0;\n      const newVersion = opts.version || currentVersion + 1;\n      \n      // Store version history if enabled\n      if (opts.dataType === this.dataTypes.VERSIONED) {\n        await this.storeVersion(key, newVersion, value, opts.metadata);\n      }\n      \n      // Calculate expiration\n      const expiresAt = opts.ttl ? Date.now() + opts.ttl : null;\n      \n      // Create metadata\n      const metadata = {\n        namespace: opts.namespace,\n        dataType: opts.dataType,\n        version: newVersion,\n        createdAt: this.metadataStore.get(key)?.createdAt || Date.now(),\n        updatedAt: Date.now(),\n        expiresAt,\n        accessCount: this.metadataStore.get(key)?.accessCount || 0,\n        size: valueSize,\n        agentId: opts.agentId,\n        compressed: opts.compress,\n        ...opts.metadata\n      };\n      \n      // Store in appropriate layer\n      if (opts.dataType === this.dataTypes.TRANSIENT) {\n        this.memoryCache.set(key, value);\n      } else {\n        this.persistentStore.set(key, value);\n        \n        // Also cache for fast access\n        this.memoryCache.set(key, value);\n        \n        // Persist to SQLite if available\n        if (this.dbStatus.available) {\n          await this.persistToSQLite(key, serializedValue, metadata);\n        }\n      }\n      \n      // Update metadata and version tracking\n      this.metadataStore.set(key, metadata);\n      this.versionStore.set(key, newVersion);\n      \n      // Update memory usage\n      this.memoryUsage += valueSize;\n      this.entryCount++;\n      \n      // Update statistics\n      this.stats.writes++;\n      this.stats.totalMemoryUsed = this.memoryUsage;\n      this.stats.averageWriteTime = this.calculateAverageTime(\n        this.stats.averageWriteTime, \n        this.stats.writes, \n        Date.now() - startTime\n      );\n      \n      // Emit events\n      this.emit('memory-set', {\n        key,\n        namespace: opts.namespace,\n        dataType: opts.dataType,\n        version: newVersion,\n        size: valueSize,\n        agentId: opts.agentId\n      });\n      \n      // Notify subscribers\n      await this.notifySubscribers(key, 'set', { value, metadata });\n      \n      // Log agent access\n      if (opts.agentId) {\n        await this.logAgentAccess(opts.agentId, key, 'write');\n      }\n      \n      // Release lock if acquired\n      if (opts.lock) {\n        await this.releaseLock(key, opts.agentId || 'system');\n      }\n      \n      return {\n        success: true,\n        version: newVersion,\n        size: valueSize,\n        expiresAt\n      };\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a value from shared memory with caching and performance optimization\n   * @param {string} key - Key to retrieve\n   * @param {object} options - Retrieval options\n   */\n  async get(key, options = {}) {\n    const startTime = Date.now();\n    \n    try {\n      if (!key || typeof key !== 'string') {\n        throw new Error('Key must be a non-empty string');\n      }\n      \n      const opts = {\n        agentId: options.agentId,\n        includeMetadata: options.includeMetadata || false,\n        version: options.version, // Specific version to retrieve\n        bypassCache: options.bypassCache || false\n      };\n      \n      let value = null;\n      let metadata = null;\n      let fromCache = false;\n      \n      // Check memory cache first (if not bypassing)\n      if (!opts.bypassCache && this.memoryCache.has(key)) {\n        value = this.memoryCache.get(key);\n        metadata = this.metadataStore.get(key);\n        fromCache = true;\n        this.stats.hits++;\n      }\n      \n      // Check persistent store\n      if (value === null && this.persistentStore.has(key)) {\n        value = this.persistentStore.get(key);\n        metadata = this.metadataStore.get(key);\n        \n        // Update cache\n        this.memoryCache.set(key, value);\n        this.stats.hits++;\n      }\n      \n      // Check SQLite if still not found\n      if (value === null && this.dbStatus.available) {\n        const result = await this.getFromSQLite(key, opts.version);\n        if (result) {\n          value = result.value;\n          metadata = result.metadata;\n          \n          // Update both stores\n          this.persistentStore.set(key, value);\n          this.memoryCache.set(key, value);\n          this.metadataStore.set(key, metadata);\n          \n          this.stats.hits++;\n        }\n      }\n      \n      // Check expiration\n      if (value !== null && metadata?.expiresAt && metadata.expiresAt < Date.now()) {\n        await this.delete(key);\n        value = null;\n        metadata = null;\n        this.stats.misses++;\n      }\n      \n      // Update access statistics\n      if (value !== null && metadata) {\n        metadata.accessCount = (metadata.accessCount || 0) + 1;\n        metadata.lastAccessed = Date.now();\n        this.metadataStore.set(key, metadata);\n        \n        // Update in SQLite if available\n        if (this.dbStatus.available) {\n          await this.updateAccessStats(key, metadata.accessCount, metadata.lastAccessed);\n        }\n      }\n      \n      // Update performance stats\n      this.stats.reads++;\n      if (value === null) {\n        this.stats.misses++;\n      }\n      \n      this.stats.averageReadTime = this.calculateAverageTime(\n        this.stats.averageReadTime,\n        this.stats.reads,\n        Date.now() - startTime\n      );\n      \n      // Log agent access\n      if (opts.agentId && value !== null) {\n        await this.logAgentAccess(opts.agentId, key, 'read');\n      }\n      \n      // Emit event\n      this.emit('memory-get', {\n        key,\n        found: value !== null,\n        fromCache,\n        agentId: opts.agentId\n      });\n      \n      // Return result\n      if (opts.includeMetadata) {\n        return {\n          value,\n          metadata,\n          found: value !== null\n        };\n      }\n      \n      return value;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete a value from shared memory\n   * @param {string} key - Key to delete\n   * @param {object} options - Deletion options\n   */\n  async delete(key, options = {}) {\n    try {\n      if (!key || typeof key !== 'string') {\n        throw new Error('Key must be a non-empty string');\n      }\n      \n      const opts = {\n        agentId: options.agentId,\n        deleteVersions: options.deleteVersions || false\n      };\n      \n      // Get metadata before deletion\n      const metadata = this.metadataStore.get(key);\n      const existed = this.persistentStore.has(key) || this.memoryCache.has(key);\n      \n      // Remove from all stores\n      this.memoryCache.delete(key);\n      this.persistentStore.delete(key);\n      this.metadataStore.delete(key);\n      this.versionStore.delete(key);\n      \n      // Remove from SQLite if available\n      if (this.dbStatus.available) {\n        await this.deleteFromSQLite(key, opts.deleteVersions);\n      }\n      \n      // Update memory usage\n      if (metadata) {\n        this.memoryUsage -= metadata.size || 0;\n        this.entryCount--;\n      }\n      \n      // Emit events\n      this.emit('memory-delete', {\n        key,\n        existed,\n        agentId: opts.agentId\n      });\n      \n      // Notify subscribers\n      await this.notifySubscribers(key, 'delete', { metadata });\n      \n      // Log agent access\n      if (opts.agentId) {\n        await this.logAgentAccess(opts.agentId, key, 'delete');\n      }\n      \n      return existed;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get all keys matching a pattern or namespace\n   * @param {object} options - Search options\n   */\n  async keys(options = {}) {\n    try {\n      const opts = {\n        namespace: options.namespace,\n        pattern: options.pattern,\n        dataType: options.dataType,\n        includeExpired: options.includeExpired || false\n      };\n      \n      const allKeys = new Set([\n        ...this.memoryCache.keys(),\n        ...this.persistentStore.keys()\n      ]);\n      \n      const filteredKeys = [];\n      const now = Date.now();\n      \n      for (const key of allKeys) {\n        const metadata = this.metadataStore.get(key);\n        \n        // Skip expired entries unless specifically requested\n        if (!opts.includeExpired && metadata?.expiresAt && metadata.expiresAt < now) {\n          continue;\n        }\n        \n        // Apply filters\n        if (opts.namespace && metadata?.namespace !== opts.namespace) {\n          continue;\n        }\n        \n        if (opts.dataType && metadata?.dataType !== opts.dataType) {\n          continue;\n        }\n        \n        if (opts.pattern && !key.match(new RegExp(opts.pattern))) {\n          continue;\n        }\n        \n        filteredKeys.push(key);\n      }\n      \n      return filteredKeys;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get memory usage statistics and information\n   */\n  getStats() {\n    const cacheHitRate = this.stats.reads > 0 ? \n      (this.stats.hits / this.stats.reads * 100).toFixed(2) : 0;\n    \n    return {\n      ...this.stats,\n      cacheHitRate: `${cacheHitRate}%`,\n      memoryUsage: this.memoryUsage,\n      entryCount: this.entryCount,\n      maxMemorySize: this.maxMemorySize,\n      maxEntries: this.maxEntries,\n      memoryUtilization: `${(this.memoryUsage / this.maxMemorySize * 100).toFixed(2)}%`,\n      entryUtilization: `${(this.entryCount / this.maxEntries * 100).toFixed(2)}%`,\n      dbStatus: this.dbStatus,\n      activeSubscribers: this.subscriberStore.size,\n      activeLocks: this.lockStore.size\n    };\n  }\n  \n  /**\n   * Subscribe to memory changes for specific keys or patterns\n   * @param {string} keyPattern - Key or pattern to watch\n   * @param {function} callback - Function to call on changes\n   * @param {object} options - Subscription options\n   */\n  subscribe(keyPattern, callback, options = {}) {\n    try {\n      const subscriptionId = crypto.randomUUID();\n      \n      const subscription = {\n        id: subscriptionId,\n        pattern: keyPattern,\n        callback,\n        agentId: options.agentId,\n        events: options.events || ['set', 'delete', 'expire'],\n        createdAt: Date.now()\n      };\n      \n      if (!this.subscriberStore.has(keyPattern)) {\n        this.subscriberStore.set(keyPattern, new Map());\n      }\n      \n      this.subscriberStore.get(keyPattern).set(subscriptionId, subscription);\n      \n      this.emit('subscription-created', {\n        subscriptionId,\n        keyPattern,\n        agentId: options.agentId\n      });\n      \n      // Return unsubscribe function\n      return () => {\n        this.unsubscribe(subscriptionId, keyPattern);\n      };\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Unsubscribe from memory changes\n   * @param {string} subscriptionId - ID of subscription to remove\n   * @param {string} keyPattern - Key pattern of subscription\n   */\n  unsubscribe(subscriptionId, keyPattern) {\n    try {\n      const patternSubs = this.subscriberStore.get(keyPattern);\n      if (patternSubs) {\n        const removed = patternSubs.delete(subscriptionId);\n        \n        if (patternSubs.size === 0) {\n          this.subscriberStore.delete(keyPattern);\n        }\n        \n        if (removed) {\n          this.emit('subscription-removed', {\n            subscriptionId,\n            keyPattern\n          });\n        }\n        \n        return removed;\n      }\n      \n      return false;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Acquire an exclusive lock on a memory key\n   * @param {string} key - Key to lock\n   * @param {string} agentId - Agent requesting the lock\n   * @param {object} options - Lock options\n   */\n  async acquireLock(key, agentId, options = {}) {\n    try {\n      const opts = {\n        timeout: options.timeout || 30000, // 30 seconds default\n        lockType: options.lockType || 'exclusive'\n      };\n      \n      const existingLock = this.lockStore.get(key);\n      const now = Date.now();\n      \n      // Check if lock is already held\n      if (existingLock) {\n        // Check if lock has expired\n        if (existingLock.expiresAt > now) {\n          throw new Error(`Key ${key} is already locked by agent ${existingLock.agentId}`);\n        } else {\n          // Lock expired, remove it\n          this.lockStore.delete(key);\n        }\n      }\n      \n      // Create new lock\n      const lock = {\n        key,\n        agentId,\n        lockType: opts.lockType,\n        acquiredAt: now,\n        expiresAt: now + opts.timeout\n      };\n      \n      this.lockStore.set(key, lock);\n      \n      // Persist to SQLite if available\n      if (this.dbStatus.available) {\n        await this.persistLockToSQLite(lock);\n      }\n      \n      this.emit('lock-acquired', {\n        key,\n        agentId,\n        lockType: opts.lockType,\n        expiresAt: lock.expiresAt\n      });\n      \n      return lock;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Release a lock on a memory key\n   * @param {string} key - Key to unlock\n   * @param {string} agentId - Agent releasing the lock\n   */\n  async releaseLock(key, agentId) {\n    try {\n      const existingLock = this.lockStore.get(key);\n      \n      if (!existingLock) {\n        return false; // No lock to release\n      }\n      \n      if (existingLock.agentId !== agentId) {\n        throw new Error(`Agent ${agentId} cannot release lock held by ${existingLock.agentId}`);\n      }\n      \n      this.lockStore.delete(key);\n      \n      // Remove from SQLite if available\n      if (this.dbStatus.available) {\n        await this.removeLockFromSQLite(key);\n      }\n      \n      this.emit('lock-released', {\n        key,\n        agentId\n      });\n      \n      return true;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Perform atomic operations on memory values\n   * @param {string} key - Key to operate on\n   * @param {function} operation - Function to perform atomically\n   * @param {object} options - Operation options\n   */\n  async atomic(key, operation, options = {}) {\n    const agentId = options.agentId || 'system';\n    let lock = null;\n    \n    try {\n      // Acquire lock\n      lock = await this.acquireLock(key, agentId, {\n        timeout: options.timeout || 10000\n      });\n      \n      // Get current value\n      const currentValue = await this.get(key, { agentId });\n      \n      // Perform operation\n      const newValue = await operation(currentValue);\n      \n      // Set new value if operation returned something\n      if (newValue !== undefined) {\n        await this.set(key, newValue, {\n          agentId,\n          ...options\n        });\n      }\n      \n      return newValue;\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      // Always release lock\n      if (lock) {\n        await this.releaseLock(key, agentId);\n      }\n    }\n  }\n  \n  /**\n   * Start garbage collection process\n   */\n  startGarbageCollection() {\n    if (this.gcTimer) {\n      clearInterval(this.gcTimer);\n    }\n    \n    this.gcTimer = setInterval(async () => {\n      try {\n        await this.runGarbageCollection();\n      } catch (error) {\n        this.emit('error', new Error(`Garbage collection failed: ${error.message}`));\n      }\n    }, this.gcInterval);\n    \n    console.log(`Garbage collection started with ${this.gcInterval}ms interval`);\n  }\n  \n  /**\n   * Run garbage collection to clean expired data and manage memory\n   */\n  async runGarbageCollection() {\n    const startTime = Date.now();\n    const now = Date.now();\n    let expiredCount = 0;\n    let evictedCount = 0;\n    \n    try {\n      // Clean expired entries\n      for (const [key, metadata] of this.metadataStore) {\n        if (metadata.expiresAt && metadata.expiresAt < now) {\n          await this.delete(key);\n          expiredCount++;\n        }\n      }\n      \n      // Clean expired locks\n      for (const [key, lock] of this.lockStore) {\n        if (lock.expiresAt < now) {\n          this.lockStore.delete(key);\n          if (this.dbStatus.available) {\n            await this.removeLockFromSQLite(key);\n          }\n        }\n      }\n      \n      // Check memory limits and evict if necessary\n      if (this.memoryUsage > this.maxMemorySize || this.entryCount > this.maxEntries) {\n        evictedCount = await this.evictLRUEntries();\n      }\n      \n      // Update statistics\n      this.stats.gcRuns++;\n      this.stats.evictions += evictedCount;\n      \n      const gcTime = Date.now() - startTime;\n      \n      this.emit('garbage-collection', {\n        duration: gcTime,\n        expiredCount,\n        evictedCount,\n        memoryUsage: this.memoryUsage,\n        entryCount: this.entryCount\n      });\n      \n      if (expiredCount > 0 || evictedCount > 0) {\n        console.log(`GC completed: ${expiredCount} expired, ${evictedCount} evicted (${gcTime}ms)`);\n      }\n      \n    } catch (error) {\n      console.error('Garbage collection error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Evict least recently used entries to free memory\n   */\n  async evictLRUEntries() {\n    const entries = [];\n    \n    // Collect all entries with access information\n    for (const [key, metadata] of this.metadataStore) {\n      if (metadata.dataType !== this.dataTypes.LOCKED) {\n        entries.push({\n          key,\n          lastAccessed: metadata.lastAccessed || metadata.createdAt,\n          size: metadata.size || 0\n        });\n      }\n    }\n    \n    // Sort by last accessed (oldest first)\n    entries.sort((a, b) => a.lastAccessed - b.lastAccessed);\n    \n    let evictedCount = 0;\n    let freedMemory = 0;\n    \n    // Evict entries until we're under limits\n    for (const entry of entries) {\n      if (this.memoryUsage <= this.maxMemorySize * 0.8 && \n          this.entryCount <= this.maxEntries * 0.8) {\n        break;\n      }\n      \n      await this.delete(entry.key);\n      evictedCount++;\n      freedMemory += entry.size;\n    }\n    \n    if (evictedCount > 0) {\n      console.log(`Evicted ${evictedCount} LRU entries, freed ${freedMemory} bytes`);\n    }\n    \n    return evictedCount;\n  }\n  \n  /**\n   * Check memory limits before adding new data\n   */\n  async checkMemoryLimits(newDataSize) {\n    const projectedMemory = this.memoryUsage + newDataSize;\n    const projectedEntries = this.entryCount + 1;\n    \n    if (projectedMemory > this.maxMemorySize) {\n      // Try to free memory through garbage collection\n      await this.runGarbageCollection();\n      \n      // Check again after GC\n      if (this.memoryUsage + newDataSize > this.maxMemorySize) {\n        throw new Error(`Memory limit exceeded: ${projectedMemory} > ${this.maxMemorySize}`);\n      }\n    }\n    \n    if (projectedEntries > this.maxEntries) {\n      throw new Error(`Entry limit exceeded: ${projectedEntries} > ${this.maxEntries}`);\n    }\n  }\n  \n  /**\n   * Notify subscribers of memory changes\n   */\n  async notifySubscribers(key, eventType, data) {\n    try {\n      for (const [pattern, subscribers] of this.subscriberStore) {\n        if (key.match(new RegExp(pattern)) || pattern === '*') {\n          for (const [subId, subscription] of subscribers) {\n            if (subscription.events.includes(eventType)) {\n              try {\n                await subscription.callback({\n                  key,\n                  eventType,\n                  data,\n                  timestamp: Date.now(),\n                  agentId: subscription.agentId\n                });\n              } catch (error) {\n                console.warn(`Subscriber ${subId} callback failed:`, error.message);\n              }\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to notify subscribers:', error);\n    }\n  }\n  \n  /**\n   * Calculate rolling average for performance metrics\n   */\n  calculateAverageTime(currentAverage, count, newTime) {\n    if (count === 1) {\n      return newTime;\n    }\n    return ((currentAverage * (count - 1)) + newTime) / count;\n  }\n  \n  /**\n   * Store a version of data for version control\n   */\n  async storeVersion(key, version, value, metadata) {\n    if (this.dbStatus.available && this.memoryDB) {\n      return new Promise((resolve, reject) => {\n        const stmt = this.memoryDB.prepare(`\n          INSERT OR REPLACE INTO memory_versions \n          (key, version, value, metadata, created_at) \n          VALUES (?, ?, ?, ?, ?)\n        `);\n        \n        stmt.run([\n          key,\n          version,\n          JSON.stringify(value),\n          JSON.stringify(metadata),\n          Date.now()\n        ], (err) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n        \n        stmt.finalize();\n      });\n    }\n  }\n  \n  /**\n   * Log agent access for monitoring and analytics\n   */\n  async logAgentAccess(agentId, key, accessType) {\n    if (this.dbStatus.available && this.hiveDB) {\n      return new Promise((resolve, reject) => {\n        const stmt = this.hiveDB.prepare(`\n          INSERT OR REPLACE INTO agent_memory \n          (agent_id, memory_key, access_type, timestamp) \n          VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([agentId, key, accessType, Date.now()], (err) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n        \n        stmt.finalize();\n      });\n    }\n  }\n  \n  /**\n   * Persist data to SQLite\n   */\n  async persistToSQLite(key, serializedValue, metadata) {\n    if (!this.memoryDB) return;\n    \n    return new Promise((resolve, reject) => {\n      const stmt = this.memoryDB.prepare(`\n        INSERT OR REPLACE INTO shared_memory \n        (key, namespace, data_type, value, metadata, version, \n         created_at, updated_at, expires_at, size_bytes, access_count, last_accessed) \n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `);\n      \n      stmt.run([\n        key,\n        metadata.namespace,\n        metadata.dataType,\n        serializedValue,\n        JSON.stringify(metadata),\n        metadata.version,\n        metadata.createdAt,\n        metadata.updatedAt,\n        metadata.expiresAt,\n        metadata.size,\n        metadata.accessCount,\n        metadata.lastAccessed\n      ], (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n      \n      stmt.finalize();\n    });\n  }\n  \n  /**\n   * Get data from SQLite\n   */\n  async getFromSQLite(key, version = null) {\n    if (!this.memoryDB) return null;\n    \n    return new Promise((resolve, reject) => {\n      let query = 'SELECT * FROM shared_memory WHERE key = ?';\n      const params = [key];\n      \n      if (version) {\n        query = 'SELECT * FROM memory_versions WHERE key = ? AND version = ?';\n        params.push(version);\n      }\n      \n      this.memoryDB.get(query, params, (err, row) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        \n        if (!row) {\n          resolve(null);\n          return;\n        }\n        \n        try {\n          const value = JSON.parse(row.value);\n          const metadata = row.metadata ? JSON.parse(row.metadata) : {};\n          \n          resolve({ value, metadata });\n        } catch (parseError) {\n          reject(parseError);\n        }\n      });\n    });\n  }\n  \n  /**\n   * Delete data from SQLite\n   */\n  async deleteFromSQLite(key, deleteVersions = false) {\n    if (!this.memoryDB) return;\n    \n    return new Promise((resolve, reject) => {\n      this.memoryDB.serialize(() => {\n        this.memoryDB.run('DELETE FROM shared_memory WHERE key = ?', [key]);\n        \n        if (deleteVersions) {\n          this.memoryDB.run('DELETE FROM memory_versions WHERE key = ?', [key]);\n        }\n        \n        resolve();\n      });\n    });\n  }\n  \n  /**\n   * Update access statistics in SQLite\n   */\n  async updateAccessStats(key, accessCount, lastAccessed) {\n    if (!this.memoryDB) return;\n    \n    return new Promise((resolve, reject) => {\n      const stmt = this.memoryDB.prepare(`\n        UPDATE shared_memory \n        SET access_count = ?, last_accessed = ? \n        WHERE key = ?\n      `);\n      \n      stmt.run([accessCount, lastAccessed, key], (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n      \n      stmt.finalize();\n    });\n  }\n  \n  /**\n   * Persist lock to SQLite\n   */\n  async persistLockToSQLite(lock) {\n    if (!this.memoryDB) return;\n    \n    return new Promise((resolve, reject) => {\n      const stmt = this.memoryDB.prepare(`\n        INSERT OR REPLACE INTO memory_locks \n        (key, agent_id, lock_type, acquired_at, expires_at) \n        VALUES (?, ?, ?, ?, ?)\n      `);\n      \n      stmt.run([\n        lock.key,\n        lock.agentId,\n        lock.lockType,\n        lock.acquiredAt,\n        lock.expiresAt\n      ], (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n      \n      stmt.finalize();\n    });\n  }\n  \n  /**\n   * Remove lock from SQLite\n   */\n  async removeLockFromSQLite(key) {\n    if (!this.memoryDB) return;\n    \n    return new Promise((resolve, reject) => {\n      this.memoryDB.run('DELETE FROM memory_locks WHERE key = ?', [key], (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  \n  /**\n   * Save current state to files (backup and fallback)\n   */\n  async saveToFiles() {\n    try {\n      const data = {\n        entries: Object.fromEntries(this.persistentStore),\n        metadata: Object.fromEntries(this.metadataStore),\n        versions: Object.fromEntries(this.versionStore),\n        timestamp: Date.now(),\n        stats: this.stats\n      };\n      \n      const memoryFile = path.join(this.hiveMindPath, 'shared-memory.json');\n      const backupFile = path.join(this.hiveMindPath, 'backups', `shared-memory-${Date.now()}.json`);\n      \n      // Save current state\n      await fs.writeFile(memoryFile, JSON.stringify(data, null, 2));\n      \n      // Create backup\n      await fs.writeFile(backupFile, JSON.stringify(data, null, 2));\n      \n      console.log('Memory state saved to files');\n      \n    } catch (error) {\n      console.error('Failed to save memory state:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Shutdown the shared memory store gracefully\n   */\n  async shutdown() {\n    try {\n      console.log('Shutting down SharedMemoryStore...');\n      \n      // Stop garbage collection\n      if (this.gcTimer) {\n        clearInterval(this.gcTimer);\n      }\n      \n      // Save current state\n      await this.saveToFiles();\n      \n      // Close SQLite databases\n      if (this.memoryDB) {\n        await new Promise((resolve) => {\n          this.memoryDB.close(resolve);\n        });\n      }\n      \n      if (this.hiveDB) {\n        await new Promise((resolve) => {\n          this.hiveDB.close(resolve);\n        });\n      }\n      \n      // Clear all data\n      this.memoryCache.clear();\n      this.persistentStore.clear();\n      this.metadataStore.clear();\n      this.versionStore.clear();\n      this.subscriberStore.clear();\n      this.lockStore.clear();\n      \n      this.emit('shutdown-complete');\n      console.log('SharedMemoryStore shutdown complete');\n      \n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n}\n\nmodule.exports = SharedMemoryStore;",
          "size": 41920,
          "lastModified": "2025-08-13T02:10:26.318Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "return",
                "position": 25050
              }
            ],
            "classes": [
              {
                "name": "SharedMemoryStore",
                "position": 938
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/smart-tool-selector.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/smart-tool-selector.js",
          "fileName": "smart-tool-selector.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\r\n\r\n/**\r\n * Smart Tool Selector\r\n * Intelligently selects the best tool for each task\r\n * Adapts based on availability and task requirements\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst IntegrationChecker = require('./integration-checker');\r\n\r\nclass SmartToolSelector {\r\n  constructor(projectPath = process.cwd()) {\r\n    this.projectPath = projectPath;\r\n    this.integrations = null;\r\n    this.taskPatterns = this.loadTaskPatterns();\r\n  }\r\n\r\n  /**\r\n   * Initialize by checking available integrations\r\n   */\r\n  async initialize() {\r\n    const checker = new IntegrationChecker(this.projectPath);\r\n    const results = await checker.checkAll();\r\n    this.integrations = results.integrations;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Select best tool for a given task\r\n   */\r\n  async selectTool(task, context = {}) {\r\n    // Ensure we're initialized\r\n    if (!this.integrations) {\r\n      await this.initialize();\r\n    }\r\n\r\n    // Analyze task requirements\r\n    const requirements = this.analyzeTask(task);\r\n    \r\n    // Score each available tool\r\n    const scores = this.scoreTools(requirements, context);\r\n    \r\n    // Select best tool with fallback options\r\n    const selection = this.chooseBestTool(scores, requirements);\r\n    \r\n    return {\r\n      primary: selection.primary,\r\n      fallback: selection.fallback,\r\n      command: this.generateCommand(selection.primary, task, context),\r\n      reasoning: selection.reasoning,\r\n      requirements\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze task to determine requirements\r\n   */\r\n  analyzeTask(task) {\r\n    const requirements = {\r\n      complexity: 'low',\r\n      coordination: false,\r\n      memory: false,\r\n      realtime: false,\r\n      planning: false,\r\n      testing: false,\r\n      deployment: false,\r\n      aiAssisted: true,\r\n      multiFile: false,\r\n      systemLevel: false\r\n    };\r\n\r\n    const taskLower = task.toLowerCase();\r\n\r\n    // Complexity detection\r\n    if (taskLower.includes('enterprise') || \r\n        taskLower.includes('architecture') || \r\n        taskLower.includes('system design')) {\r\n      requirements.complexity = 'high';\r\n      requirements.planning = true;\r\n    } else if (taskLower.includes('feature') || \r\n               taskLower.includes('api') || \r\n               taskLower.includes('integration')) {\r\n      requirements.complexity = 'medium';\r\n    }\r\n\r\n    // Coordination needs\r\n    if (taskLower.includes('multi') || \r\n        taskLower.includes('coordinate') || \r\n        taskLower.includes('orchestrate')) {\r\n      requirements.coordination = true;\r\n    }\r\n\r\n    // Memory requirements\r\n    if (taskLower.includes('context') || \r\n        taskLower.includes('remember') || \r\n        taskLower.includes('previous')) {\r\n      requirements.memory = true;\r\n    }\r\n\r\n    // Real-time needs\r\n    if (taskLower.includes('real-time') || \r\n        taskLower.includes('websocket') || \r\n        taskLower.includes('live')) {\r\n      requirements.realtime = true;\r\n    }\r\n\r\n    // Testing requirements\r\n    if (taskLower.includes('test') || \r\n        taskLower.includes('spec') || \r\n        taskLower.includes('coverage')) {\r\n      requirements.testing = true;\r\n    }\r\n\r\n    // Deployment needs\r\n    if (taskLower.includes('deploy') || \r\n        taskLower.includes('release') || \r\n        taskLower.includes('production')) {\r\n      requirements.deployment = true;\r\n    }\r\n\r\n    // Multi-file operations\r\n    if (taskLower.includes('refactor') || \r\n        taskLower.includes('across') || \r\n        taskLower.includes('multiple files')) {\r\n      requirements.multiFile = true;\r\n    }\r\n\r\n    // System-level operations\r\n    if (taskLower.includes('install') || \r\n        taskLower.includes('configure') || \r\n        taskLower.includes('setup')) {\r\n      requirements.systemLevel = true;\r\n    }\r\n\r\n    return requirements;\r\n  }\r\n\r\n  /**\r\n   * Score available tools based on requirements\r\n   */\r\n  scoreTools(requirements, context) {\r\n    const scores = {};\r\n\r\n    // Claude Code scoring\r\n    if (this.integrations.claudeCode) {\r\n      scores.claudeCode = this.scoreClaudeCode(requirements, context);\r\n    }\r\n\r\n    // Agent-OS scoring\r\n    if (this.integrations.agentOS) {\r\n      scores.agentOS = this.scoreAgentOS(requirements, context);\r\n    }\r\n\r\n    // Claude Flow scoring\r\n    if (this.integrations.claudeFlow) {\r\n      scores.claudeFlow = this.scoreClaudeFlow(requirements, context);\r\n    }\r\n\r\n    // TMux Orchestrator scoring\r\n    if (this.integrations.tmux) {\r\n      scores.tmux = this.scoreTMux(requirements, context);\r\n    }\r\n\r\n    // Fallback: Basic workflow\r\n    scores.basicWorkflow = this.scoreBasicWorkflow(requirements, context);\r\n\r\n    return scores;\r\n  }\r\n\r\n  /**\r\n   * Score Claude Code for task\r\n   */\r\n  scoreClaudeCode(requirements, context) {\r\n    let score = 0;\r\n\r\n    // Claude Code excels at:\r\n    if (requirements.aiAssisted) score += 30;\r\n    if (requirements.complexity === 'low') score += 20;\r\n    if (requirements.complexity === 'medium') score += 15;\r\n    if (!requirements.coordination) score += 10;\r\n    if (requirements.multiFile) score += 15;\r\n    if (requirements.testing) score += 10;\r\n\r\n    // Less suitable for:\r\n    if (requirements.complexity === 'high') score -= 10;\r\n    if (requirements.coordination) score -= 15;\r\n    if (requirements.systemLevel) score -= 10;\r\n\r\n    // Context bonuses\r\n    if (context.userPreference === 'claude-code') score += 20;\r\n    if (context.previousSuccess === 'claude-code') score += 10;\r\n\r\n    return {\r\n      score,\r\n      tool: 'claude-code',\r\n      strengths: ['AI assistance', 'code generation', 'multi-file edits'],\r\n      weaknesses: ['complex coordination', 'system operations']\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Score Agent-OS for task\r\n   */\r\n  scoreAgentOS(requirements, context) {\r\n    let score = 0;\r\n\r\n    // Agent-OS excels at:\r\n    if (requirements.coordination) score += 25;\r\n    if (requirements.planning) score += 20;\r\n    if (requirements.complexity === 'high') score += 20;\r\n    if (requirements.systemLevel) score += 15;\r\n    if (requirements.deployment) score += 15;\r\n\r\n    // Less suitable for:\r\n    if (requirements.complexity === 'low') score -= 10;\r\n    if (!requirements.coordination) score -= 5;\r\n\r\n    // Context bonuses\r\n    if (context.userPreference === 'agent-os') score += 20;\r\n    if (context.projectType === 'enterprise') score += 15;\r\n\r\n    return {\r\n      score,\r\n      tool: 'agent-os',\r\n      strengths: ['orchestration', 'planning', 'system operations'],\r\n      weaknesses: ['simple tasks', 'quick fixes']\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Score Claude Flow for task\r\n   */\r\n  scoreClaudeFlow(requirements, context) {\r\n    let score = 0;\r\n\r\n    // Claude Flow excels at:\r\n    if (requirements.coordination) score += 30;\r\n    if (requirements.memory) score += 25;\r\n    if (requirements.complexity === 'medium') score += 20;\r\n    if (requirements.complexity === 'high') score += 25;\r\n    if (requirements.realtime) score += 15;\r\n    if (requirements.planning) score += 20;\r\n\r\n    // Specialized approaches\r\n    if (requirements.complexity === 'high' && requirements.planning) {\r\n      score += 20; // SPARC methodology\r\n    }\r\n\r\n    // Less suitable for:\r\n    if (requirements.complexity === 'low') score -= 15;\r\n    if (!requirements.coordination && !requirements.memory) score -= 10;\r\n\r\n    // Context bonuses\r\n    if (context.userPreference === 'claude-flow') score += 20;\r\n    if (context.agentCount > 1) score += 15;\r\n\r\n    return {\r\n      score,\r\n      tool: 'claude-flow',\r\n      strengths: ['multi-agent coordination', 'memory', 'complex workflows'],\r\n      weaknesses: ['simple tasks', 'overhead for small projects'],\r\n      approach: this.selectClaudeFlowApproach(requirements)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Score TMux Orchestrator for task\r\n   */\r\n  scoreTMux(requirements, context) {\r\n    let score = 0;\r\n\r\n    // TMux excels at:\r\n    if (requirements.realtime) score += 20;\r\n    if (requirements.coordination) score += 15;\r\n    if (requirements.systemLevel) score += 20;\r\n    if (context.longRunning) score += 25;\r\n\r\n    // Less suitable for:\r\n    if (!requirements.coordination) score -= 10;\r\n    if (requirements.complexity === 'low') score -= 15;\r\n\r\n    // Context bonuses\r\n    if (context.userPreference === 'tmux') score += 20;\r\n    if (context.sessionManagement) score += 15;\r\n\r\n    return {\r\n      score,\r\n      tool: 'tmux',\r\n      strengths: ['session management', 'long-running tasks', 'parallel execution'],\r\n      weaknesses: ['simple tasks', 'overhead for quick operations']\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Score basic workflow for task\r\n   */\r\n  scoreBasicWorkflow(requirements, context) {\r\n    let score = 10; // Base score as fallback\r\n\r\n    // Basic workflow is good for:\r\n    if (requirements.complexity === 'low') score += 20;\r\n    if (!requirements.coordination) score += 15;\r\n    if (!requirements.memory) score += 10;\r\n\r\n    // Less suitable for:\r\n    if (requirements.complexity === 'high') score -= 20;\r\n    if (requirements.coordination) score -= 15;\r\n    if (requirements.planning) score -= 15;\r\n\r\n    return {\r\n      score,\r\n      tool: 'basic-workflow',\r\n      strengths: ['simplicity', 'quick execution', 'no dependencies'],\r\n      weaknesses: ['complex tasks', 'coordination', 'memory']\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Select Claude Flow approach based on requirements\r\n   */\r\n  selectClaudeFlowApproach(requirements) {\r\n    if (requirements.complexity === 'high' && requirements.planning) {\r\n      return 'hive-mind-sparc';\r\n    } else if (requirements.complexity === 'medium' || requirements.coordination) {\r\n      return 'hive-mind';\r\n    } else {\r\n      return 'simple-swarm';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Choose best tool from scores\r\n   */\r\n  chooseBestTool(scores, requirements) {\r\n    // Sort tools by score\r\n    const sorted = Object.entries(scores)\r\n      .sort((a, b) => b[1].score - a[1].score);\r\n\r\n    const primary = sorted[0][1];\r\n    const fallback = sorted[1] ? sorted[1][1] : null;\r\n\r\n    // Generate reasoning\r\n    const reasoning = this.generateReasoning(primary, fallback, requirements);\r\n\r\n    return {\r\n      primary,\r\n      fallback,\r\n      reasoning\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate reasoning for tool selection\r\n   */\r\n  generateReasoning(primary, fallback, requirements) {\r\n    let reasoning = `Selected ${primary.tool} because it excels at ${primary.strengths.join(', ')}.`;\r\n\r\n    if (requirements.complexity === 'high') {\r\n      reasoning += ' The task complexity requires advanced coordination capabilities.';\r\n    }\r\n\r\n    if (requirements.coordination) {\r\n      reasoning += ' Multi-agent coordination is needed for this task.';\r\n    }\r\n\r\n    if (fallback && fallback.score > 0) {\r\n      reasoning += ` Fallback option: ${fallback.tool} can handle ${fallback.strengths.join(', ')}.`;\r\n    }\r\n\r\n    return reasoning;\r\n  }\r\n\r\n  /**\r\n   * Generate command for selected tool\r\n   */\r\n  generateCommand(toolInfo, task, context) {\r\n    switch (toolInfo.tool) {\r\n      case 'claude-code':\r\n        return this.generateClaudeCommand(task, context);\r\n      \r\n      case 'agent-os':\r\n        return this.generateAgentOSCommand(task, context);\r\n      \r\n      case 'claude-flow':\r\n        return this.generateClaudeFlowCommand(toolInfo, task, context);\r\n      \r\n      case 'tmux':\r\n        return this.generateTMuxCommand(task, context);\r\n      \r\n      case 'basic-workflow':\r\n      default:\r\n        return this.generateBasicCommand(task, context);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate Claude Code command\r\n   */\r\n  generateClaudeCommand(task, context) {\r\n    let command = context.yoloMode ? 'yolo' : 'claude';\r\n    \r\n    if (context.projectPath) {\r\n      command += ` --project \"${context.projectPath}\"`;\r\n    }\r\n    \r\n    command += ` \"${task}\"`;\r\n    \r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * Generate Agent-OS command\r\n   */\r\n  generateAgentOSCommand(task, context) {\r\n    return `agent-os orchestrate --task \"${task}\" --mode ${context.mode || 'auto'}`;\r\n  }\r\n\r\n  /**\r\n   * Generate Claude Flow command\r\n   */\r\n  generateClaudeFlowCommand(toolInfo, task, context) {\r\n    const version = context.claudeFlowVersion || 'alpha';\r\n    let command = `npx claude-flow@${version}`;\r\n    \r\n    switch (toolInfo.approach) {\r\n      case 'hive-mind-sparc':\r\n        command += ` hive-mind spawn --sparc --agents ${context.agentCount || 8}`;\r\n        break;\r\n      case 'hive-mind':\r\n        command += ` hive-mind spawn --agents ${context.agentCount || 4}`;\r\n        break;\r\n      case 'simple-swarm':\r\n      default:\r\n        command += ` swarm`;\r\n        break;\r\n    }\r\n    \r\n    command += ` --${context.yoloMode ? 'yolo' : 'claude'} \"${task}\"`;\r\n    \r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * Generate TMux command\r\n   */\r\n  generateTMuxCommand(task, context) {\r\n    return `tmux-orchestrator start --task \"${task}\" --session ${context.sessionName || 'workflow'}`;\r\n  }\r\n\r\n  /**\r\n   * Generate basic workflow command\r\n   */\r\n  generateBasicCommand(task, context) {\r\n    return `./ai-workflow init --auto \"${task}\"`;\r\n  }\r\n\r\n  /**\r\n   * Load task pattern definitions\r\n   */\r\n  loadTaskPatterns() {\r\n    return {\r\n      'feature-development': {\r\n        preferred: ['claude-code', 'claude-flow'],\r\n        requirements: ['aiAssisted', 'multiFile']\r\n      },\r\n      'bug-fix': {\r\n        preferred: ['claude-code'],\r\n        requirements: ['aiAssisted']\r\n      },\r\n      'system-architecture': {\r\n        preferred: ['agent-os', 'claude-flow'],\r\n        requirements: ['planning', 'coordination']\r\n      },\r\n      'testing': {\r\n        preferred: ['claude-code', 'agent-os'],\r\n        requirements: ['testing', 'multiFile']\r\n      },\r\n      'deployment': {\r\n        preferred: ['agent-os', 'tmux'],\r\n        requirements: ['deployment', 'systemLevel']\r\n      },\r\n      'refactoring': {\r\n        preferred: ['claude-code', 'claude-flow'],\r\n        requirements: ['multiFile', 'aiAssisted']\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get recommendations for task\r\n   */\r\n  async getRecommendations(task, context = {}) {\r\n    await this.initialize();\r\n    \r\n    const selection = await this.selectTool(task, context);\r\n    const recommendations = [];\r\n\r\n    // Add tool-specific recommendations\r\n    if (!this.integrations[selection.primary.tool]) {\r\n      recommendations.push(`Install ${selection.primary.tool} for optimal performance`);\r\n    }\r\n\r\n    // Add approach recommendations\r\n    if (selection.primary.tool === 'claude-flow' && selection.primary.approach === 'hive-mind-sparc') {\r\n      recommendations.push('Consider using SPARC methodology for systematic development');\r\n    }\r\n\r\n    // Add context recommendations\r\n    if (selection.requirements.memory && !this.integrations.claudeFlow) {\r\n      recommendations.push('Claude Flow provides memory capabilities for context retention');\r\n    }\r\n\r\n    if (selection.requirements.coordination && !this.integrations.agentOS) {\r\n      recommendations.push('Agent-OS enhances multi-system coordination');\r\n    }\r\n\r\n    return {\r\n      selection,\r\n      recommendations\r\n    };\r\n  }\r\n}\r\n\r\n// CLI execution\r\nif (require.main === module) {\r\n  const task = process.argv[2];\r\n  \r\n  if (!task) {\r\n    console.error('Usage: smart-tool-selector.js \"task description\"');\r\n    process.exit(1);\r\n  }\r\n  \r\n  const selector = new SmartToolSelector();\r\n  \r\n  selector.getRecommendations(task).then(result => {\r\n    console.log('\\n🎯 Tool Selection for:', task);\r\n    console.log('=' .repeat(50));\r\n    \r\n    console.log('\\n📊 Selected Tool:', result.selection.primary.tool);\r\n    console.log('💡 Reasoning:', result.selection.reasoning);\r\n    console.log('\\n🚀 Command:', result.selection.command);\r\n    \r\n    if (result.selection.fallback) {\r\n      console.log('\\n🔄 Fallback:', result.selection.fallback.tool);\r\n    }\r\n    \r\n    if (result.recommendations.length > 0) {\r\n      console.log('\\n💡 Recommendations:');\r\n      result.recommendations.forEach(rec => {\r\n        console.log(`  • ${rec}`);\r\n      });\r\n    }\r\n    \r\n    console.log('\\n' + '='.repeat(50));\r\n  });\r\n}\r\n\r\nmodule.exports = SmartToolSelector;",
          "size": 15994,
          "lastModified": "2025-08-12T23:42:29.118Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": true,
          "agentOSVersion": ".",
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "SmartToolSelector",
                "position": 290
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/sub-agent-manager.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/sub-agent-manager.js",
          "fileName": "sub-agent-manager.js",
          "extension": "js",
          "type": "javascript",
          "content": "/**\n * Sub-Agent Manager - Lifecycle and Resource Management\n * \n * Manages the complete lifecycle of sub-agents including spawning, monitoring,\n * resource allocation, and termination. Integrates with TMux sessions for\n * multi-window coordination and tracks context window usage.\n */\n\nconst { spawn } = require('child_process');\nconst EventEmitter = require('events');\nconst path = require('path');\nconst fs = require('fs').promises;\n\nclass SubAgentManager extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    // Configuration\n    this.maxAgents = options.maxAgents || 10;\n    this.contextWindowLimit = options.contextWindowLimit || 200000; // 200k tokens\n    this.projectRoot = options.projectRoot || process.cwd();\n    this.tmuxEnabled = options.tmuxEnabled !== false;\n    \n    // Agent registry\n    this.agents = new Map();\n    this.processes = new Map();\n    this.sessions = new Map();\n    \n    // Resource tracking\n    this.resources = {\n      memory: new Map(),\n      cpu: new Map(),\n      tokens: new Map(),\n      startTimes: new Map()\n    };\n    \n    // Performance metrics\n    this.metrics = {\n      totalSpawned: 0,\n      totalTerminated: 0,\n      averageLifetime: 0,\n      peakConcurrent: 0,\n      contextOverflows: 0,\n      errors: []\n    };\n    \n    // TMux configuration\n    this.tmuxConfig = {\n      sessionPrefix: 'queen-agent-',\n      windowLayout: 'tiled',\n      paneSync: false\n    };\n    \n    // Agent template paths\n    this.templatePaths = {\n      default: path.join(this.projectRoot, '.claude/agents'),\n      workflow: path.join(this.projectRoot, '.ai-workflow/agent-templates'),\n      custom: path.join(this.projectRoot, 'agent-templates')\n    };\n    \n    // Start resource monitoring\n    this.startResourceMonitoring();\n  }\n  \n  /**\n   * Spawn a new sub-agent with lifecycle management\n   * @param {string} agentId - Unique agent identifier\n   * @param {string} type - Agent type/role\n   * @param {object} config - Agent configuration\n   */\n  async spawnAgent(agentId, type, config = {}) {\n    // Check resource limits\n    if (this.agents.size >= this.maxAgents) {\n      throw new Error(`Maximum agent limit reached: ${this.maxAgents}`);\n    }\n    \n    // Create agent metadata\n    const agent = {\n      id: agentId,\n      type: type,\n      status: 'spawning',\n      config: {\n        ...config,\n        contextWindow: config.contextWindow || this.contextWindowLimit,\n        timeout: config.timeout || 300000, // 5 minutes default\n        retries: config.retries || 3\n      },\n      spawnTime: Date.now(),\n      pid: null,\n      sessionId: null,\n      tokenUsage: 0,\n      messageCount: 0\n    };\n    \n    // Register agent\n    this.agents.set(agentId, agent);\n    this.resources.tokens.set(agentId, 0);\n    this.resources.startTimes.set(agentId, Date.now());\n    \n    try {\n      // Load agent template\n      const template = await this.loadAgentTemplate(type);\n      agent.template = template;\n      \n      // Create TMux session if enabled\n      if (this.tmuxEnabled) {\n        agent.sessionId = await this.createTmuxSession(agentId, type);\n        this.sessions.set(agentId, agent.sessionId);\n      }\n      \n      // Spawn agent process\n      const process = await this.spawnAgentProcess(agent);\n      agent.pid = process.pid;\n      this.processes.set(agentId, process);\n      \n      // Initialize resource tracking\n      this.initializeResourceTracking(agentId, process.pid);\n      \n      // Update status\n      agent.status = 'active';\n      this.metrics.totalSpawned++;\n      \n      // Update peak concurrent\n      if (this.agents.size > this.metrics.peakConcurrent) {\n        this.metrics.peakConcurrent = this.agents.size;\n      }\n      \n      // Emit spawn event\n      this.emit('agent-spawned', {\n        agentId,\n        type,\n        pid: process.pid,\n        sessionId: agent.sessionId\n      });\n      \n      // Set up lifecycle monitoring\n      this.monitorAgentLifecycle(agentId);\n      \n      return agent;\n      \n    } catch (error) {\n      // Clean up on error\n      agent.status = 'error';\n      agent.error = error.message;\n      this.agents.delete(agentId);\n      \n      this.metrics.errors.push({\n        agentId,\n        error: error.message,\n        timestamp: Date.now()\n      });\n      \n      throw error;\n    }\n  }\n  \n  /**\n   * Load agent template from various locations\n   */\n  async loadAgentTemplate(type) {\n    const templateFileName = `${type}.md`;\n    const searchPaths = [\n      path.join(this.templatePaths.default, templateFileName),\n      path.join(this.templatePaths.workflow, templateFileName),\n      path.join(this.templatePaths.custom, templateFileName)\n    ];\n    \n    for (const templatePath of searchPaths) {\n      try {\n        const content = await fs.readFile(templatePath, 'utf-8');\n        return {\n          path: templatePath,\n          content: content,\n          type: type\n        };\n      } catch (error) {\n        // Continue searching\n      }\n    }\n    \n    // Return default template if none found\n    return {\n      type: type,\n      content: this.getDefaultTemplate(type),\n      isDefault: true\n    };\n  }\n  \n  /**\n   * Spawn the actual agent process\n   */\n  async spawnAgentProcess(agent) {\n    const command = this.buildAgentCommand(agent);\n    \n    // Spawn process with proper environment\n    const env = {\n      ...process.env,\n      AGENT_ID: agent.id,\n      AGENT_TYPE: agent.type,\n      CONTEXT_WINDOW: agent.config.contextWindow,\n      PROJECT_ROOT: this.projectRoot,\n      QUEEN_CONTROLLER: 'true'\n    };\n    \n    const processOptions = {\n      cwd: this.projectRoot,\n      env: env,\n      shell: true,\n      detached: false\n    };\n    \n    // Spawn the process\n    const agentProcess = spawn(command.cmd, command.args, processOptions);\n    \n    // Handle process output\n    agentProcess.stdout.on('data', (data) => {\n      this.handleAgentOutput(agent.id, data.toString());\n    });\n    \n    agentProcess.stderr.on('data', (data) => {\n      this.handleAgentError(agent.id, data.toString());\n    });\n    \n    agentProcess.on('exit', (code, signal) => {\n      this.handleAgentExit(agent.id, code, signal);\n    });\n    \n    return agentProcess;\n  }\n  \n  /**\n   * Build command to spawn agent\n   */\n  buildAgentCommand(agent) {\n    // Use npx claude-flow for actual agent spawning\n    const baseCommand = 'npx --yes claude-flow@latest';\n    \n    // Map agent types to claude-flow commands\n    const commandMap = {\n      'code-analyzer': 'analyze',\n      'test-runner': 'test',\n      'doc-generator': 'document',\n      'deployment-engineer': 'deploy',\n      'security-scanner': 'security',\n      'performance-optimizer': 'optimize'\n    };\n    \n    const flowCommand = commandMap[agent.type] || 'agent';\n    \n    return {\n      cmd: baseCommand,\n      args: [\n        flowCommand,\n        '--agent-id', agent.id,\n        '--type', agent.type,\n        '--context-window', agent.config.contextWindow,\n        '--mode', 'sub-agent'\n      ]\n    };\n  }\n  \n  /**\n   * Create TMux session for agent\n   */\n  async createTmuxSession(agentId, type) {\n    const sessionName = `${this.tmuxConfig.sessionPrefix}${agentId}`;\n    \n    try {\n      // Create new tmux session\n      await this.execCommand(`tmux new-session -d -s ${sessionName} -n ${type}`);\n      \n      // Set up panes if needed\n      if (this.tmuxConfig.windowLayout === 'split') {\n        await this.execCommand(`tmux split-window -t ${sessionName} -h`);\n        await this.execCommand(`tmux split-window -t ${sessionName} -v`);\n      }\n      \n      return sessionName;\n    } catch (error) {\n      console.warn(`TMux session creation failed: ${error.message}`);\n      return null;\n    }\n  }\n  \n  /**\n   * Initialize resource tracking for agent\n   */\n  initializeResourceTracking(agentId, pid) {\n    // Track memory usage\n    this.resources.memory.set(agentId, {\n      current: 0,\n      peak: 0,\n      average: 0,\n      samples: []\n    });\n    \n    // Track CPU usage\n    this.resources.cpu.set(agentId, {\n      current: 0,\n      peak: 0,\n      average: 0,\n      samples: []\n    });\n    \n    // Start tracking interval for this agent\n    const trackingInterval = setInterval(() => {\n      if (!this.agents.has(agentId)) {\n        clearInterval(trackingInterval);\n        return;\n      }\n      \n      this.updateResourceMetrics(agentId, pid);\n    }, 5000); // Update every 5 seconds\n  }\n  \n  /**\n   * Update resource metrics for an agent\n   */\n  async updateResourceMetrics(agentId, pid) {\n    try {\n      // Get process stats (simplified - would use proper system calls in production)\n      const memUsage = process.memoryUsage();\n      const cpuUsage = process.cpuUsage();\n      \n      // Update memory tracking\n      const memData = this.resources.memory.get(agentId);\n      if (memData) {\n        memData.current = memUsage.heapUsed;\n        memData.samples.push(memUsage.heapUsed);\n        if (memUsage.heapUsed > memData.peak) {\n          memData.peak = memUsage.heapUsed;\n        }\n        memData.average = memData.samples.reduce((a, b) => a + b, 0) / memData.samples.length;\n      }\n      \n      // Update CPU tracking\n      const cpuData = this.resources.cpu.get(agentId);\n      if (cpuData) {\n        const cpuPercent = (cpuUsage.user + cpuUsage.system) / 1000000; // Convert to percentage\n        cpuData.current = cpuPercent;\n        cpuData.samples.push(cpuPercent);\n        if (cpuPercent > cpuData.peak) {\n          cpuData.peak = cpuPercent;\n        }\n        cpuData.average = cpuData.samples.reduce((a, b) => a + b, 0) / cpuData.samples.length;\n      }\n      \n      // Check for resource warnings\n      if (memUsage.heapUsed > 500 * 1024 * 1024) { // 500MB warning\n        this.emit('resource-warning', {\n          agentId,\n          type: 'memory',\n          value: memUsage.heapUsed,\n          threshold: 500 * 1024 * 1024\n        });\n      }\n      \n    } catch (error) {\n      // Ignore errors in resource tracking\n    }\n  }\n  \n  /**\n   * Monitor agent lifecycle\n   */\n  monitorAgentLifecycle(agentId) {\n    const agent = this.agents.get(agentId);\n    if (!agent) return;\n    \n    // Set timeout for agent\n    if (agent.config.timeout) {\n      setTimeout(() => {\n        if (this.agents.has(agentId) && this.agents.get(agentId).status === 'active') {\n          this.terminateAgent(agentId, 'timeout');\n        }\n      }, agent.config.timeout);\n    }\n    \n    // Monitor context window usage\n    const contextInterval = setInterval(() => {\n      if (!this.agents.has(agentId)) {\n        clearInterval(contextInterval);\n        return;\n      }\n      \n      const tokenUsage = this.resources.tokens.get(agentId) || 0;\n      if (tokenUsage > agent.config.contextWindow * 0.9) {\n        this.emit('context-warning', {\n          agentId,\n          usage: tokenUsage,\n          limit: agent.config.contextWindow,\n          percentage: (tokenUsage / agent.config.contextWindow) * 100\n        });\n      }\n      \n      if (tokenUsage >= agent.config.contextWindow) {\n        this.metrics.contextOverflows++;\n        this.terminateAgent(agentId, 'context-overflow');\n        clearInterval(contextInterval);\n      }\n    }, 10000); // Check every 10 seconds\n  }\n  \n  /**\n   * Update token usage for an agent\n   */\n  updateTokenUsage(agentId, tokens) {\n    const current = this.resources.tokens.get(agentId) || 0;\n    const updated = current + tokens;\n    this.resources.tokens.set(agentId, updated);\n    \n    const agent = this.agents.get(agentId);\n    if (agent) {\n      agent.tokenUsage = updated;\n    }\n    \n    return updated;\n  }\n  \n  /**\n   * Handle agent output\n   */\n  handleAgentOutput(agentId, output) {\n    const agent = this.agents.get(agentId);\n    if (!agent) return;\n    \n    // Update message count\n    agent.messageCount++;\n    \n    // Estimate token usage (rough estimate: 1 token per 4 characters)\n    const estimatedTokens = Math.ceil(output.length / 4);\n    this.updateTokenUsage(agentId, estimatedTokens);\n    \n    // Emit output event\n    this.emit('agent-output', {\n      agentId,\n      type: agent.type,\n      output: output,\n      timestamp: Date.now()\n    });\n  }\n  \n  /**\n   * Handle agent errors\n   */\n  handleAgentError(agentId, error) {\n    const agent = this.agents.get(agentId);\n    if (!agent) return;\n    \n    this.metrics.errors.push({\n      agentId,\n      type: agent.type,\n      error: error,\n      timestamp: Date.now()\n    });\n    \n    this.emit('agent-error', {\n      agentId,\n      type: agent.type,\n      error: error\n    });\n    \n    // Check if we should retry\n    if (agent.config.retries > 0) {\n      agent.config.retries--;\n      this.emit('agent-retry', {\n        agentId,\n        remainingRetries: agent.config.retries\n      });\n    } else {\n      this.terminateAgent(agentId, 'error');\n    }\n  }\n  \n  /**\n   * Handle agent process exit\n   */\n  handleAgentExit(agentId, code, signal) {\n    const agent = this.agents.get(agentId);\n    if (!agent) return;\n    \n    agent.status = 'terminated';\n    agent.exitCode = code;\n    agent.exitSignal = signal;\n    agent.endTime = Date.now();\n    \n    // Calculate lifetime\n    const lifetime = agent.endTime - agent.spawnTime;\n    this.updateAverageLifetime(lifetime);\n    \n    // Clean up resources\n    this.cleanupAgent(agentId);\n    \n    this.emit('agent-terminated', {\n      agentId,\n      type: agent.type,\n      code,\n      signal,\n      lifetime\n    });\n  }\n  \n  /**\n   * Terminate an agent\n   */\n  async terminateAgent(agentId, reason = 'manual') {\n    const agent = this.agents.get(agentId);\n    if (!agent) return false;\n    \n    // Update status\n    agent.status = 'terminating';\n    agent.terminationReason = reason;\n    \n    // Kill process\n    const process = this.processes.get(agentId);\n    if (process) {\n      try {\n        process.kill('SIGTERM');\n        \n        // Force kill after timeout\n        setTimeout(() => {\n          if (this.processes.has(agentId)) {\n            process.kill('SIGKILL');\n          }\n        }, 5000);\n      } catch (error) {\n        console.error(`Error terminating agent ${agentId}:`, error);\n      }\n    }\n    \n    // Close TMux session\n    if (this.tmuxEnabled && agent.sessionId) {\n      try {\n        await this.execCommand(`tmux kill-session -t ${agent.sessionId}`);\n      } catch (error) {\n        // Ignore TMux errors\n      }\n    }\n    \n    // Clean up\n    await this.cleanupAgent(agentId);\n    \n    this.metrics.totalTerminated++;\n    \n    return true;\n  }\n  \n  /**\n   * Clean up agent resources\n   */\n  async cleanupAgent(agentId) {\n    // Remove from registries\n    this.agents.delete(agentId);\n    this.processes.delete(agentId);\n    this.sessions.delete(agentId);\n    \n    // Clean up resource tracking\n    this.resources.memory.delete(agentId);\n    this.resources.cpu.delete(agentId);\n    this.resources.tokens.delete(agentId);\n    this.resources.startTimes.delete(agentId);\n  }\n  \n  /**\n   * Update average lifetime metric\n   */\n  updateAverageLifetime(lifetime) {\n    const total = this.metrics.totalTerminated;\n    if (total === 0) {\n      this.metrics.averageLifetime = lifetime;\n    } else {\n      this.metrics.averageLifetime = \n        (this.metrics.averageLifetime * (total - 1) + lifetime) / total;\n    }\n  }\n  \n  /**\n   * Get agent status\n   */\n  getAgentStatus(agentId) {\n    const agent = this.agents.get(agentId);\n    if (!agent) return null;\n    \n    return {\n      id: agent.id,\n      type: agent.type,\n      status: agent.status,\n      pid: agent.pid,\n      sessionId: agent.sessionId,\n      tokenUsage: agent.tokenUsage,\n      messageCount: agent.messageCount,\n      lifetime: Date.now() - agent.spawnTime,\n      resources: {\n        memory: this.resources.memory.get(agentId),\n        cpu: this.resources.cpu.get(agentId)\n      }\n    };\n  }\n  \n  /**\n   * Get all agents status\n   */\n  getAllAgentsStatus() {\n    const statuses = [];\n    for (const agentId of this.agents.keys()) {\n      statuses.push(this.getAgentStatus(agentId));\n    }\n    return statuses;\n  }\n  \n  /**\n   * Get performance metrics\n   */\n  getMetrics() {\n    return {\n      ...this.metrics,\n      currentActive: this.agents.size,\n      resourceUsage: {\n        totalMemory: Array.from(this.resources.memory.values())\n          .reduce((sum, data) => sum + (data.current || 0), 0),\n        totalCpu: Array.from(this.resources.cpu.values())\n          .reduce((sum, data) => sum + (data.current || 0), 0),\n        totalTokens: Array.from(this.resources.tokens.values())\n          .reduce((sum, val) => sum + val, 0)\n      }\n    };\n  }\n  \n  /**\n   * Start resource monitoring loop\n   */\n  startResourceMonitoring() {\n    this.monitoringInterval = setInterval(() => {\n      this.emit('metrics-update', this.getMetrics());\n    }, 10000); // Every 10 seconds\n  }\n  \n  /**\n   * Execute shell command (helper)\n   */\n  execCommand(command) {\n    return new Promise((resolve, reject) => {\n      require('child_process').exec(command, (error, stdout, stderr) => {\n        if (error) reject(error);\n        else resolve(stdout);\n      });\n    });\n  }\n  \n  /**\n   * Get default template for agent type\n   */\n  getDefaultTemplate(type) {\n    return `---\nname: ${type}\ndescription: Default ${type} agent\ncontext_window: ${this.contextWindowLimit}\n---\n\nYou are a specialized ${type} agent.\n\n## Core Responsibilities\n- Perform ${type} tasks efficiently\n- Report results to Queen Controller\n- Collaborate with other agents\n\n## Communication Protocol\n- Input: Task assignments from Queen Controller\n- Output: Results and status updates\n`;\n  }\n  \n  /**\n   * Shutdown manager\n   */\n  async shutdown() {\n    // Stop monitoring\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n    }\n    \n    // Terminate all agents\n    const agentIds = Array.from(this.agents.keys());\n    for (const agentId of agentIds) {\n      await this.terminateAgent(agentId, 'shutdown');\n    }\n    \n    this.emit('shutdown-complete');\n  }\n}\n\nmodule.exports = SubAgentManager;",
          "size": 17873,
          "lastModified": "2025-08-13T02:06:05.055Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "SubAgentManager",
                "position": 437
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/test-agent-os-document-analyzer.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/test-agent-os-document-analyzer.js",
          "fileName": "test-agent-os-document-analyzer.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Test Agent-OS Document Analyzer\n * Comprehensive testing of the document analysis capabilities\n */\n\nconst AgentOSDocumentAnalyzer = require('./agent-os-document-analyzer.js');\nconst SharedMemoryStore = require('./shared-memory.js');\nconst CustomizationManager = require('./customization-manager.js');\nconst fs = require('fs').promises;\nconst path = require('path');\n\nasync function testAgentOSDocumentAnalyzer() {\n  console.log('🧪 Testing Agent-OS Document Analyzer...\\n');\n  \n  try {\n    // Initialize dependencies\n    console.log('1. Initializing dependencies...');\n    const sharedMemory = new SharedMemoryStore({\n      projectRoot: process.cwd(),\n      maxMemorySize: 100 * 1024 * 1024 // 100MB for testing\n    });\n    \n    await new Promise(resolve => {\n      sharedMemory.once('initialized', resolve);\n    });\n    \n    const customizationManager = new CustomizationManager(sharedMemory);\n    \n    // Initialize analyzer\n    const analyzer = new AgentOSDocumentAnalyzer({\n      projectRoot: process.cwd(),\n      sharedMemory,\n      customizationManager\n    });\n    \n    await new Promise(resolve => {\n      analyzer.once('initialized', resolve);\n    });\n    \n    console.log('✅ Dependencies initialized successfully\\n');\n    \n    // Test 1: Analyze existing documents\n    console.log('2. Testing document discovery and analysis...');\n    const projectPath = process.cwd();\n    \n    const analysisResult = await analyzer.analyzeExistingDocs(projectPath, {\n      recursive: true,\n      detectCustomizations: true,\n      analysisDepth: 'standard'\n    });\n    \n    console.log(`✅ Found and analyzed ${analysisResult.totalDocuments} documents`);\n    console.log(`   - Agent-OS managed: ${analysisResult.agentOSDocuments}`);\n    console.log(`   - With customizations: ${analysisResult.documentsWithCustomizations}\\n`);\n    \n    // Test 2: Document type detection\n    console.log('3. Testing document type detection...');\n    \n    // Test with sample content\n    const testDocuments = [\n      {\n        fileName: 'CLAUDE.md',\n        content: '# Claude Configuration\\n\\n## Project Analysis\\n<!-- USER: Custom section -->'\n      },\n      {\n        fileName: 'package.json',\n        content: '{\"name\": \"test\", \"version\": \"1.0.0\", \"agent-os\": {\"version\": \"2.1.0\"}}'\n      },\n      {\n        fileName: 'docker-compose.yml',\n        content: 'version: \"3.8\"\\nservices:\\n  app:\\n    image: node:18'\n      }\n    ];\n    \n    for (const doc of testDocuments) {\n      const docType = analyzer.detectDocumentType(\n        doc.fileName, \n        path.extname(doc.fileName).slice(1), \n        doc.content\n      );\n      console.log(`   - ${doc.fileName}: ${docType}`);\n    }\n    console.log('✅ Document type detection working\\n');\n    \n    // Test 3: Customization detection\n    console.log('4. Testing customization detection...');\n    \n    const sampleDoc = {\n      path: '/test/CLAUDE.md',\n      content: `# Claude Configuration\n      \n## Project Analysis\n<!-- USER: This is my custom comment -->\n\n## Custom Section\n<!-- CUSTOM START -->\nThis is my custom content that should be preserved.\n<!-- CUSTOM END -->\n\n## Technology Stack\n- JavaScript # MODIFIED - Added TypeScript support\n- Docker`,\n      type: 'markdown'\n    };\n    \n    const customizations = await analyzer.detectCustomizations(sampleDoc, {\n      analyzePatterns: true,\n      detectStructuralChanges: true\n    });\n    \n    console.log(`✅ Detected ${customizations.length} customizations:`);\n    customizations.forEach((custom, index) => {\n      console.log(`   ${index + 1}. ${custom.type}: ${custom.description || 'No description'}`);\n    });\n    console.log('');\n    \n    // Test 4: Extract custom sections\n    console.log('5. Testing custom section extraction...');\n    \n    const customSections = await analyzer.extractCustomSections(sampleDoc.content, {\n      includeComments: true,\n      includeMarkedSections: true\n    });\n    \n    console.log(`✅ Extracted ${customSections.length} custom sections\\n`);\n    \n    // Test 5: Document comparison\n    console.log('6. Testing document comparison...');\n    \n    const doc1 = {\n      content: '# Title\\n\\nOriginal content\\n\\n## Section A',\n      structure: { headers: [{ level: 1, text: 'Title' }] }\n    };\n    \n    const doc2 = {\n      content: '# Title\\n\\nModified content\\n\\n## Section A\\n\\n## Section B',\n      structure: { headers: [{ level: 1, text: 'Title' }, { level: 2, text: 'Section B' }] }\n    };\n    \n    const comparison = await analyzer.compareDocuments(doc1, doc2, {\n      compareContent: true,\n      compareStructure: true\n    });\n    \n    console.log(`✅ Document comparison completed`);\n    console.log(`   - Similarity: ${comparison.similarity}`);\n    console.log(`   - Risk level: ${comparison.riskLevel}\\n`);\n    \n    // Test 6: Update strategy calculation\n    console.log('7. Testing update strategy calculation...');\n    \n    const existingDoc = {\n      path: '/test/CLAUDE.md',\n      content: sampleDoc.content,\n      customizations: customizations,\n      type: 'markdown'\n    };\n    \n    const newTemplate = {\n      version: '2.2.0',\n      content: '# Claude Configuration\\n\\n## New Project Analysis\\n\\n## Technology Stack\\n\\n## New Features',\n      changes: ['Updated project analysis', 'Added new features section']\n    };\n    \n    const strategy = await analyzer.calculateUpdateStrategy(existingDoc, newTemplate, {\n      strategy: 'merge-intelligent',\n      preserveUserContent: true,\n      generateReport: true\n    });\n    \n    console.log(`✅ Update strategy calculated: ${strategy.strategy}`);\n    console.log(`   - Risk level: ${strategy.riskLevel}`);\n    console.log(`   - Estimated time: ${strategy.estimatedTime}\\n`);\n    \n    // Test 7: User content preservation\n    console.log('8. Testing user content preservation...');\n    \n    const preservationResult = await analyzer.preserveUserContent(existingDoc, newTemplate, {\n      preserveComments: true,\n      preserveCustomSections: true,\n      generateBackup: false\n    });\n    \n    console.log(`✅ User content preservation completed`);\n    console.log(`   - Customizations preserved: ${preservationResult.preservationStrategy.customizations.length}`);\n    console.log(`   - Preserved types:`, Object.keys(preservationResult.stats).join(', '));\n    console.log('');\n    \n    // Test 8: Generate merge report\n    console.log('9. Testing merge report generation...');\n    \n    const mergeReport = await analyzer.generateMergeReport(existingDoc, newTemplate, strategy, {\n      includePreview: false,\n      includeRiskAnalysis: true,\n      includeRecommendations: true,\n      format: 'detailed'\n    });\n    \n    console.log(`✅ Merge report generated`);\n    console.log(`   - Document type: ${mergeReport.executiveSummary.documentType}`);\n    console.log(`   - Customizations found: ${mergeReport.executiveSummary.customizationsFound}`);\n    console.log(`   - Update complexity: ${mergeReport.executiveSummary.updateComplexity}`);\n    console.log(`   - Risk level: ${mergeReport.executiveSummary.riskLevel}`);\n    console.log(`   - Recommendations: ${mergeReport.recommendations.length}\\n`);\n    \n    // Test 9: Performance and statistics\n    console.log('10. Testing performance and statistics...');\n    \n    const stats = analyzer.stats;\n    console.log(`✅ Analyzer statistics:`);\n    console.log(`   - Documents analyzed: ${stats.documentsAnalyzed}`);\n    console.log(`   - Customizations detected: ${stats.customizationsDetected}`);\n    console.log(`   - Update strategies generated: ${stats.updateStrategiesGenerated}`);\n    console.log(`   - Merge conflicts: ${stats.mergeConflicts}`);\n    console.log(`   - Preserved user content: ${stats.preservedUserContent}`);\n    console.log(`   - Analysis time: ${stats.analysisTime}ms\\n`);\n    \n    // Test 10: Event system\n    console.log('11. Testing event system...');\n    \n    let eventCount = 0;\n    analyzer.on('customizations-detected', () => eventCount++);\n    analyzer.on('strategy-calculated', () => eventCount++);\n    analyzer.on('content-preserved', () => eventCount++);\n    \n    // Trigger some events by running operations again\n    await analyzer.detectCustomizations(sampleDoc);\n    await analyzer.calculateUpdateStrategy(existingDoc, newTemplate);\n    \n    console.log(`✅ Event system working - ${eventCount} events fired\\n`);\n    \n    console.log('🎉 All Agent-OS Document Analyzer tests passed successfully!\\n');\n    \n    // Display final summary\n    console.log('📊 Test Summary:');\n    console.log('================');\n    console.log('✅ Document discovery and analysis');\n    console.log('✅ Document type detection'); \n    console.log('✅ Customization detection');\n    console.log('✅ Custom section extraction');\n    console.log('✅ Document comparison');\n    console.log('✅ Update strategy calculation');\n    console.log('✅ User content preservation');\n    console.log('✅ Merge report generation');\n    console.log('✅ Performance tracking');\n    console.log('✅ Event system integration');\n    console.log('');\n    console.log('🔧 Component ready for production use!');\n    \n    // Cleanup\n    await sharedMemory.shutdown();\n    \n  } catch (error) {\n    console.error('❌ Test failed:', error.message);\n    console.error(error.stack);\n    process.exit(1);\n  }\n}\n\n// Run tests if this file is executed directly\nif (require.main === module) {\n  testAgentOSDocumentAnalyzer().catch(error => {\n    console.error('Test execution failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { testAgentOSDocumentAnalyzer };",
          "size": 9498,
          "lastModified": "2025-08-13T17:47:48.608Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "testAgentOSDocumentAnalyzer",
                "position": 401
              }
            ],
            "classes": [],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/test-phase3-implementation.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/test-phase3-implementation.js",
          "fileName": "test-phase3-implementation.js",
          "extension": "js",
          "type": "javascript",
          "content": "#!/usr/bin/env node\n\n/**\n * Phase 3 Implementation Test Suite\n * Tests all Phase 3 components for the MASTER-WORKFLOW v3.0\n * \n * Tests:\n * - Deep Codebase Analyzer\n * - All 8 Analysis Engines\n * - Document Generator v2\n * - Interactive Components\n * - CLAUDE.md Generator\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n// const chalk = require('chalk');\n\n// Import Phase 3 components\nconst DeepCodebaseAnalyzer = require('./deep-codebase-analyzer');\nconst DocumentGeneratorV2 = require('./document-generator-v2');\nconst ClaudeMdGenerator = require('./claude-md-generator');\nconst InteractiveUpdater = require('./interactive-updater');\nconst CustomizationManager = require('./customization-manager');\nconst DocumentVersioning = require('./document-versioning');\nconst EnhancedTemplateEngine = require('./enhanced-template-engine');\n\n// Import Phase 1-2 components for integration testing\nconst SharedMemoryStore = require('./shared-memory');\nconst QueenController = require('./queen-controller');\nconst AgentCommunication = require('./agent-communication');\n\n// Test utilities\nconst testResults = {\n  passed: [],\n  failed: [],\n  skipped: []\n};\n\nasync function test(name, testFn) {\n  try {\n    console.log(`Testing: ${name}...`);\n    await testFn();\n    testResults.passed.push(name);\n    console.log(`  ✅ ${name} passed`);\n  } catch (error) {\n    testResults.failed.push({ name, error: error.message });\n    console.log(`  ❌ ${name} failed: ${error.message}`);\n  }\n}\n\nasync function testAsync(name, testFn, timeout = 5000) {\n  return new Promise(async (resolve) => {\n    const timer = setTimeout(() => {\n      testResults.skipped.push(`${name} (timeout)`);\n      console.log(`  ⏭️  ${name} skipped (timeout)`);\n      resolve();\n    }, timeout);\n    \n    try {\n      await test(name, testFn);\n    } finally {\n      clearTimeout(timer);\n      resolve();\n    }\n  });\n}\n\n// Test Suite\nasync function runPhase3Tests() {\n  console.log('\\n🧪 Phase 3 Implementation Test Suite\\n');\n  console.log('Testing all Phase 3 components...\\n');\n  \n  // Initialize shared components\n  const sharedMemory = new SharedMemoryStore();\n  const queenController = new QueenController();\n  const agentCommunication = new AgentCommunication();\n  \n  // Test 1: Deep Codebase Analyzer\n  await test('Deep Codebase Analyzer initialization', async () => {\n    const analyzer = new DeepCodebaseAnalyzer({\n      sharedMemory,\n      queenController,\n      agentCommunication\n    });\n    \n    if (!analyzer.patternEngine) throw new Error('Pattern engine not initialized');\n    if (!analyzer.architectureEngine) throw new Error('Architecture engine not initialized');\n    if (!analyzer.businessLogicEngine) throw new Error('Business logic engine not initialized');\n    if (!analyzer.apiEngine) throw new Error('API engine not initialized');\n    if (!analyzer.databaseEngine) throw new Error('Database engine not initialized');\n    if (!analyzer.testEngine) throw new Error('Test engine not initialized');\n    if (!analyzer.securityEngine) throw new Error('Security engine not initialized');\n    if (!analyzer.performanceEngine) throw new Error('Performance engine not initialized');\n  });\n  \n  // Test 2: Analysis Engines existence\n  await test('All 8 Analysis Engines exist', async () => {\n    const enginesDir = path.join(__dirname, 'analysis-engines');\n    const expectedEngines = [\n      'pattern-detection-engine.js',\n      'architecture-detection-engine.js',\n      'business-logic-extractor.js',\n      'api-analysis-engine.js',\n      'database-analysis-engine.js',\n      'test-analysis-engine.js',\n      'security-analysis-engine.js',\n      'performance-analysis-engine.js'\n    ];\n    \n    for (const engine of expectedEngines) {\n      const enginePath = path.join(enginesDir, engine);\n      try {\n        await fs.access(enginePath);\n      } catch {\n        throw new Error(`Engine ${engine} not found`);\n      }\n    }\n  });\n  \n  // Test 3: Analysis Engines can be imported\n  await test('All Analysis Engines can be imported', async () => {\n    const engines = [\n      'pattern-detection-engine',\n      'architecture-detection-engine',\n      'business-logic-extractor',\n      'api-analysis-engine',\n      'database-analysis-engine',\n      'test-analysis-engine',\n      'security-analysis-engine',\n      'performance-analysis-engine'\n    ];\n    \n    for (const engine of engines) {\n      const EngineCons = require(`./analysis-engines/${engine}`);\n      const instance = new EngineCons(sharedMemory);\n      if (!instance) throw new Error(`Failed to instantiate ${engine}`);\n    }\n  });\n  \n  // Test 4: Document Generator v2 initialization\n  await test('Document Generator v2 initialization', async () => {\n    const generator = new DocumentGeneratorV2({\n      sharedMemory,\n      queenController,\n      agentCommunication\n    });\n    \n    if (!generator.interactiveUpdater) throw new Error('Interactive updater not initialized');\n    if (!generator.customizationManager) throw new Error('Customization manager not initialized');\n    if (!generator.versionManager) throw new Error('Version manager not initialized');\n    if (!generator.templateEngine) throw new Error('Template engine not initialized');\n  });\n  \n  // Test 5: Interactive Components\n  await test('Interactive Components initialization', async () => {\n    const updater = new InteractiveUpdater(sharedMemory);\n    const customizationMgr = new CustomizationManager(sharedMemory);\n    const versionMgr = new DocumentVersioning(sharedMemory);\n    const templateEngine = new EnhancedTemplateEngine(sharedMemory);\n    \n    if (!updater.sharedMemory) throw new Error('Interactive updater shared memory not set');\n    if (!customizationMgr.sharedMemory) throw new Error('Customization manager shared memory not set');\n    if (!versionMgr.sharedMemory) throw new Error('Version manager shared memory not set');\n    if (!templateEngine.sharedMemory) throw new Error('Template engine shared memory not set');\n  });\n  \n  // Test 6: CLAUDE.md Generator initialization\n  await test('CLAUDE.md Generator initialization', async () => {\n    const generator = new ClaudeMdGenerator({\n      sharedMemory,\n      agentCommunication\n    });\n    \n    if (!generator.mcpServerCategories) throw new Error('MCP server categories not defined');\n    if (!generator.subAgents) throw new Error('Sub-agents not defined');\n    if (generator.subAgents.length !== 10) throw new Error('Should have 10 sub-agents');\n    \n    // Check MCP server count\n    let totalServers = 0;\n    for (const category of Object.values(generator.mcpServerCategories)) {\n      totalServers += category.length;\n    }\n    if (totalServers < 80) throw new Error(`Only ${totalServers} MCP servers defined, expected 87+`);\n  });\n  \n  // Test 7: Deep Analysis Methods\n  await testAsync('Deep Analysis methods exist', async () => {\n    const analyzer = new DeepCodebaseAnalyzer({\n      sharedMemory,\n      queenController,\n      agentCommunication\n    });\n    \n    const methods = [\n      'analyzeComplete',\n      'extractPatterns',\n      'detectArchitecture',\n      'extractBusinessLogic',\n      'detectAPIs',\n      'analyzeDatabases',\n      'analyzeTests',\n      'scanSecurity',\n      'identifyBottlenecks'\n    ];\n    \n    for (const method of methods) {\n      if (typeof analyzer[method] !== 'function') {\n        throw new Error(`Method ${method} not found`);\n      }\n    }\n  });\n  \n  // Test 8: Document Generator Interactive Methods\n  await test('Document Generator interactive methods exist', async () => {\n    const generator = new DocumentGeneratorV2({\n      sharedMemory,\n      queenController,\n      agentCommunication\n    });\n    \n    const methods = [\n      'generateDocumentsInteractive',\n      'interactiveUpdateMode',\n      'createUpdatePlan',\n      'presentUpdateOptions',\n      'showDiffPreview',\n      'updateDocuments'\n    ];\n    \n    for (const method of methods) {\n      if (typeof generator[method] !== 'function') {\n        throw new Error(`Method ${method} not found`);\n      }\n    }\n  });\n  \n  // Test 9: CLAUDE.md Generator Methods\n  await test('CLAUDE.md Generator methods exist', async () => {\n    const generator = new ClaudeMdGenerator({\n      sharedMemory,\n      agentCommunication\n    });\n    \n    const methods = [\n      'generate',\n      'determineProjectConfig',\n      'autoDetectMCPServers',\n      'autoAssignAgents',\n      'generateCustomInstructions',\n      'generateContent'\n    ];\n    \n    for (const method of methods) {\n      if (typeof generator[method] !== 'function') {\n        throw new Error(`Method ${method} not found`);\n      }\n    }\n  });\n  \n  // Test 10: Pattern Detection Engine functionality\n  await testAsync('Pattern Detection Engine can detect patterns', async () => {\n    const PatternEngine = require('./analysis-engines/pattern-detection-engine');\n    const engine = new PatternEngine(sharedMemory);\n    \n    const testCode = `\n      class Singleton {\n        constructor() {\n          if (Singleton.instance) {\n            return Singleton.instance;\n          }\n          Singleton.instance = this;\n        }\n      }\n    `;\n    \n    const patterns = await engine.detectDesignPatterns([\n      { path: 'test.js', content: testCode }\n    ]);\n    \n    if (!patterns || patterns.length === 0) {\n      throw new Error('No patterns detected');\n    }\n  });\n  \n  // Test 11: Architecture Detection\n  await testAsync('Architecture Detection Engine functionality', async () => {\n    const ArchEngine = require('./analysis-engines/architecture-detection-engine');\n    const engine = new ArchEngine(sharedMemory);\n    \n    const result = await engine.detectArchitecture('.');\n    \n    if (!result.type) throw new Error('Architecture type not detected');\n    if (typeof result.confidence !== 'number') throw new Error('Confidence score not calculated');\n  });\n  \n  // Test 12: Customization Manager detection\n  await test('Customization Manager can detect customizations', async () => {\n    const manager = new CustomizationManager(sharedMemory);\n    \n    const original = '# Title\\nOriginal content';\n    const modified = '# Title\\nOriginal content\\n<!-- User custom comment -->';\n    \n    const customizations = await manager.detectCustomizations(original, modified);\n    \n    if (!Array.isArray(customizations)) {\n      throw new Error('Customizations should be an array');\n    }\n  });\n  \n  // Test 13: Document Versioning\n  await testAsync('Document Versioning can create snapshots', async () => {\n    const versioning = new DocumentVersioning(sharedMemory);\n    \n    const testPath = 'test-doc.md';\n    const testContent = '# Test Document\\nContent here';\n    \n    const version = await versioning.createSnapshot(testPath, testContent);\n    \n    if (!version || !version.id) {\n      throw new Error('Version not created properly');\n    }\n  });\n  \n  // Test 14: Template Engine compilation\n  await test('Template Engine can compile templates', async () => {\n    const engine = new EnhancedTemplateEngine(sharedMemory);\n    \n    const template = 'Hello {{name}}!';\n    const data = { name: 'World' };\n    \n    const result = await engine.render(template, data);\n    \n    if (result !== 'Hello World!') {\n      throw new Error(`Template rendering failed: got \"${result}\"`);\n    }\n  });\n  \n  // Test 15: Integration with SharedMemory\n  await testAsync('Components integrate with SharedMemory', async () => {\n    const analyzer = new DeepCodebaseAnalyzer({ sharedMemory });\n    \n    // Store test data\n    await sharedMemory.set('test:phase3', { data: 'test' });\n    \n    // Retrieve test data\n    const retrieved = await sharedMemory.get('test:phase3');\n    \n    if (!retrieved || retrieved.data !== 'test') {\n      throw new Error('SharedMemory integration failed');\n    }\n  });\n  \n  // Test 16: Event emission\n  await testAsync('Components emit events correctly', async () => {\n    const analyzer = new DeepCodebaseAnalyzer({ sharedMemory });\n    \n    let eventFired = false;\n    analyzer.on('analysis-complete', () => {\n      eventFired = true;\n    });\n    \n    analyzer.emit('analysis-complete', { test: true });\n    \n    // Give time for event to fire\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    if (!eventFired) {\n      throw new Error('Event not emitted/received');\n    }\n  });\n  \n  // Print results\n  console.log('\\n📊 Test Results Summary\\n');\n  console.log(`✅ Passed: ${testResults.passed.length}`);\n  console.log(`❌ Failed: ${testResults.failed.length}`);\n  console.log(`⏭️  Skipped: ${testResults.skipped.length}`);\n  \n  if (testResults.failed.length > 0) {\n    console.log('\\nFailed Tests:');\n    testResults.failed.forEach(({ name, error }) => {\n      console.log(`  - ${name}: ${error}`);\n    });\n  }\n  \n  if (testResults.skipped.length > 0) {\n    console.log('\\nSkipped Tests:');\n    testResults.skipped.forEach(name => {\n      console.log(`  - ${name}`);\n    });\n  }\n  \n  // Calculate pass rate\n  const total = testResults.passed.length + testResults.failed.length + testResults.skipped.length;\n  const passRate = Math.round((testResults.passed.length / total) * 100);\n  \n  console.log(`\\n📈 Pass Rate: ${passRate}%`);\n  \n  if (passRate >= 80) {\n    console.log('\\n✨ Phase 3 Implementation Test Suite PASSED!\\n');\n  } else {\n    console.log('\\n⚠️  Phase 3 Implementation needs attention\\n');\n  }\n  \n  return passRate;\n}\n\n// Run tests if executed directly\nif (require.main === module) {\n  runPhase3Tests()\n    .then(passRate => {\n      process.exit(passRate >= 80 ? 0 : 1);\n    })\n    .catch(error => {\n      console.error('Test suite failed:', error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = { runPhase3Tests };",
          "size": 13608,
          "lastModified": "2025-08-13T16:43:00.982Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "test",
                "position": 1174
              },
              {
                "name": "testAsync",
                "position": 1497
              },
              {
                "name": "runPhase3Tests",
                "position": 1910
              }
            ],
            "classes": [
              {
                "name": "Singleton",
                "position": 8890
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/test-shared-memory.js": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/test-shared-memory.js",
          "fileName": "test-shared-memory.js",
          "extension": "js",
          "type": "javascript",
          "content": "/**\n * Test Suite for SharedMemoryStore\n * \n * Comprehensive testing of the shared memory implementation including:\n * - Basic CRUD operations\n * - Cross-agent data sharing\n * - Context preservation\n * - Result caching and retrieval\n * - State synchronization\n * - Memory versioning\n * - Pub/Sub notifications\n * - Garbage collection\n * - Performance optimization\n * \n * @author Claude Code\n * @date August 2025\n */\n\nconst SharedMemoryStore = require('./shared-memory');\nconst path = require('path');\nconst fs = require('fs').promises;\n\nclass SharedMemoryTester {\n  constructor() {\n    this.testResults = [];\n    this.memoryStore = null;\n    this.testProjectRoot = path.join(__dirname, '..', 'test-data');\n  }\n  \n  /**\n   * Run all tests\n   */\n  async runAllTests() {\n    console.log('🧪 Starting SharedMemoryStore Test Suite...\\n');\n    \n    try {\n      await this.setupTestEnvironment();\n      \n      // Core functionality tests\n      await this.testBasicOperations();\n      await this.testNamespaceOperations();\n      await this.testDataTypes();\n      await this.testTTLAndExpiration();\n      \n      // Advanced features\n      await this.testVersioning();\n      await this.testAtomicOperations();\n      await this.testPubSubSystem();\n      await this.testLockingMechanism();\n      \n      // Cross-agent functionality\n      await this.testCrossAgentSharing();\n      await this.testContextPreservation();\n      await this.testResultCaching();\n      \n      // Performance and memory management\n      await this.testMemoryLimits();\n      await this.testGarbageCollection();\n      await this.testPerformanceMetrics();\n      \n      // Integration tests\n      await this.testSQLiteIntegration();\n      await this.testFileBasedFallback();\n      \n      await this.cleanupTestEnvironment();\n      \n      this.printTestResults();\n      \n    } catch (error) {\n      console.error('❌ Test suite failed:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Setup test environment\n   */\n  async setupTestEnvironment() {\n    console.log('📋 Setting up test environment...');\n    \n    try {\n      // Create test directory\n      await fs.mkdir(this.testProjectRoot, { recursive: true });\n      \n      // Initialize memory store\n      this.memoryStore = new SharedMemoryStore({\n        projectRoot: this.testProjectRoot,\n        maxMemorySize: 10 * 1024 * 1024, // 10MB for testing\n        maxEntries: 1000,\n        gcInterval: 5000 // 5 seconds for testing\n      });\n      \n      // Wait for initialization\n      await new Promise((resolve) => {\n        this.memoryStore.once('initialized', resolve);\n      });\n      \n      this.addTestResult('Environment Setup', true, 'Test environment initialized successfully');\n      \n    } catch (error) {\n      this.addTestResult('Environment Setup', false, `Setup failed: ${error.message}`);\n      throw error;\n    }\n  }\n  \n  /**\n   * Test basic CRUD operations\n   */\n  async testBasicOperations() {\n    console.log('🔧 Testing basic operations...');\n    \n    try {\n      // Test SET operation\n      const setResult = await this.memoryStore.set('test-key-1', { message: 'Hello, World!' }, {\n        agentId: 'test-agent-1',\n        metadata: { type: 'greeting' }\n      });\n      \n      this.assert(setResult.success, 'SET operation should succeed');\n      this.assert(setResult.version === 1, 'Initial version should be 1');\n      \n      // Test GET operation\n      const getValue = await this.memoryStore.get('test-key-1', { agentId: 'test-agent-1' });\n      this.assert(getValue?.message === 'Hello, World!', 'GET should return correct value');\n      \n      // Test GET with metadata\n      const getWithMetadata = await this.memoryStore.get('test-key-1', { \n        includeMetadata: true,\n        agentId: 'test-agent-1'\n      });\n      \n      this.assert(getWithMetadata.found, 'GET with metadata should find the value');\n      this.assert(getWithMetadata.metadata.agentId === 'test-agent-1', 'Metadata should include agent ID');\n      \n      // Test UPDATE operation\n      await this.memoryStore.set('test-key-1', { message: 'Updated message' }, {\n        agentId: 'test-agent-1'\n      });\n      \n      const updatedValue = await this.memoryStore.get('test-key-1');\n      this.assert(updatedValue?.message === 'Updated message', 'UPDATE should change the value');\n      \n      // Test DELETE operation\n      const deleteResult = await this.memoryStore.delete('test-key-1', { agentId: 'test-agent-1' });\n      this.assert(deleteResult === true, 'DELETE should return true for existing key');\n      \n      const deletedValue = await this.memoryStore.get('test-key-1');\n      this.assert(deletedValue === null, 'GET after DELETE should return null');\n      \n      this.addTestResult('Basic Operations', true, 'All CRUD operations work correctly');\n      \n    } catch (error) {\n      this.addTestResult('Basic Operations', false, `Basic operations failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test namespace operations\n   */\n  async testNamespaceOperations() {\n    console.log('🏷️ Testing namespace operations...');\n    \n    try {\n      // Set values in different namespaces\n      await this.memoryStore.set('config-1', { setting: 'value1' }, {\n        namespace: this.memoryStore.namespaces.CONFIG\n      });\n      \n      await this.memoryStore.set('cache-1', { data: 'cached' }, {\n        namespace: this.memoryStore.namespaces.CACHE\n      });\n      \n      await this.memoryStore.set('temp-1', { temp: 'temporary' }, {\n        namespace: this.memoryStore.namespaces.TEMP\n      });\n      \n      // Test namespace filtering\n      const configKeys = await this.memoryStore.keys({\n        namespace: this.memoryStore.namespaces.CONFIG\n      });\n      \n      this.assert(configKeys.includes('config-1'), 'Config namespace should contain config-1');\n      this.assert(!configKeys.includes('cache-1'), 'Config namespace should not contain cache-1');\n      \n      const cacheKeys = await this.memoryStore.keys({\n        namespace: this.memoryStore.namespaces.CACHE\n      });\n      \n      this.assert(cacheKeys.includes('cache-1'), 'Cache namespace should contain cache-1');\n      this.assert(!cacheKeys.includes('config-1'), 'Cache namespace should not contain config-1');\n      \n      this.addTestResult('Namespace Operations', true, 'Namespace isolation works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Namespace Operations', false, `Namespace operations failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test different data types\n   */\n  async testDataTypes() {\n    console.log('📊 Testing data types...');\n    \n    try {\n      // Test PERSISTENT data type\n      await this.memoryStore.set('persistent-data', { persist: true }, {\n        dataType: this.memoryStore.dataTypes.PERSISTENT\n      });\n      \n      // Test TRANSIENT data type\n      await this.memoryStore.set('transient-data', { temporary: true }, {\n        dataType: this.memoryStore.dataTypes.TRANSIENT\n      });\n      \n      // Test CACHED data type\n      await this.memoryStore.set('cached-data', { cached: true }, {\n        dataType: this.memoryStore.dataTypes.CACHED,\n        ttl: 10000 // 10 seconds\n      });\n      \n      // Verify data types are stored correctly\n      const persistentMeta = await this.memoryStore.get('persistent-data', { includeMetadata: true });\n      this.assert(persistentMeta.metadata.dataType === this.memoryStore.dataTypes.PERSISTENT, \n        'Persistent data type should be stored correctly');\n      \n      const transientMeta = await this.memoryStore.get('transient-data', { includeMetadata: true });\n      this.assert(transientMeta.metadata.dataType === this.memoryStore.dataTypes.TRANSIENT,\n        'Transient data type should be stored correctly');\n      \n      this.addTestResult('Data Types', true, 'All data types work correctly');\n      \n    } catch (error) {\n      this.addTestResult('Data Types', false, `Data type operations failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test TTL and expiration\n   */\n  async testTTLAndExpiration() {\n    console.log('⏰ Testing TTL and expiration...');\n    \n    try {\n      // Set data with short TTL\n      await this.memoryStore.set('expire-soon', { data: 'will expire' }, {\n        ttl: 1000 // 1 second\n      });\n      \n      // Verify data exists immediately\n      const immediateValue = await this.memoryStore.get('expire-soon');\n      this.assert(immediateValue?.data === 'will expire', 'Data should exist immediately after setting');\n      \n      // Wait for expiration\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      // Verify data has expired\n      const expiredValue = await this.memoryStore.get('expire-soon');\n      this.assert(expiredValue === null, 'Data should be null after TTL expiration');\n      \n      this.addTestResult('TTL and Expiration', true, 'TTL expiration works correctly');\n      \n    } catch (error) {\n      this.addTestResult('TTL and Expiration', false, `TTL operations failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test versioning system\n   */\n  async testVersioning() {\n    console.log('📝 Testing versioning system...');\n    \n    try {\n      // Set versioned data\n      const v1Result = await this.memoryStore.set('versioned-key', { version: 1 }, {\n        dataType: this.memoryStore.dataTypes.VERSIONED\n      });\n      \n      this.assert(v1Result.version === 1, 'First version should be 1');\n      \n      // Update versioned data\n      const v2Result = await this.memoryStore.set('versioned-key', { version: 2 }, {\n        dataType: this.memoryStore.dataTypes.VERSIONED\n      });\n      \n      this.assert(v2Result.version === 2, 'Second version should be 2');\n      \n      // Get current version\n      const currentValue = await this.memoryStore.get('versioned-key');\n      this.assert(currentValue?.version === 2, 'Current value should be version 2');\n      \n      // TODO: Add version history retrieval when implemented\n      \n      this.addTestResult('Versioning System', true, 'Version tracking works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Versioning System', false, `Versioning failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test atomic operations\n   */\n  async testAtomicOperations() {\n    console.log('⚛️ Testing atomic operations...');\n    \n    try {\n      // Set initial counter value\n      await this.memoryStore.set('counter', 0, { agentId: 'atomic-test' });\n      \n      // Perform atomic increment\n      const result = await this.memoryStore.atomic('counter', (currentValue) => {\n        return (currentValue || 0) + 1;\n      }, { agentId: 'atomic-test' });\n      \n      this.assert(result === 1, 'Atomic increment should return 1');\n      \n      // Verify counter value\n      const counterValue = await this.memoryStore.get('counter');\n      this.assert(counterValue === 1, 'Counter should be 1 after atomic increment');\n      \n      // Test concurrent atomic operations\n      const promises = [];\n      for (let i = 0; i < 5; i++) {\n        promises.push(\n          this.memoryStore.atomic('counter', (currentValue) => {\n            return currentValue + 1;\n          }, { agentId: `concurrent-${i}` })\n        );\n      }\n      \n      await Promise.all(promises);\n      \n      const finalCounter = await this.memoryStore.get('counter');\n      this.assert(finalCounter === 6, 'Counter should be 6 after 5 concurrent increments');\n      \n      this.addTestResult('Atomic Operations', true, 'Atomic operations work correctly');\n      \n    } catch (error) {\n      this.addTestResult('Atomic Operations', false, `Atomic operations failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test pub/sub system\n   */\n  async testPubSubSystem() {\n    console.log('📡 Testing pub/sub system...');\n    \n    try {\n      let notificationReceived = false;\n      let notificationData = null;\n      \n      // Subscribe to pattern\n      const unsubscribe = this.memoryStore.subscribe('pubsub-*', (event) => {\n        notificationReceived = true;\n        notificationData = event;\n      }, { agentId: 'subscriber-agent' });\n      \n      // Set data that matches pattern\n      await this.memoryStore.set('pubsub-test', { message: 'Hello subscribers!' }, {\n        agentId: 'publisher-agent'\n      });\n      \n      // Wait for notification\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      this.assert(notificationReceived, 'Subscriber should receive notification');\n      this.assert(notificationData?.key === 'pubsub-test', 'Notification should contain correct key');\n      this.assert(notificationData?.eventType === 'set', 'Notification should be for set event');\n      \n      // Test unsubscribe\n      unsubscribe();\n      notificationReceived = false;\n      \n      await this.memoryStore.set('pubsub-test-2', { message: 'Should not notify' });\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      this.assert(!notificationReceived, 'Should not receive notification after unsubscribe');\n      \n      this.addTestResult('Pub/Sub System', true, 'Pub/Sub notifications work correctly');\n      \n    } catch (error) {\n      this.addTestResult('Pub/Sub System', false, `Pub/Sub failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test locking mechanism\n   */\n  async testLockingMechanism() {\n    console.log('🔒 Testing locking mechanism...');\n    \n    try {\n      const key = 'locked-resource';\n      const agentId1 = 'agent-1';\n      const agentId2 = 'agent-2';\n      \n      // Acquire lock\n      const lock = await this.memoryStore.acquireLock(key, agentId1, { timeout: 5000 });\n      this.assert(lock.agentId === agentId1, 'Lock should be held by agent-1');\n      \n      // Try to acquire same lock with different agent (should fail)\n      try {\n        await this.memoryStore.acquireLock(key, agentId2);\n        this.assert(false, 'Second lock acquisition should fail');\n      } catch (lockError) {\n        this.assert(lockError.message.includes('already locked'), 'Should get appropriate lock error');\n      }\n      \n      // Release lock\n      const released = await this.memoryStore.releaseLock(key, agentId1);\n      this.assert(released === true, 'Lock release should succeed');\n      \n      // Now second agent should be able to acquire lock\n      const secondLock = await this.memoryStore.acquireLock(key, agentId2);\n      this.assert(secondLock.agentId === agentId2, 'Second agent should now hold the lock');\n      \n      await this.memoryStore.releaseLock(key, agentId2);\n      \n      this.addTestResult('Locking Mechanism', true, 'Exclusive locking works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Locking Mechanism', false, `Locking failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test cross-agent data sharing\n   */\n  async testCrossAgentSharing() {\n    console.log('🤝 Testing cross-agent data sharing...');\n    \n    try {\n      const agentA = 'analysis-agent';\n      const agentB = 'processing-agent';\n      const sharedKey = 'shared-analysis-results';\n      \n      // Agent A stores analysis results\n      await this.memoryStore.set(sharedKey, {\n        analysisType: 'code-quality',\n        results: {\n          score: 85,\n          issues: ['minor-style-issue'],\n          suggestions: ['improve-comments']\n        },\n        timestamp: Date.now()\n      }, {\n        namespace: this.memoryStore.namespaces.CROSS_AGENT,\n        agentId: agentA,\n        metadata: { sharedWith: [agentB] }\n      });\n      \n      // Agent B retrieves shared results\n      const sharedData = await this.memoryStore.get(sharedKey, {\n        agentId: agentB,\n        includeMetadata: true\n      });\n      \n      this.assert(sharedData.found, 'Agent B should be able to access shared data');\n      this.assert(sharedData.value.results.score === 85, 'Shared data should be intact');\n      this.assert(sharedData.metadata.agentId === agentA, 'Metadata should show original agent');\n      \n      // Test shared state updates\n      await this.memoryStore.set(`${sharedKey}-processed`, {\n        originalAnalysis: sharedData.value,\n        processedBy: agentB,\n        additionalFindings: ['performance-optimization-opportunity'],\n        processed: true\n      }, {\n        namespace: this.memoryStore.namespaces.CROSS_AGENT,\n        agentId: agentB\n      });\n      \n      this.addTestResult('Cross-Agent Sharing', true, 'Cross-agent data sharing works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Cross-Agent Sharing', false, `Cross-agent sharing failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test context preservation\n   */\n  async testContextPreservation() {\n    console.log('💾 Testing context preservation...');\n    \n    try {\n      const agentId = 'context-test-agent';\n      const contextKey = `agent-context-${agentId}`;\n      \n      // Store agent context\n      const context = {\n        currentTask: 'analyze-codebase',\n        progress: 0.6,\n        intermediateResults: [\n          { file: 'app.js', status: 'analyzed' },\n          { file: 'utils.js', status: 'analyzing' }\n        ],\n        sessionData: {\n          startTime: Date.now(),\n          tokensUsed: 15000,\n          maxTokens: 200000\n        }\n      };\n      \n      await this.memoryStore.set(contextKey, context, {\n        namespace: this.memoryStore.namespaces.AGENT_CONTEXT,\n        dataType: this.memoryStore.dataTypes.PERSISTENT,\n        agentId: agentId\n      });\n      \n      // Simulate agent restart - context should be preserved\n      const preservedContext = await this.memoryStore.get(contextKey, {\n        agentId: agentId,\n        includeMetadata: true\n      });\n      \n      this.assert(preservedContext.found, 'Context should be preserved');\n      this.assert(preservedContext.value.currentTask === 'analyze-codebase', 'Task should be preserved');\n      this.assert(preservedContext.value.progress === 0.6, 'Progress should be preserved');\n      this.assert(preservedContext.value.intermediateResults.length === 2, 'Intermediate results should be preserved');\n      \n      // Update context (simulating progress)\n      context.progress = 0.8;\n      context.intermediateResults[1].status = 'analyzed';\n      context.intermediateResults.push({ file: 'config.js', status: 'analyzing' });\n      \n      await this.memoryStore.set(contextKey, context, {\n        namespace: this.memoryStore.namespaces.AGENT_CONTEXT,\n        dataType: this.memoryStore.dataTypes.PERSISTENT,\n        agentId: agentId\n      });\n      \n      const updatedContext = await this.memoryStore.get(contextKey, { agentId: agentId });\n      this.assert(updatedContext.progress === 0.8, 'Updated progress should be preserved');\n      this.assert(updatedContext.intermediateResults.length === 3, 'Updated results should be preserved');\n      \n      this.addTestResult('Context Preservation', true, 'Agent context preservation works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Context Preservation', false, `Context preservation failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test result caching\n   */\n  async testResultCaching() {\n    console.log('🗄️ Testing result caching...');\n    \n    try {\n      const cacheKey = 'expensive-computation-result';\n      \n      // Simulate expensive computation result\n      const computationResult = {\n        input: { algorithm: 'complex-analysis', dataset: 'large-codebase' },\n        output: { \n          complexity: 'high',\n          maintainability: 0.7,\n          recommendations: ['refactor-module-x', 'optimize-algorithm-y']\n        },\n        metadata: {\n          computationTime: 45000, // 45 seconds\n          memoryUsed: '500MB',\n          cacheUntil: Date.now() + (60 * 60 * 1000) // 1 hour\n        }\n      };\n      \n      // Cache the result\n      await this.memoryStore.set(cacheKey, computationResult, {\n        namespace: this.memoryStore.namespaces.CACHE,\n        dataType: this.memoryStore.dataTypes.CACHED,\n        ttl: 60 * 60 * 1000, // 1 hour cache\n        agentId: 'computation-agent'\n      });\n      \n      // Retrieve cached result (should be fast)\n      const startTime = Date.now();\n      const cachedResult = await this.memoryStore.get(cacheKey, {\n        agentId: 'requesting-agent'\n      });\n      const retrievalTime = Date.now() - startTime;\n      \n      this.assert(cachedResult !== null, 'Cached result should be retrievable');\n      this.assert(cachedResult.output.complexity === 'high', 'Cached data should be intact');\n      this.assert(retrievalTime < 100, 'Cache retrieval should be fast (< 100ms)');\n      \n      // Test cache key pattern matching\n      const cacheKeys = await this.memoryStore.keys({\n        namespace: this.memoryStore.namespaces.CACHE,\n        pattern: 'expensive-.*'\n      });\n      \n      this.assert(cacheKeys.includes(cacheKey), 'Cache key should be found by pattern');\n      \n      this.addTestResult('Result Caching', true, 'Result caching and retrieval work correctly');\n      \n    } catch (error) {\n      this.addTestResult('Result Caching', false, `Result caching failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test memory limits and enforcement\n   */\n  async testMemoryLimits() {\n    console.log('📏 Testing memory limits...');\n    \n    try {\n      // Get current memory usage\n      const initialStats = this.memoryStore.getStats();\n      const initialMemoryUsage = initialStats.memoryUsage;\n      \n      // Try to add data within limits\n      const smallData = { data: 'small data chunk' };\n      await this.memoryStore.set('small-data', smallData);\n      \n      // Add larger data chunks approaching the limit\n      const largeDataChunk = 'x'.repeat(1024 * 1024); // 1MB string\n      \n      for (let i = 0; i < 8; i++) { // Add 8MB of data\n        await this.memoryStore.set(`large-data-${i}`, { chunk: largeDataChunk });\n      }\n      \n      const afterLargeStats = this.memoryStore.getStats();\n      this.assert(afterLargeStats.memoryUsage > initialMemoryUsage, 'Memory usage should increase');\n      \n      // Try to exceed memory limit (should trigger eviction or fail)\n      try {\n        const veryLargeChunk = 'x'.repeat(5 * 1024 * 1024); // 5MB\n        await this.memoryStore.set('very-large-data', { chunk: veryLargeChunk });\n        \n        // If we reach here, eviction should have occurred\n        const finalStats = this.memoryStore.getStats();\n        this.assert(finalStats.evictions > 0, 'Memory limit enforcement should trigger evictions');\n        \n      } catch (memoryError) {\n        // This is acceptable - memory limit exceeded\n        this.assert(memoryError.message.includes('Memory limit exceeded'), 'Should get memory limit error');\n      }\n      \n      this.addTestResult('Memory Limits', true, 'Memory limit enforcement works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Memory Limits', false, `Memory limit testing failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test garbage collection\n   */\n  async testGarbageCollection() {\n    console.log('🗑️ Testing garbage collection...');\n    \n    try {\n      const initialStats = this.memoryStore.getStats();\n      const initialGCRuns = initialStats.gcRuns;\n      \n      // Add some data with short TTL\n      for (let i = 0; i < 10; i++) {\n        await this.memoryStore.set(`gc-test-${i}`, { data: `test data ${i}` }, {\n          ttl: 500 // 500ms TTL\n        });\n      }\n      \n      // Wait for TTL to expire and GC to run\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      // Check if garbage collection occurred\n      const afterGCStats = this.memoryStore.getStats();\n      this.assert(afterGCStats.gcRuns > initialGCRuns, 'Garbage collection should have run');\n      \n      // Verify expired data was cleaned up\n      const expiredValue = await this.memoryStore.get('gc-test-0');\n      this.assert(expiredValue === null, 'Expired data should be cleaned up by GC');\n      \n      // Test manual garbage collection\n      await this.memoryStore.runGarbageCollection();\n      \n      const manualGCStats = this.memoryStore.getStats();\n      this.assert(manualGCStats.gcRuns === afterGCStats.gcRuns + 1, 'Manual GC should increment run count');\n      \n      this.addTestResult('Garbage Collection', true, 'Garbage collection works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Garbage Collection', false, `Garbage collection failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test performance metrics\n   */\n  async testPerformanceMetrics() {\n    console.log('📊 Testing performance metrics...');\n    \n    try {\n      const initialStats = this.memoryStore.getStats();\n      \n      // Perform multiple operations to generate metrics\n      for (let i = 0; i < 100; i++) {\n        await this.memoryStore.set(`perf-test-${i}`, { index: i });\n        await this.memoryStore.get(`perf-test-${i}`);\n      }\n      \n      const finalStats = this.memoryStore.getStats();\n      \n      // Verify metrics were tracked\n      this.assert(finalStats.reads > initialStats.reads, 'Read count should increase');\n      this.assert(finalStats.writes > initialStats.writes, 'Write count should increase');\n      this.assert(finalStats.hits > initialStats.hits, 'Cache hits should increase');\n      \n      // Check performance averages\n      this.assert(finalStats.averageReadTime >= 0, 'Average read time should be tracked');\n      this.assert(finalStats.averageWriteTime >= 0, 'Average write time should be tracked');\n      \n      // Check cache hit rate\n      this.assert(finalStats.cacheHitRate.includes('%'), 'Cache hit rate should be a percentage');\n      \n      this.addTestResult('Performance Metrics', true, 'Performance metrics tracking works correctly');\n      \n    } catch (error) {\n      this.addTestResult('Performance Metrics', false, `Performance metrics failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test SQLite integration\n   */\n  async testSQLiteIntegration() {\n    console.log('🗃️ Testing SQLite integration...');\n    \n    try {\n      const dbStatus = this.memoryStore.dbStatus;\n      \n      if (dbStatus.available) {\n        // Test SQLite persistence\n        await this.memoryStore.set('sqlite-test', { persistent: true }, {\n          dataType: this.memoryStore.dataTypes.PERSISTENT\n        });\n        \n        // Verify data is in SQLite (by attempting to get it after clearing cache)\n        this.memoryStore.memoryCache.clear();\n        \n        const persistedValue = await this.memoryStore.get('sqlite-test');\n        this.assert(persistedValue?.persistent === true, 'Data should persist in SQLite');\n        \n        this.addTestResult('SQLite Integration', true, 'SQLite persistence works correctly');\n        \n      } else {\n        // SQLite not available, test file-based fallback\n        this.assert(dbStatus.fallback === 'file_based', 'Should fallback to file-based storage');\n        \n        this.addTestResult('SQLite Integration', true, 'File-based fallback configured correctly');\n      }\n      \n    } catch (error) {\n      this.addTestResult('SQLite Integration', false, `SQLite integration failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Test file-based fallback\n   */\n  async testFileBasedFallback() {\n    console.log('📁 Testing file-based fallback...');\n    \n    try {\n      // Force save to files\n      await this.memoryStore.saveToFiles();\n      \n      // Check if backup files were created\n      const hiveMindPath = path.join(this.testProjectRoot, '.hive-mind');\n      const memoryFile = path.join(hiveMindPath, 'shared-memory.json');\n      \n      try {\n        const stats = await fs.stat(memoryFile);\n        this.assert(stats.isFile(), 'Memory file should be created');\n        \n        // Verify file content\n        const fileContent = await fs.readFile(memoryFile, 'utf-8');\n        const parsed = JSON.parse(fileContent);\n        \n        this.assert(parsed.entries && typeof parsed.entries === 'object', 'File should contain entries');\n        this.assert(parsed.metadata && typeof parsed.metadata === 'object', 'File should contain metadata');\n        this.assert(typeof parsed.timestamp === 'number', 'File should contain timestamp');\n        \n        this.addTestResult('File-Based Fallback', true, 'File-based persistence works correctly');\n        \n      } catch (fileError) {\n        this.addTestResult('File-Based Fallback', false, `File operations failed: ${fileError.message}`);\n      }\n      \n    } catch (error) {\n      this.addTestResult('File-Based Fallback', false, `File-based fallback failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Cleanup test environment\n   */\n  async cleanupTestEnvironment() {\n    console.log('🧹 Cleaning up test environment...');\n    \n    try {\n      if (this.memoryStore) {\n        await this.memoryStore.shutdown();\n      }\n      \n      // Clean up test files\n      try {\n        await fs.rm(this.testProjectRoot, { recursive: true, force: true });\n      } catch (cleanupError) {\n        console.warn('Warning: Could not fully clean up test directory:', cleanupError.message);\n      }\n      \n      this.addTestResult('Environment Cleanup', true, 'Test environment cleaned up successfully');\n      \n    } catch (error) {\n      this.addTestResult('Environment Cleanup', false, `Cleanup failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Add test result\n   */\n  addTestResult(testName, passed, message) {\n    this.testResults.push({\n      test: testName,\n      passed,\n      message,\n      timestamp: Date.now()\n    });\n  }\n  \n  /**\n   * Assert helper\n   */\n  assert(condition, message) {\n    if (!condition) {\n      throw new Error(`Assertion failed: ${message}`);\n    }\n  }\n  \n  /**\n   * Print test results summary\n   */\n  printTestResults() {\n    console.log('\\n📋 Test Results Summary');\n    console.log('='.repeat(50));\n    \n    let passed = 0;\n    let failed = 0;\n    \n    for (const result of this.testResults) {\n      const status = result.passed ? '✅ PASS' : '❌ FAIL';\n      console.log(`${status} ${result.test}: ${result.message}`);\n      \n      if (result.passed) {\n        passed++;\n      } else {\n        failed++;\n      }\n    }\n    \n    console.log('='.repeat(50));\n    console.log(`Total Tests: ${this.testResults.length}`);\n    console.log(`Passed: ${passed}`);\n    console.log(`Failed: ${failed}`);\n    console.log(`Success Rate: ${((passed / this.testResults.length) * 100).toFixed(1)}%`);\n    \n    if (failed === 0) {\n      console.log('\\n🎉 All tests passed! SharedMemoryStore is working correctly.');\n    } else {\n      console.log(`\\n⚠️ ${failed} test(s) failed. Please review the implementation.`);\n    }\n  }\n}\n\n// Run tests if called directly\nif (require.main === module) {\n  const tester = new SharedMemoryTester();\n  tester.runAllTests().catch(error => {\n    console.error('Test execution failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = SharedMemoryTester;",
          "size": 30730,
          "lastModified": "2025-08-13T02:12:33.961Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [],
            "classes": [
              {
                "name": "SharedMemoryTester",
                "position": 537
              }
            ],
            "imports": [],
            "exports": [],
            "variables": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "imports": [],
          "exports": [],
          "classes": [],
          "functions": []
        },
        "/workspaces/MASTER-WORKFLOW/intelligence-engine/user-choice-handler.sh": {
          "path": "/workspaces/MASTER-WORKFLOW/intelligence-engine/user-choice-handler.sh",
          "fileName": "user-choice-handler.sh",
          "extension": "sh",
          "type": "shell",
          "content": "#!/bin/bash\n\n# User Choice Handler for Intelligent Workflow Decision System\n# Provides interactive selection of Claude Flow approaches with AI guidance\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nMAGENTA='\\033[0;35m'\nCYAN='\\033[0;36m'\nNC='\\033[0m' # No Color\nBOLD='\\033[1m'\n\n# Configuration\nINTELLIGENCE_ENGINE_DIR=\"$(dirname \"$0\")\"\nAI_DEV_HOME=\"$HOME/.ai-dev-os\"\nANALYSIS_CACHE=\"$AI_DEV_HOME/analysis-cache.json\"\n\n# Function to display header\nprint_header() {\n    echo -e \"\\n${BOLD}${BLUE}═══════════════════════════════════════════════════════${NC}\"\n    echo -e \"${BOLD}${CYAN}  $1${NC}\"\n    echo -e \"${BOLD}${BLUE}═══════════════════════════════════════════════════════${NC}\\n\"\n}\n\n# Function to display approach details\nshow_approach_details() {\n    local approach=\"$1\"\n    local match_score=\"$2\"\n    local icon=\"$3\"\n    local name=\"$4\"\n    local description=\"$5\"\n    local time_estimate=\"$6\"\n    local agent_count=\"$7\"\n    local best_for=\"$8\"\n    \n    echo -e \"${BOLD}${icon} ${name}${NC}\"\n    echo -e \"  ${CYAN}Description:${NC} ${description}\"\n    echo -e \"  ${CYAN}Time Estimate:${NC} ${time_estimate}\"\n    echo -e \"  ${CYAN}Agent Count:${NC} ${agent_count}\"\n    echo -e \"  ${CYAN}Match Score:${NC} ${match_score}%\"\n    echo -e \"  ${CYAN}Best For:${NC}\"\n    echo \"$best_for\" | while IFS= read -r line; do\n        echo -e \"    • $line\"\n    done\n    echo \"\"\n}\n\n# Function to analyze project\nanalyze_project() {\n    local project_path=\"${1:-$(pwd)}\"\n    local task_description=\"${2:-}\"\n    \n    echo -e \"${CYAN}🧠 Analyzing project complexity...${NC}\" >&2\n    \n    # Run complexity analyzer\n    local analysis=$(node \"$INTELLIGENCE_ENGINE_DIR/complexity-analyzer.js\" \"$project_path\")\n    \n    if [ $? -ne 0 ]; then\n        echo -e \"${RED}❌ Analysis failed${NC}\"\n        return 1\n    fi\n    \n    # Cache analysis result\n    mkdir -p \"$AI_DEV_HOME\"\n    echo \"$analysis\" > \"$ANALYSIS_CACHE\"\n    \n    # Display analysis summary\n    local score=$(echo \"$analysis\" | jq -r '.score')\n    local stage=$(echo \"$analysis\" | jq -r '.stage')\n    local confidence=$(echo \"$analysis\" | jq -r '.confidence')\n    \n    echo -e \"${GREEN}📊 Analysis Complete!${NC}\" >&2\n    echo -e \"\\n${BOLD}Project Analysis Summary:${NC}\" >&2\n    echo -e \"  ${CYAN}Complexity Score:${NC} ${score}/100\" >&2\n    echo -e \"  ${CYAN}Project Stage:${NC} ${stage}\" >&2\n    echo -e \"  ${CYAN}Analysis Confidence:${NC} ${confidence}%\" >&2\n    \n    # Show detected features if available\n    if [ \"$(echo \"$analysis\" | jq -r '.factors.features')\" != \"null\" ]; then\n        echo -e \"\\n${BOLD}Detected Features:${NC}\" >&2\n        echo \"$analysis\" | jq -r '.factors.features.detected | to_entries[] | select(.value == true) | \"  ✓ \\(.key)\"' >&2\n    fi\n    \n    echo \"$analysis\"\n}\n\n# Function to get approach recommendation\nget_recommendation() {\n    local analysis=\"$1\"\n    local user_choice=\"${2:-}\"\n    local task_description=\"${3:-}\"\n    local claude_flow_version=\"${4:-alpha}\"\n    \n    # Run approach selector with version\n    local temp_analysis=\"/tmp/analysis_$$.json\"\n    echo \"$analysis\" > \"$temp_analysis\"\n    \n    local recommendation=$(node \"$INTELLIGENCE_ENGINE_DIR/approach-selector.js\" \"$temp_analysis\" \"$user_choice\" \"$task_description\" \"$claude_flow_version\")\n    \n    rm -f \"$temp_analysis\"\n    \n    echo \"$recommendation\"\n}\n\n# Function to display interactive menu\nshow_interactive_menu() {\n    local analysis=\"$1\"\n    local task_description=\"${2:-}\"\n    \n    print_header \"🎯 AI Workflow Approach Selection\"\n    \n    # Get AI recommendation\n    local recommendation=$(get_recommendation \"$analysis\" \"\" \"$task_description\")\n    \n    local selected=$(echo \"$recommendation\" | jq -r '.selected')\n    local reasoning=$(echo \"$recommendation\" | jq -r '.reasoning[]' | sed 's/^/  • /')\n    \n    echo -e \"${BOLD}${GREEN}🎯 AI Recommendation:${NC}\"\n    case \"$selected\" in\n        \"simpleSwarm\")\n            echo -e \"${BOLD}⚡ Simple Swarm${NC}\"\n            ;;\n        \"hiveMind\")\n            echo -e \"${BOLD}🐝 Hive-Mind${NC}\"\n            ;;\n        \"hiveMindSparc\")\n            echo -e \"${BOLD}🏛️ Hive-Mind + SPARC${NC}\"\n            ;;\n    esac\n    \n    echo -e \"\\n${CYAN}📋 Reasoning:${NC}\"\n    echo \"$reasoning\"\n    \n    echo -e \"\\n${BOLD}${BLUE}════════════════════════════════════════════════════════${NC}\"\n    echo -e \"\\n${BOLD}Available Approaches:${NC}\\n\"\n    \n    # Display Simple Swarm option (compute match via jq to avoid inline JS injection)\n    local swarm_match=$(printf '%s' \"$recommendation\" | jq -r '(.alternatives[]? | select(.name==\"Simple Swarm\") | .matchScore) // .matchScore // 0')\n    \n    echo -e \"${BOLD}1. ⚡ Simple Swarm${NC}\"\n    echo -e \"   • Best for: Quick prototypes, single features, bug fixes\"\n    echo -e \"   • Time: 5-30 minutes\"\n    echo -e \"   • Resources: Low (1 agent)\"\n    if [ \"$selected\" = \"simpleSwarm\" ]; then\n        echo -e \"   • Match Score: ${GREEN}${swarm_match}% (⭐ RECOMMENDED)${NC}\"\n    else\n        echo -e \"   • Match Score: ${swarm_match}%\"\n    fi\n    echo \"\"\n    \n    # Display Hive-Mind option\n    local hive_match=$(printf '%s' \"$recommendation\" | jq -r '(.alternatives[]? | select(.name==\"Hive-Mind\") | .matchScore) // .matchScore // 0')\n    \n    echo -e \"${BOLD}2. 🐝 Hive-Mind${NC}\"\n    echo -e \"   • Best for: Multi-feature development, coordination\"\n    echo -e \"   • Time: 30 minutes - 4 hours\"\n    echo -e \"   • Resources: Medium (4-6 agents)\"\n    if [ \"$selected\" = \"hiveMind\" ]; then\n        echo -e \"   • Match Score: ${GREEN}${hive_match}% (⭐ RECOMMENDED)${NC}\"\n    else\n        echo -e \"   • Match Score: ${hive_match}%\"\n    fi\n    echo \"\"\n    \n    # Display Hive-Mind + SPARC option\n    local sparc_match=$(printf '%s' \"$recommendation\" | jq -r '(.alternatives[]? | select(.name==\"Hive-Mind + SPARC\") | .matchScore) // .matchScore // 0')\n    \n    echo -e \"${BOLD}3. 🏛️ Hive-Mind + SPARC${NC}\"\n    echo -e \"   • Best for: Enterprise projects, systematic development\"\n    echo -e \"   • Time: 4+ hours\"\n    echo -e \"   • Resources: High (8-12 agents)\"\n    if [ \"$selected\" = \"hiveMindSparc\" ]; then\n        echo -e \"   • Match Score: ${GREEN}${sparc_match}% (⭐ RECOMMENDED)${NC}\"\n    else\n        echo -e \"   • Match Score: ${sparc_match}%\"\n    fi\n    echo \"\"\n    \n    echo -e \"${BOLD}${BLUE}════════════════════════════════════════════════════════${NC}\"\n    echo -e \"\\n${BOLD}Choose your approach:${NC}\"\n    echo -e \"[${BOLD}1${NC}] Simple Swarm  [${BOLD}2${NC}] Hive-Mind  [${BOLD}3${NC}] Hive-Mind + SPARC\"\n    echo -e \"[${BOLD}R${NC}] Use AI Recommendation  [${BOLD}A${NC}] Show More Analysis  [${BOLD}Q${NC}] Quit\"\n    echo -e \"\\n${CYAN}Your choice: ${NC}\"\n}\n\n# Function to show detailed analysis\nshow_detailed_analysis() {\n    local analysis=\"$1\"\n    \n    print_header \"📊 Detailed Project Analysis\"\n    \n    echo -e \"${BOLD}Complexity Factors:${NC}\\n\"\n    \n    # Show all factors with scores\n    for factor in size dependencies architecture techStack features team deployment testing; do\n        local factor_score=$(echo \"$analysis\" | jq -r \".factors.$factor.score // 0\")\n        local factor_desc=$(echo \"$analysis\" | jq -r \".factors.$factor.description // 'N/A'\")\n        \n        # Determine color based on score\n        local color=\"\"\n        if [ \"$factor_score\" -lt 30 ]; then\n            color=\"${GREEN}\"\n        elif [ \"$factor_score\" -lt 70 ]; then\n            color=\"${YELLOW}\"\n        else\n            color=\"${RED}\"\n        fi\n        \n        echo -e \"  ${BOLD}$(echo $factor | sed 's/.*/\\u&/'):${NC}\"\n        echo -e \"    Score: ${color}${factor_score}/100${NC}\"\n        echo -e \"    Details: ${factor_desc}\"\n        echo \"\"\n    done\n    \n    echo -e \"${CYAN}Press Enter to continue...${NC}\"\n    read\n}\n\n# Function to confirm user choice\nconfirm_choice() {\n    local approach_key=\"$1\"\n    local analysis=\"$2\"\n    local recommendation=\"$3\"\n    \n    echo -e \"\\n${BOLD}${BLUE}════════════════════════════════════════════════════════${NC}\"\n    echo -e \"\\n${BOLD}📋 Setup Summary:${NC}\"\n    \n    local name=$(echo \"$recommendation\" | jq -r '.name')\n    local time=$(echo \"$recommendation\" | jq -r '.timeEstimate')\n    local agents=$(echo \"$recommendation\" | jq -r '.agentCount')\n    local command=$(echo \"$recommendation\" | jq -r '.command')\n    \n    echo -e \"  ${CYAN}Approach:${NC} $name\"\n    echo -e \"  ${CYAN}Estimated Time:${NC} $time\"\n    echo -e \"  ${CYAN}Agent Count:${NC} $agents\"\n    echo -e \"  ${CYAN}Command:${NC} $command\"\n    \n    # Show warning if there's a mismatch\n    if [ \"$(echo \"$recommendation\" | jq -r '.mismatch')\" = \"true\" ]; then\n        echo -e \"\\n${YELLOW}⚠️  Warning: Choice doesn't match AI recommendation${NC}\"\n        echo \"$recommendation\" | jq -r '.warning.messages[]' | while IFS= read -r msg; do\n            echo -e \"  ${YELLOW}• $msg${NC}\"\n        done\n    fi\n    \n    echo -e \"\\n${CYAN}Proceed with this setup? (Y/n): ${NC}\"\n    read -n 1 confirm\n    echo \"\"\n    \n    case \"$confirm\" in\n        n|N)\n            echo -e \"${YELLOW}🔄 Let's choose again...${NC}\"\n            return 1\n            ;;\n        *)\n            return 0\n            ;;\n    esac\n}\n\n# Function to execute selected approach\nexecute_approach() {\n    local recommendation=\"$1\"\n    local project_path=\"${2:-$(pwd)}\"\n    \n    local approach=$(echo \"$recommendation\" | jq -r '.selected')\n    local command=$(echo \"$recommendation\" | jq -r '.command')\n    local name=$(echo \"$recommendation\" | jq -r '.name')\n    \n    print_header \"🚀 Initializing $name\"\n    \n    # Save user selection for learning\n    node \"$INTELLIGENCE_ENGINE_DIR/approach-selector.js\" \"$ANALYSIS_CACHE\" \"$approach\" > /dev/null 2>&1\n    \n    # Execute setup steps\n    echo \"$recommendation\" | jq -r '.setupSteps[]' | while IFS= read -r step; do\n        echo -e \"${GREEN}✓${NC} $step\"\n        sleep 0.5\n    done\n    \n    echo -e \"\\n${BOLD}${GREEN}✅ Setup Complete!${NC}\"\n    echo -e \"\\n${CYAN}Ready to execute:${NC}\"\n    echo -e \"${BOLD}$command${NC}\"\n    \n    # Create project configuration\n    mkdir -p \"$project_path/.ai-dev\"\n    echo \"$recommendation\" > \"$project_path/.ai-dev/approach-selection.json\"\n    \n    echo -e \"\\n${CYAN}Next steps:${NC}\"\n    echo -e \"1. Run the command above to start AI coordination\"\n    echo -e \"2. For tmux session: ${BOLD}tmux attach -t ai-dev-session${NC}\"\n    echo -e \"3. Monitor progress in ${BOLD}.ai-dev/logs/${NC}\"\n\n  # Auto-run the recommended command unless disabled\n  if [ \"${AIWF_AUTORUN:-true}\" = \"true\" ]; then\n    echo -e \"\\n${CYAN}Launching now (set AIWF_AUTORUN=false to disable auto-run) ...${NC}\"\n    # Use a login shell to preserve PATH/npx behavior\n    bash -lc \"$command\"\n  else\n    echo -e \"\\n${YELLOW}Auto-run disabled (AIWF_AUTORUN=false). You can run the command manually above.${NC}\"\n  fi\n}\n\n# Main execution function\nmain() {\n    local mode=\"${1:-interactive}\"\n    local task_description=\"${2:-}\"\n    local project_path=\"${3:-$(pwd)}\"\n    local claude_flow_version=\"${CLAUDE_FLOW_VERSION:-alpha}\"  # Can be set via environment variable\n    \n    case \"$mode\" in\n        --auto|--automatic)\n            # Automatic mode - AI decides everything\n            echo -e \"${CYAN}🤖 Automatic mode - AI will select optimal approach${NC}\\n\"\n            \n            local analysis=$(analyze_project \"$project_path\" \"$task_description\")\n            if [ $? -ne 0 ]; then\n                exit 1\n            fi\n            \n            local recommendation=$(get_recommendation \"$analysis\" \"\" \"$task_description\")\n            execute_approach \"$recommendation\" \"$project_path\"\n            ;;\n            \n        --interactive|--choose)\n            # Interactive mode - show options and let user choose\n            local analysis=$(analyze_project \"$project_path\" \"$task_description\")\n            if [ $? -ne 0 ]; then\n                exit 1\n            fi\n            \n            while true; do\n                show_interactive_menu \"$analysis\" \"$task_description\"\n                read -n 1 choice\n                echo \"\"\n                \n                case \"$choice\" in\n                    1)\n                        recommendation=$(get_recommendation \"$analysis\" \"simple-swarm\" \"$task_description\")\n                        if confirm_choice \"simpleSwarm\" \"$analysis\" \"$recommendation\"; then\n                            execute_approach \"$recommendation\" \"$project_path\"\n                            break\n                        fi\n                        ;;\n                    2)\n                        recommendation=$(get_recommendation \"$analysis\" \"hive-mind\" \"$task_description\")\n                        if confirm_choice \"hiveMind\" \"$analysis\" \"$recommendation\"; then\n                            execute_approach \"$recommendation\" \"$project_path\"\n                            break\n                        fi\n                        ;;\n                    3)\n                        recommendation=$(get_recommendation \"$analysis\" \"hive-mind-sparc\" \"$task_description\")\n                        if confirm_choice \"hiveMindSparc\" \"$analysis\" \"$recommendation\"; then\n                            execute_approach \"$recommendation\" \"$project_path\"\n                            break\n                        fi\n                        ;;\n                    r|R)\n                        recommendation=$(get_recommendation \"$analysis\" \"\" \"$task_description\")\n                        local selected=$(echo \"$recommendation\" | jq -r '.selected')\n                        if confirm_choice \"$selected\" \"$analysis\" \"$recommendation\"; then\n                            execute_approach \"$recommendation\" \"$project_path\"\n                            break\n                        fi\n                        ;;\n                    a|A)\n                        show_detailed_analysis \"$analysis\"\n                        ;;\n                    q|Q)\n                        echo -e \"${YELLOW}👋 Setup cancelled${NC}\"\n                        exit 0\n                        ;;\n                    *)\n                        echo -e \"${RED}❌ Invalid choice. Please try again.${NC}\"\n                        sleep 1\n                        ;;\n                esac\n            done\n            ;;\n            \n        --analyze-only|--recommend)\n            # Analysis only mode - show recommendation without executing\n            local analysis=$(analyze_project \"$project_path\" \"$task_description\")\n            if [ $? -ne 0 ]; then\n                exit 1\n            fi\n            \n            local recommendation=$(get_recommendation \"$analysis\" \"\" \"$task_description\")\n            \n            print_header \"📊 Analysis & Recommendation\"\n            echo \"$recommendation\" | jq '.'\n            ;;\n            \n        --swarm|--simple)\n            # Force Simple Swarm\n            echo -e \"${CYAN}⚡ Forcing Simple Swarm approach${NC}\\n\"\n            local analysis=$(analyze_project \"$project_path\" \"$task_description\")\n            local recommendation=$(get_recommendation \"$analysis\" \"simple-swarm\" \"$task_description\")\n            \n            if [ \"$(echo \"$recommendation\" | jq -r '.mismatch')\" = \"true\" ]; then\n                echo -e \"${YELLOW}⚠️  Warning: Simple Swarm may not be optimal for this project${NC}\"\n                if ! confirm_choice \"simpleSwarm\" \"$analysis\" \"$recommendation\"; then\n                    exit 1\n                fi\n            fi\n            \n            execute_approach \"$recommendation\" \"$project_path\"\n            ;;\n            \n        --hive|--hivemind)\n            # Force Hive-Mind\n            echo -e \"${CYAN}🐝 Forcing Hive-Mind approach${NC}\\n\"\n            local analysis=$(analyze_project \"$project_path\" \"$task_description\")\n            local recommendation=$(get_recommendation \"$analysis\" \"hive-mind\" \"$task_description\")\n            \n            if [ \"$(echo \"$recommendation\" | jq -r '.mismatch')\" = \"true\" ]; then\n                echo -e \"${YELLOW}⚠️  Warning: Hive-Mind may not be optimal for this project${NC}\"\n                if ! confirm_choice \"hiveMind\" \"$analysis\" \"$recommendation\"; then\n                    exit 1\n                fi\n            fi\n            \n            execute_approach \"$recommendation\" \"$project_path\"\n            ;;\n            \n        --sparc|--enterprise)\n            # Force Hive-Mind + SPARC\n            echo -e \"${CYAN}🏛️ Forcing Hive-Mind + SPARC approach${NC}\\n\"\n            local analysis=$(analyze_project \"$project_path\" \"$task_description\")\n            local recommendation=$(get_recommendation \"$analysis\" \"hive-mind-sparc\" \"$task_description\")\n            \n            if [ \"$(echo \"$recommendation\" | jq -r '.mismatch')\" = \"true\" ]; then\n                echo -e \"${YELLOW}⚠️  Warning: SPARC may be overkill for this project${NC}\"\n                if ! confirm_choice \"hiveMindSparc\" \"$analysis\" \"$recommendation\"; then\n                    exit 1\n                fi\n            fi\n            \n            execute_approach \"$recommendation\" \"$project_path\"\n            ;;\n            \n        --help|-h)\n            echo \"Usage: $0 [mode] [task-description] [project-path]\"\n            echo \"\"\n            echo \"Modes:\"\n            echo \"  --auto, --automatic     AI selects optimal approach automatically\"\n            echo \"  --interactive, --choose Show analysis and let user choose\"\n            echo \"  --analyze-only         Analyze and show recommendation only\"\n            echo \"  --swarm, --simple      Force Simple Swarm approach\"\n            echo \"  --hive, --hivemind     Force Hive-Mind approach\"\n            echo \"  --sparc, --enterprise  Force Hive-Mind + SPARC approach\"\n            echo \"  --help, -h             Show this help message\"\n            echo \"\"\n            echo \"Examples:\"\n            echo \"  $0 --auto \\\"Build REST API\\\"\"\n            echo \"  $0 --interactive\"\n            echo \"  $0 --sparc \\\"Complex enterprise system\\\"\"\n            ;;\n            \n        *)\n            # Default to interactive mode\n            main \"--interactive\" \"$mode\" \"$task_description\"\n            ;;\n    esac\n}\n\n# Check dependencies\ncheck_dependencies() {\n    if ! command -v node &> /dev/null; then\n        echo -e \"${RED}❌ Node.js is required but not installed${NC}\"\n        exit 1\n    fi\n    \n    if ! command -v jq &> /dev/null; then\n        echo -e \"${RED}❌ jq is required but not installed${NC}\"\n        echo \"Install with: sudo apt-get install jq\"\n        exit 1\n    fi\n    \n    if [ ! -f \"$INTELLIGENCE_ENGINE_DIR/complexity-analyzer.js\" ]; then\n        echo -e \"${RED}❌ complexity-analyzer.js not found${NC}\"\n        exit 1\n    fi\n    \n    if [ ! -f \"$INTELLIGENCE_ENGINE_DIR/approach-selector.js\" ]; then\n        echo -e \"${RED}❌ approach-selector.js not found${NC}\"\n        exit 1\n    fi\n}\n\n# Run dependency check\ncheck_dependencies\n\n# Execute main function\nmain \"$@\"",
          "size": 18704,
          "lastModified": "2025-08-12T21:03:09.988Z",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "isAgentOSManaged": false,
          "agentOSVersion": null,
          "templateVersion": null,
          "customizations": [],
          "structure": {
            "functions": [
              {
                "name": "print_header",
                "position": 495
              },
              {
                "name": "show_approach_details",
                "position": 774
              },
              {
                "name": "analyze_project",
                "position": 1447
              },
              {
                "name": "get_recommendation",
                "position": 2830
              },
              {
                "name": "show_interactive_menu",
                "position": 3389
              },
              {
                "name": "show_detailed_analysis",
                "position": 6690
              },
              {
                "name": "confirm_choice",
                "position": 7748
              },
              {
                "name": "execute_approach",
                "position": 9139
              },
              {
                "name": "main",
                "position": 10755
              },
              {
                "name": "check_dependencies",
                "position": 17959
              }
            ],
            "variables": [
              {
                "name": "RED",
                "position": 173
              },
              {
                "name": "GREEN",
                "position": 190
              },
              {
                "name": "YELLOW",
                "position": 209
              },
              {
                "name": "BLUE",
                "position": 229
              },
              {
                "name": "MAGENTA",
                "position": 247
              },
              {
                "name": "CYAN",
                "position": 268
              },
              {
                "name": "NC",
                "position": 286
              },
              {
                "name": "BOLD",
                "position": 310
              },
              {
                "name": "INTELLIGENCE_ENGINE_DIR",
                "position": 342
              },
              {
                "name": "AI_DEV_HOME",
                "position": 384
              },
              {
                "name": "ANALYSIS_CACHE",
                "position": 415
              }
            ],
            "commands": []
          },
          "metadata": {},
          "analysis": {
            "complexity": "unknown",
            "customizationLevel": "unknown",
            "updateRisk": "unknown"
          },
          "variables": [],
          "functions": [],
          "commands": []
        }
      },
      "recommendations": []
    }
  },
  "metadata": {
    "document-analysis:68da34ca0ed34af3b219f8157d039ec0": {
      "namespace": "cache",
      "dataType": "cached",
      "version": 1,
      "createdAt": 1755107275336,
      "updatedAt": 1755107294118,
      "expiresAt": 1755193694118,
      "accessCount": 0,
      "size": 483180,
      "compressed": false
    }
  },
  "versions": {
    "document-analysis:68da34ca0ed34af3b219f8157d039ec0": 1
  },
  "timestamp": 1755107294250,
  "stats": {
    "reads": 0,
    "writes": 1,
    "hits": 0,
    "misses": 0,
    "evictions": 0,
    "gcRuns": 0,
    "totalMemoryUsed": 966350,
    "averageReadTime": 0,
    "averageWriteTime": 129,
    "concurrentOperations": 0
  }
}