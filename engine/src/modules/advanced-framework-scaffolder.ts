/**
 * Advanced Framework Scaffolding System for Claude Flow 2.0
 * Supports complex, multi-component tech stacks including React/shadcn/Tailwind and Rust/Supabase/PostgreSQL
 * Generated by Claude Code using Frontend Specialist + API Builder + Database Architect Agents
 */

import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { createInterface } from 'readline';
import { UniversalProjectTemplate, TemplateContext, UniversalTechnology } from './universal-scaffolder.js';

const execAsync = promisify(exec);

export interface FrameworkStackTemplate {
  id: string;
  name: string;
  description: string;
  category: 'frontend' | 'backend' | 'fullstack' | 'mobile' | 'desktop';
  complexity: number;
  technologies: string[];
  requirements: {
    node?: string;
    rust?: string;
    python?: string;
    database?: string;
  };
  structure: AdvancedProjectStructure;
  configuration: StackConfiguration;
  installation: InstallationSteps[];
  development: DevelopmentWorkflow;
  deployment: DeploymentWorkflow;
  integrations: IntegrationPoints;
}

export interface AdvancedProjectStructure {
  root: ProjectDirectory;
  subprojects?: Record<string, ProjectDirectory>;
  shared?: ProjectDirectory;
}

export interface ProjectDirectory {
  name: string;
  directories: Record<string, string>;
  files: Record<string, AdvancedFileTemplate>;
  scripts: Record<string, string>;
  dependencies: Record<string, string>;
  devDependencies: Record<string, string>;
}

export interface AdvancedFileTemplate {
  path: string;
  content: string | ((context: TemplateContext) => string);
  executable?: boolean;
  templated: boolean;
  description: string;
  dependencies?: string[];
}

export interface StackConfiguration {
  packageManagers: string[];
  buildTools: string[];
  configFiles: Record<string, any>;
  environmentVariables: Record<string, string>;
  ports: Record<string, number>;
  databases: DatabaseConfiguration[];
  authentication: AuthenticationConfig;
  apis: ApiConfiguration[];
}

export interface DatabaseConfiguration {
  type: 'postgresql' | 'mysql' | 'mongodb' | 'redis' | 'sqlite';
  host: string;
  port: number;
  database: string;
  migrations: string[];
  seedData?: string[];
}

export interface AuthenticationConfig {
  provider: 'supabase' | 'auth0' | 'firebase' | 'custom';
  configuration: Record<string, any>;
  routes: string[];
}

export interface ApiConfiguration {
  framework: 'express' | 'fastapi' | 'axum' | 'gin' | 'aspnet';
  baseUrl: string;
  endpoints: ApiEndpoint[];
  middleware: string[];
  documentation: string;
}

export interface ApiEndpoint {
  path: string;
  method: string;
  description: string;
  authentication: boolean;
  parameters: Parameter[];
  response: ResponseSchema;
}

export interface Parameter {
  name: string;
  type: string;
  required: boolean;
  description: string;
}

export interface ResponseSchema {
  type: string;
  properties: Record<string, any>;
}

export interface InstallationSteps {
  name: string;
  description: string;
  commands: string[];
  platform?: 'windows' | 'macos' | 'linux';
  optional: boolean;
}

export interface DevelopmentWorkflow {
  setup: string[];
  start: string[];
  test: string[];
  build: string[];
  lint: string[];
  format: string[];
}

export interface DeploymentWorkflow {
  platforms: string[];
  containerization: ContainerConfig;
  cicd: CicdConfig;
  environments: EnvironmentConfig[];
}

export interface ContainerConfig {
  dockerfile: string;
  dockerCompose?: string;
  kubernetes?: string;
}

export interface CicdConfig {
  provider: string;
  configuration: string;
  triggers: string[];
  stages: string[];
}

export interface EnvironmentConfig {
  name: string;
  variables: Record<string, string>;
  database: DatabaseConfiguration;
  deployment: Record<string, any>;
}

export interface IntegrationPoints {
  mcpServers: string[];
  agents: string[];
  workflows: string[];
  tools: string[];
  apis: string[];
}

class AdvancedFrameworkScaffolder {
  private templates: Map<string, FrameworkStackTemplate> = new Map();

  constructor() {
    this.initializeTemplates();
  }

  private initializeTemplates() {
    // React + shadcn/ui + Tailwind CSS Stack
    this.registerReactShadcnTailwindTemplate();
    
    // Rust + Supabase + PostgreSQL Stack
    this.registerRustSupabasePostgresTemplate();
    
    // Full-Stack React + Rust Template
    this.registerFullStackReactRustTemplate();
    
    // Next.js + TypeScript + Prisma + Supabase Template
    this.registerNextjsPrismaSupabaseTemplate();
    
    // Vue.js + Nuxt + Tailwind + Supabase Template
    this.registerVueNuxtSupabaseTemplate();
    
    // Svelte + SvelteKit + Tailwind + Supabase Template
    this.registerSvelteKitSupabaseTemplate();
    
    // Flutter + Supabase + Firebase Template
    this.registerFlutterSupabaseTemplate();
    
    // React Native + Expo + Supabase Template
    this.registerReactNativeExpoTemplate();
  }

  private registerReactShadcnTailwindTemplate() {
    const template: FrameworkStackTemplate = {
      id: 'react-shadcn-tailwind',
      name: 'React + shadcn/ui + Tailwind CSS',
      description: 'Modern React application with shadcn/ui components and Tailwind CSS styling',
      category: 'frontend',
      complexity: 7,
      technologies: ['React', 'TypeScript', 'Vite', 'shadcn/ui', 'Tailwind CSS', 'React Router', 'React Hook Form'],
      requirements: {
        node: '>=18.0.0'
      },
      structure: {
        root: {
          name: 'react-app',
          directories: {
            'src': 'Source code directory',
            'src/components': 'React components',
            'src/components/ui': 'shadcn/ui components',
            'src/lib': 'Utility functions and configurations',
            'src/hooks': 'Custom React hooks',
            'src/pages': 'Page components',
            'src/styles': 'CSS and styling files',
            'src/types': 'TypeScript type definitions',
            'public': 'Static assets',
            'docs': 'Documentation'
          },
          files: {
            'package.json': {
              path: 'package.json',
              content: (context) => this.generateReactPackageJson(context),
              templated: true,
              description: 'Node.js package configuration with all dependencies'
            },
            'tsconfig.json': {
              path: 'tsconfig.json',
              content: this.generateTypeScriptConfig(),
              templated: false,
              description: 'TypeScript configuration for React'
            },
            'tailwind.config.js': {
              path: 'tailwind.config.js',
              content: this.generateTailwindConfig(),
              templated: false,
              description: 'Tailwind CSS configuration with shadcn/ui integration'
            },
            'components.json': {
              path: 'components.json',
              content: this.generateShadcnConfig(),
              templated: false,
              description: 'shadcn/ui components configuration'
            },
            'vite.config.ts': {
              path: 'vite.config.ts',
              content: this.generateViteConfig(),
              templated: false,
              description: 'Vite build tool configuration'
            },
            'src/main.tsx': {
              path: 'src/main.tsx',
              content: (context) => this.generateReactMain(context),
              templated: true,
              description: 'React application entry point'
            },
            'src/App.tsx': {
              path: 'src/App.tsx',
              content: (context) => this.generateReactApp(context),
              templated: true,
              description: 'Main React application component'
            },
            'src/lib/utils.ts': {
              path: 'src/lib/utils.ts',
              content: this.generateUtilsFile(),
              templated: false,
              description: 'Utility functions for className merging and more'
            },
            'src/styles/globals.css': {
              path: 'src/styles/globals.css',
              content: this.generateGlobalStyles(),
              templated: false,
              description: 'Global CSS styles with Tailwind imports'
            },
            'index.html': {
              path: 'index.html',
              content: (context) => this.generateIndexHtml(context),
              templated: true,
              description: 'HTML entry point for Vite'
            },
            '.eslintrc.cjs': {
              path: '.eslintrc.cjs',
              content: this.generateEslintConfig(),
              templated: false,
              description: 'ESLint configuration for code quality'
            },
            'README.md': {
              path: 'README.md',
              content: (context) => this.generateReactReadme(context),
              templated: true,
              description: 'Project documentation and setup instructions'
            }
          },
          scripts: {
            'dev': 'vite',
            'build': 'tsc && vite build',
            'lint': 'eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0',
            'preview': 'vite preview',
            'ui:add': 'npx shadcn-ui@latest add',
            'ui:init': 'npx shadcn-ui@latest init'
          },
          dependencies: {
            'react': '^18.2.0',
            'react-dom': '^18.2.0',
            'react-router-dom': '^6.20.0',
            'react-hook-form': '^7.48.0',
            '@hookform/resolvers': '^3.3.0',
            'zod': '^3.22.0',
            'class-variance-authority': '^0.7.0',
            'clsx': '^2.0.0',
            'tailwind-merge': '^2.0.0',
            'lucide-react': '^0.294.0',
            '@radix-ui/react-slot': '^1.0.0',
            '@radix-ui/react-toast': '^1.1.0',
            '@radix-ui/react-dialog': '^1.0.0',
            '@radix-ui/react-dropdown-menu': '^2.0.0'
          },
          devDependencies: {
            '@types/react': '^18.2.37',
            '@types/react-dom': '^18.2.15',
            '@typescript-eslint/eslint-plugin': '^6.10.0',
            '@typescript-eslint/parser': '^6.10.0',
            '@vitejs/plugin-react': '^4.1.1',
            'eslint': '^8.53.0',
            'eslint-plugin-react-hooks': '^4.6.0',
            'eslint-plugin-react-refresh': '^0.4.4',
            'typescript': '^5.2.2',
            'vite': '^4.5.0',
            'tailwindcss': '^3.3.6',
            'autoprefixer': '^10.4.16',
            'postcss': '^8.4.32'
          }
        }
      },
      configuration: {
        packageManagers: ['npm', 'yarn', 'pnpm'],
        buildTools: ['vite'],
        configFiles: {
          'tailwind.config.js': {},
          'tsconfig.json': {},
          'vite.config.ts': {},
          'components.json': {}
        },
        environmentVariables: {
          'VITE_APP_TITLE': 'React App',
          'VITE_API_URL': 'http://localhost:3001/api'
        },
        ports: {
          'dev': 5173,
          'preview': 4173
        },
        databases: [],
        authentication: {
          provider: 'custom',
          configuration: {},
          routes: ['/login', '/register', '/profile']
        },
        apis: []
      },
      installation: [
        {
          name: 'Install Dependencies',
          description: 'Install all npm dependencies',
          commands: ['npm install'],
          optional: false
        },
        {
          name: 'Initialize shadcn/ui',
          description: 'Set up shadcn/ui components',
          commands: ['npx shadcn-ui@latest init'],
          optional: false
        },
        {
          name: 'Add Basic Components',
          description: 'Add commonly used shadcn/ui components',
          commands: [
            'npx shadcn-ui@latest add button',
            'npx shadcn-ui@latest add input',
            'npx shadcn-ui@latest add card',
            'npx shadcn-ui@latest add toast',
            'npx shadcn-ui@latest add dialog'
          ],
          optional: true
        }
      ],
      development: {
        setup: ['npm install'],
        start: ['npm run dev'],
        test: ['npm run test'],
        build: ['npm run build'],
        lint: ['npm run lint'],
        format: ['npm run format']
      },
      deployment: {
        platforms: ['vercel', 'netlify', 'aws', 'azure'],
        containerization: {
          dockerfile: this.generateReactDockerfile()
        },
        cicd: {
          provider: 'github-actions',
          configuration: this.generateReactGithubActions(),
          triggers: ['push', 'pull_request'],
          stages: ['lint', 'test', 'build', 'deploy']
        },
        environments: [
          {
            name: 'development',
            variables: { 'NODE_ENV': 'development' },
            database: {} as DatabaseConfiguration,
            deployment: {}
          },
          {
            name: 'production',
            variables: { 'NODE_ENV': 'production' },
            database: {} as DatabaseConfiguration,
            deployment: {}
          }
        ]
      },
      integrations: {
        mcpServers: ['npm', 'github', 'vercel'],
        agents: ['frontend-specialist-agent', 'performance-optimizer-agent'],
        workflows: ['component-development', 'performance-optimization'],
        tools: ['vite', 'eslint', 'typescript'],
        apis: []
      }
    };

    this.templates.set(template.id, template);
  }

  private registerRustSupabasePostgresTemplate() {
    const template: FrameworkStackTemplate = {
      id: 'rust-supabase-postgres',
      name: 'Rust + Supabase + PostgreSQL',
      description: 'High-performance Rust backend with Supabase authentication and PostgreSQL database',
      category: 'backend',
      complexity: 8,
      technologies: ['Rust', 'Axum', 'Supabase', 'PostgreSQL', 'SQLx', 'Tokio', 'Serde'],
      requirements: {
        rust: '>=1.70.0',
        database: 'postgresql>=14'
      },
      structure: {
        root: {
          name: 'rust-backend',
          directories: {
            'src': 'Source code directory',
            'src/api': 'API route handlers',
            'src/models': 'Database models and schemas',
            'src/db': 'Database connection and utilities',
            'src/auth': 'Authentication and authorization',
            'src/middleware': 'HTTP middleware functions',
            'src/utils': 'Utility functions',
            'migrations': 'Database migration scripts',
            'supabase': 'Supabase configuration',
            'tests': 'Test files',
            'docs': 'API documentation'
          },
          files: {
            'Cargo.toml': {
              path: 'Cargo.toml',
              content: (context) => this.generateRustCargoToml(context),
              templated: true,
              description: 'Rust package configuration with all dependencies'
            },
            'src/main.rs': {
              path: 'src/main.rs',
              content: (context) => this.generateRustMain(context),
              templated: true,
              description: 'Rust application entry point with Axum server'
            },
            'src/lib.rs': {
              path: 'src/lib.rs',
              content: this.generateRustLib(),
              templated: false,
              description: 'Library exports and module definitions'
            },
            'src/api/mod.rs': {
              path: 'src/api/mod.rs',
              content: this.generateRustApiMod(),
              templated: false,
              description: 'API module exports'
            },
            'src/api/users.rs': {
              path: 'src/api/users.rs',
              content: this.generateRustUsersApi(),
              templated: false,
              description: 'User management API endpoints'
            },
            'src/models/mod.rs': {
              path: 'src/models/mod.rs',
              content: this.generateRustModelsMod(),
              templated: false,
              description: 'Database models module'
            },
            'src/models/user.rs': {
              path: 'src/models/user.rs',
              content: this.generateRustUserModel(),
              templated: false,
              description: 'User database model'
            },
            'src/db/mod.rs': {
              path: 'src/db/mod.rs',
              content: this.generateRustDbMod(),
              templated: false,
              description: 'Database module exports'
            },
            'src/db/connection.rs': {
              path: 'src/db/connection.rs',
              content: this.generateRustDbConnection(),
              templated: false,
              description: 'Database connection management'
            },
            'src/auth/mod.rs': {
              path: 'src/auth/mod.rs',
              content: this.generateRustAuthMod(),
              templated: false,
              description: 'Authentication module'
            },
            'src/auth/supabase.rs': {
              path: 'src/auth/supabase.rs',
              content: this.generateRustSupabaseAuth(),
              templated: false,
              description: 'Supabase authentication integration'
            },
            '.env.example': {
              path: '.env.example',
              content: this.generateRustEnvExample(),
              templated: false,
              description: 'Environment variables template'
            },
            'Dockerfile': {
              path: 'Dockerfile',
              content: this.generateRustDockerfile(),
              templated: false,
              description: 'Multi-stage Docker build for Rust'
            },
            'migrations/001_initial.sql': {
              path: 'migrations/001_initial.sql',
              content: this.generateInitialMigration(),
              templated: false,
              description: 'Initial database schema migration'
            },
            'README.md': {
              path: 'README.md',
              content: (context) => this.generateRustReadme(context),
              templated: true,
              description: 'Project documentation and API reference'
            }
          },
          scripts: {
            'dev': 'cargo watch -x run',
            'build': 'cargo build --release',
            'test': 'cargo test',
            'migrate': 'sqlx migrate run',
            'migrate:create': 'sqlx migrate add',
            'lint': 'cargo clippy -- -D warnings',
            'format': 'cargo fmt'
          },
          dependencies: {
            'axum': '0.7.0',
            'tokio': '{ version = "1.0", features = ["full"] }',
            'serde': '{ version = "1.0", features = ["derive"] }',
            'serde_json': '1.0',
            'sqlx': '{ version = "0.7", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] }',
            'uuid': '{ version = "1.0", features = ["v4", "serde"] }',
            'chrono': '{ version = "0.4", features = ["serde"] }',
            'anyhow': '1.0',
            'thiserror': '1.0',
            'tracing': '0.1',
            'tracing-subscriber': '0.3',
            'tower': '0.4',
            'tower-http': '{ version = "0.5", features = ["cors", "trace"] }',
            'jsonwebtoken': '9.0',
            'reqwest': '{ version = "0.11", features = ["json"] }',
            'dotenv': '0.15'
          },
          devDependencies: {
            'cargo-watch': '8.0'
          }
        }
      },
      configuration: {
        packageManagers: ['cargo'],
        buildTools: ['cargo'],
        configFiles: {
          'Cargo.toml': {},
          '.env': {}
        },
        environmentVariables: {
          'DATABASE_URL': 'postgresql://username:password@localhost:5432/database',
          'SUPABASE_URL': 'https://your-project.supabase.co',
          'SUPABASE_ANON_KEY': 'your-anon-key',
          'SUPABASE_SERVICE_ROLE_KEY': 'your-service-role-key',
          'JWT_SECRET': 'your-jwt-secret',
          'PORT': '3001'
        },
        ports: {
          'api': 3001,
          'database': 5432
        },
        databases: [
          {
            type: 'postgresql',
            host: 'localhost',
            port: 5432,
            database: 'app_db',
            migrations: ['001_initial.sql', '002_add_users.sql']
          }
        ],
        authentication: {
          provider: 'supabase',
          configuration: {
            url: 'SUPABASE_URL',
            anonKey: 'SUPABASE_ANON_KEY',
            serviceRoleKey: 'SUPABASE_SERVICE_ROLE_KEY'
          },
          routes: ['/auth/login', '/auth/register', '/auth/refresh']
        },
        apis: [
          {
            framework: 'axum',
            baseUrl: '/api/v1',
            endpoints: [
              {
                path: '/users',
                method: 'GET',
                description: 'List all users',
                authentication: true,
                parameters: [],
                response: { type: 'array', properties: {} }
              },
              {
                path: '/users/:id',
                method: 'GET',
                description: 'Get user by ID',
                authentication: true,
                parameters: [
                  { name: 'id', type: 'uuid', required: true, description: 'User ID' }
                ],
                response: { type: 'object', properties: {} }
              }
            ],
            middleware: ['cors', 'auth', 'logging'],
            documentation: '/docs'
          }
        ]
      },
      installation: [
        {
          name: 'Install Rust',
          description: 'Install Rust programming language',
          commands: ['curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh'],
          optional: false
        },
        {
          name: 'Install SQLx CLI',
          description: 'Install SQLx command-line tool for migrations',
          commands: ['cargo install sqlx-cli --no-default-features --features postgres'],
          optional: false
        },
        {
          name: 'Setup Database',
          description: 'Create database and run migrations',
          commands: [
            'createdb app_db',
            'sqlx migrate run'
          ],
          optional: false
        },
        {
          name: 'Install Development Tools',
          description: 'Install cargo-watch for development',
          commands: ['cargo install cargo-watch'],
          optional: true
        }
      ],
      development: {
        setup: ['cargo build'],
        start: ['cargo run'],
        test: ['cargo test'],
        build: ['cargo build --release'],
        lint: ['cargo clippy'],
        format: ['cargo fmt']
      },
      deployment: {
        platforms: ['aws', 'gcp', 'azure', 'railway', 'fly.io'],
        containerization: {
          dockerfile: this.generateRustDockerfile()
        },
        cicd: {
          provider: 'github-actions',
          configuration: this.generateRustGithubActions(),
          triggers: ['push', 'pull_request'],
          stages: ['test', 'build', 'deploy']
        },
        environments: [
          {
            name: 'development',
            variables: { 'RUST_LOG': 'debug' },
            database: {
              type: 'postgresql',
              host: 'localhost',
              port: 5432,
              database: 'app_dev',
              migrations: []
            },
            deployment: {}
          },
          {
            name: 'production',
            variables: { 'RUST_LOG': 'info' },
            database: {
              type: 'postgresql',
              host: 'prod-db.example.com',
              port: 5432,
              database: 'app_prod',
              migrations: []
            },
            deployment: {}
          }
        ]
      },
      integrations: {
        mcpServers: ['postgres', 'supabase', 'github'],
        agents: ['api-builder-agent', 'database-architect-agent', 'security-auditor'],
        workflows: ['api-development', 'database-optimization'],
        tools: ['cargo', 'sqlx', 'docker'],
        apis: ['supabase-api']
      }
    };

    this.templates.set(template.id, template);
  }

  private registerFullStackReactRustTemplate() {
    const template: FrameworkStackTemplate = {
      id: 'fullstack-react-rust',
      name: 'Full-Stack React + Rust',
      description: 'Complete full-stack application with React frontend and Rust backend',
      category: 'fullstack',
      complexity: 9,
      technologies: ['React', 'TypeScript', 'Rust', 'Axum', 'PostgreSQL', 'Supabase', 'Tailwind CSS', 'shadcn/ui'],
      requirements: {
        node: '>=18.0.0',
        rust: '>=1.70.0',
        database: 'postgresql>=14'
      },
      structure: {
        root: {
          name: 'fullstack-app',
          directories: {
            'frontend': 'React frontend application',
            'backend': 'Rust backend API',
            'shared': 'Shared types and utilities',
            'docs': 'Project documentation',
            'scripts': 'Development and deployment scripts'
          },
          files: {
            'package.json': {
              path: 'package.json',
              content: (context) => this.generateFullStackPackageJson(context),
              templated: true,
              description: 'Root package.json for workspace management'
            },
            'docker-compose.yml': {
              path: 'docker-compose.yml',
              content: this.generateFullStackDockerCompose(),
              templated: false,
              description: 'Docker Compose configuration for development'
            },
            'README.md': {
              path: 'README.md',
              content: (context) => this.generateFullStackReadme(context),
              templated: true,
              description: 'Project overview and setup instructions'
            },
            '.gitignore': {
              path: '.gitignore',
              content: this.generateFullStackGitignore(),
              templated: false,
              description: 'Git ignore file for all projects'
            }
          },
          scripts: {
            'install': 'npm run install:frontend && npm run install:backend',
            'install:frontend': 'cd frontend && npm install',
            'install:backend': 'cd backend && cargo build',
            'dev': 'concurrently "npm run dev:backend" "npm run dev:frontend"',
            'dev:frontend': 'cd frontend && npm run dev',
            'dev:backend': 'cd backend && cargo watch -x run',
            'build': 'npm run build:frontend && npm run build:backend',
            'build:frontend': 'cd frontend && npm run build',
            'build:backend': 'cd backend && cargo build --release',
            'test': 'npm run test:frontend && npm run test:backend',
            'test:frontend': 'cd frontend && npm run test',
            'test:backend': 'cd backend && cargo test'
          },
          dependencies: {},
          devDependencies: {
            'concurrently': '^8.2.2'
          }
        },
        subprojects: {
          frontend: {
            name: 'frontend',
            directories: {
              'src': 'React source code',
              'src/components': 'React components',
              'src/pages': 'Page components',
              'src/lib': 'Utility functions',
              'src/types': 'TypeScript types',
              'public': 'Static assets'
            },
            files: {},
            scripts: {},
            dependencies: {},
            devDependencies: {}
          },
          backend: {
            name: 'backend',
            directories: {
              'src': 'Rust source code',
              'src/api': 'API endpoints',
              'src/models': 'Database models',
              'src/db': 'Database utilities',
              'migrations': 'Database migrations'
            },
            files: {},
            scripts: {},
            dependencies: {},
            devDependencies: {}
          }
        },
        shared: {
          name: 'shared',
          directories: {
            'types': 'Shared TypeScript/Rust types',
            'schemas': 'API schemas and validation',
            'utils': 'Shared utility functions'
          },
          files: {},
          scripts: {},
          dependencies: {},
          devDependencies: {}
        }
      },
      configuration: {
        packageManagers: ['npm', 'cargo'],
        buildTools: ['vite', 'cargo'],
        configFiles: {},
        environmentVariables: {
          'FRONTEND_URL': 'http://localhost:5173',
          'BACKEND_URL': 'http://localhost:3001',
          'DATABASE_URL': 'postgresql://username:password@localhost:5432/database'
        },
        ports: {
          'frontend': 5173,
          'backend': 3001,
          'database': 5432
        },
        databases: [
          {
            type: 'postgresql',
            host: 'localhost',
            port: 5432,
            database: 'fullstack_app',
            migrations: []
          }
        ],
        authentication: {
          provider: 'supabase',
          configuration: {},
          routes: []
        },
        apis: []
      },
      installation: [
        {
          name: 'Install Node.js Dependencies',
          description: 'Install frontend dependencies',
          commands: ['npm run install:frontend'],
          optional: false
        },
        {
          name: 'Install Rust Dependencies',
          description: 'Build Rust backend',
          commands: ['npm run install:backend'],
          optional: false
        },
        {
          name: 'Setup Database',
          description: 'Initialize PostgreSQL database',
          commands: ['docker-compose up -d postgres'],
          optional: false
        }
      ],
      development: {
        setup: ['npm run install'],
        start: ['npm run dev'],
        test: ['npm run test'],
        build: ['npm run build'],
        lint: ['npm run lint'],
        format: ['npm run format']
      },
      deployment: {
        platforms: ['vercel', 'railway', 'aws', 'docker'],
        containerization: {
          dockerfile: this.generateFullStackDockerfile(),
          dockerCompose: this.generateFullStackDockerCompose()
        },
        cicd: {
          provider: 'github-actions',
          configuration: this.generateFullStackGithubActions(),
          triggers: ['push', 'pull_request'],
          stages: ['test', 'build', 'deploy']
        },
        environments: []
      },
      integrations: {
        mcpServers: ['npm', 'postgres', 'supabase', 'github'],
        agents: ['frontend-specialist-agent', 'api-builder-agent', 'database-architect-agent'],
        workflows: ['fullstack-development', 'deployment-pipeline'],
        tools: ['vite', 'cargo', 'docker', 'postgresql'],
        apis: ['backend-api']
      }
    };

    this.templates.set(template.id, template);
  }

  // Additional template registration methods would go here...
  private registerNextjsPrismaSupabaseTemplate() {
    // Implementation for Next.js + Prisma + Supabase template
  }

  private registerVueNuxtSupabaseTemplate() {
    // Implementation for Vue.js + Nuxt + Supabase template
  }

  private registerSvelteKitSupabaseTemplate() {
    // Implementation for SvelteKit + Supabase template
  }

  private registerFlutterSupabaseTemplate() {
    // Implementation for Flutter + Supabase template
  }

  private registerReactNativeExpoTemplate() {
    // Implementation for React Native + Expo template
  }

  // Content generation methods for React + shadcn/ui + Tailwind
  private generateReactPackageJson(context: TemplateContext): string {
    return JSON.stringify({
      name: context.projectName,
      private: true,
      version: "0.0.0",
      type: "module",
      description: context.description,
      author: context.author,
      license: context.license,
      scripts: {
        dev: "vite",
        build: "tsc && vite build",
        lint: "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        preview: "vite preview",
        "ui:add": "npx shadcn-ui@latest add",
        "ui:init": "npx shadcn-ui@latest init"
      },
      dependencies: {
        react: "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.20.0",
        "react-hook-form": "^7.48.0",
        "@hookform/resolvers": "^3.3.0",
        zod: "^3.22.0",
        "class-variance-authority": "^0.7.0",
        clsx: "^2.0.0",
        "tailwind-merge": "^2.0.0",
        "lucide-react": "^0.294.0",
        "@radix-ui/react-slot": "^1.0.0",
        "@radix-ui/react-toast": "^1.1.0",
        "@radix-ui/react-dialog": "^1.0.0",
        "@radix-ui/react-dropdown-menu": "^2.0.0"
      },
      devDependencies: {
        "@types/react": "^18.2.37",
        "@types/react-dom": "^18.2.15",
        "@typescript-eslint/eslint-plugin": "^6.10.0",
        "@typescript-eslint/parser": "^6.10.0",
        "@vitejs/plugin-react": "^4.1.1",
        eslint: "^8.53.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.4",
        typescript: "^5.2.2",
        vite: "^4.5.0",
        tailwindcss: "^3.3.6",
        autoprefixer: "^10.4.16",
        postcss: "^8.4.32"
      }
    }, null, 2);
  }

  private generateTypeScriptConfig(): string {
    return JSON.stringify({
      compilerOptions: {
        target: "ES2020",
        useDefineForClassFields: true,
        lib: ["ES2020", "DOM", "DOM.Iterable"],
        module: "ESNext",
        skipLibCheck: true,
        moduleResolution: "bundler",
        allowImportingTsExtensions: true,
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        jsx: "react-jsx",
        strict: true,
        noUnusedLocals: true,
        noUnusedParameters: true,
        noFallthroughCasesInSwitch: true,
        baseUrl: ".",
        paths: {
          "@/*": ["./src/*"],
          "@/components/*": ["./src/components/*"],
          "@/lib/*": ["./src/lib/*"],
          "@/hooks/*": ["./src/hooks/*"],
          "@/types/*": ["./src/types/*"]
        }
      },
      include: ["src"],
      references: [{ path: "./tsconfig.node.json" }]
    }, null, 2);
  }

  private generateTailwindConfig(): string {
    return `/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}`;
  }

  private generateShadcnConfig(): string {
    return JSON.stringify({
      "$schema": "https://ui.shadcn.com/schema.json",
      style: "default",
      rsc: false,
      tsx: true,
      tailwind: {
        config: "tailwind.config.js",
        css: "src/styles/globals.css",
        baseColor: "slate",
        cssVariables: true
      },
      aliases: {
        components: "@/components",
        utils: "@/lib/utils"
      }
    }, null, 2);
  }

  private generateViteConfig(): string {
    return `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 5173,
    host: true,
  },
})`;
  }

  private generateReactMain(context: TemplateContext): string {
    return `import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App.tsx'
import './styles/globals.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
)`;
  }

  private generateReactApp(context: TemplateContext): string {
    return `import { Routes, Route } from 'react-router-dom'
import { Toaster } from '@/components/ui/toaster'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'

function App() {
  return (
    <div className="min-h-screen bg-background">
      <main className="container mx-auto px-4 py-8">
        <div className="max-w-2xl mx-auto text-center space-y-8">
          <div className="space-y-4">
            <h1 className="text-4xl font-bold tracking-tight">
              Welcome to ${context.projectName}
            </h1>
            <p className="text-xl text-muted-foreground">
              ${context.description || 'A modern React application with shadcn/ui and Tailwind CSS'}
            </p>
          </div>
          
          <Card className="text-left">
            <CardHeader>
              <CardTitle>Getting Started</CardTitle>
              <CardDescription>
                Your React app is ready to go with shadcn/ui components and Tailwind CSS styling.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Button variant="default" className="w-full">
                  Primary Button
                </Button>
                <Button variant="outline" className="w-full">
                  Secondary Button
                </Button>
              </div>
              <p className="text-sm text-muted-foreground">
                Edit <code className="bg-muted px-1 py-0.5 rounded">src/App.tsx</code> to customize your application.
              </p>
            </CardContent>
          </Card>
        </div>
      </main>
      <Toaster />
    </div>
  )
}

export default App`;
  }

  private generateUtilsFile(): string {
    return `import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}`;
  }

  private generateGlobalStyles(): string {
    return `@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;

    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}`;
  }

  private generateIndexHtml(context: TemplateContext): string {
    return `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${context.projectName}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>`;
  }

  private generateEslintConfig(): string {
    return `module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
  },
}`;
  }

  private generateReactReadme(context: TemplateContext): string {
    return `# ${context.projectName}

${context.description || 'A modern React application with shadcn/ui components and Tailwind CSS styling.'}

## Features

- ‚ö° **Vite** - Fast build tool and development server
- ‚öõÔ∏è **React 18** - Latest React with hooks and concurrent features
- üé® **Tailwind CSS** - Utility-first CSS framework
- üß© **shadcn/ui** - Beautiful and accessible React components
- üì± **Responsive Design** - Mobile-first approach
- üîß **TypeScript** - Type safety and better developer experience
- üéØ **ESLint** - Code linting and formatting
- üö¶ **React Router** - Client-side routing

## Getting Started

### Prerequisites

- Node.js 18 or higher
- npm, yarn, or pnpm

### Installation

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Initialize shadcn/ui:
   \`\`\`bash
   npx shadcn-ui@latest init
   \`\`\`

3. Add basic components:
   \`\`\`bash
   npx shadcn-ui@latest add button
   npx shadcn-ui@latest add card
   npx shadcn-ui@latest add input
   \`\`\`

### Development

Start the development server:
\`\`\`bash
npm run dev
\`\`\`

The application will be available at \`http://localhost:5173\`.

### Building

Build for production:
\`\`\`bash
npm run build
\`\`\`

### Available Scripts

- \`npm run dev\` - Start development server
- \`npm run build\` - Build for production
- \`npm run preview\` - Preview production build
- \`npm run lint\` - Run ESLint
- \`npm run ui:add\` - Add shadcn/ui components
- \`npm run ui:init\` - Initialize shadcn/ui

## Project Structure

\`\`\`
src/
‚îú‚îÄ‚îÄ components/          # React components
‚îÇ   ‚îî‚îÄ‚îÄ ui/             # shadcn/ui components
‚îú‚îÄ‚îÄ hooks/              # Custom React hooks
‚îú‚îÄ‚îÄ lib/                # Utility functions
‚îú‚îÄ‚îÄ pages/              # Page components
‚îú‚îÄ‚îÄ styles/             # CSS files
‚îú‚îÄ‚îÄ types/              # TypeScript type definitions
‚îú‚îÄ‚îÄ App.tsx             # Main App component
‚îî‚îÄ‚îÄ main.tsx            # Application entry point
\`\`\`

## Adding Components

To add new shadcn/ui components:

\`\`\`bash
npx shadcn-ui@latest add [component-name]
\`\`\`

Available components: button, card, input, dialog, dropdown-menu, toast, and many more.

## Customization

### Tailwind CSS

Customize your design system in \`tailwind.config.js\`:

\`\`\`javascript
theme: {
  extend: {
    colors: {
      // Add your custom colors
    },
  },
}
\`\`\`

### shadcn/ui

Customize component styles in \`src/styles/globals.css\` using CSS variables.

## Deployment

### Vercel

1. Push your code to GitHub
2. Connect your repository to Vercel
3. Deploy automatically

### Netlify

1. Build the project: \`npm run build\`
2. Deploy the \`dist\` folder to Netlify

### Docker

Build and run with Docker:

\`\`\`bash
docker build -t ${context.projectName.toLowerCase()} .
docker run -p 3000:3000 ${context.projectName.toLowerCase()}
\`\`\`

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## License

${context.license || 'MIT'}
`;
  }

  // Content generation methods for Rust backend would continue here...
  private generateRustCargoToml(context: TemplateContext): string {
    return `[package]
name = "${context.projectName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}"
version = "0.1.0"
edition = "2021"
description = "${context.description || 'Rust backend with Supabase and PostgreSQL'}"
authors = ["${context.author || 'Your Name <your.email@example.com>'}"]
license = "${context.license || 'MIT'}"

[dependencies]
axum = "0.7.0"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
anyhow = "1.0"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
jsonwebtoken = "9.0"
reqwest = { version = "0.11", features = ["json"] }
dotenv = "0.15"

[dev-dependencies]
cargo-watch = "8.0"
`;
  }

  private generateRustMain(context: TemplateContext): string {
    return `use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use sqlx::{PgPool, postgres::PgPoolOptions};
use std::net::SocketAddr;
use tower::ServiceBuilder;
use tower_http::{cors::CorsLayer, trace::TraceLayer};
use tracing::{info, Level};

mod api;
mod auth;
mod db;
mod models;

use crate::api::users;
use crate::auth::supabase;
use crate::db::connection;

#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
}

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    version: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_max_level(Level::INFO)
        .init();

    // Load environment variables
    dotenv::dotenv().ok();

    // Database connection
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    
    let pool = PgPoolOptions::new()
        .max_connections(20)
        .connect(&database_url)
        .await?;

    // Run migrations
    sqlx::migrate!("./migrations").run(&pool).await?;

    let app_state = AppState { db: pool };

    // Build our application with routes
    let app = Router::new()
        .route("/health", get(health_check))
        .nest("/api/v1", api_routes())
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CorsLayer::permissive())
        )
        .with_state(app_state);

    // Run server
    let port = std::env::var("PORT")
        .unwrap_or_else(|_| "3001".to_string())
        .parse::<u16>()?;
    
    let addr = SocketAddr::from(([0, 0, 0, 0], port));
    info!("Server listening on {}", addr);
    
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}

fn api_routes() -> Router<AppState> {
    Router::new()
        .nest("/users", users::routes())
        .nest("/auth", supabase::routes())
}

async fn health_check() -> Result<Json<HealthResponse>, StatusCode> {
    Ok(Json(HealthResponse {
        status: "healthy".to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    }))
}
`;
  }

  private generateRustLib(): string {
    return `pub mod api;
pub mod auth;
pub mod db;
pub mod models;

pub use api::*;
pub use auth::*;
pub use db::*;
pub use models::*;
`;
  }

  // Additional content generation methods would continue here...
  
  private generateReactDockerfile(): string {
    return `# Build stage
FROM node:18-alpine as build

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built app
COPY --from=build /app/dist /usr/share/nginx/html

# Copy nginx config
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
`;
  }

  private generateRustDockerfile(): string {
    return `# Build stage
FROM rust:1.70 as builder

WORKDIR /app

# Copy Cargo files
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm src/main.rs

# Copy source code
COPY src ./src
COPY migrations ./migrations
RUN touch src/main.rs
RUN cargo build --release

# Runtime stage
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \\
    ca-certificates \\
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy binary
COPY --from=builder /app/target/release/* ./
COPY --from=builder /app/migrations ./migrations

EXPOSE 3001

CMD ["./main"]
`;
  }

  private generateReactGithubActions(): string {
    return `name: Frontend CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run tests
      run: npm run test
    
    - name: Build
      run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install and build
      run: |
        npm ci
        npm run build
    
    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v20
      with:
        vercel-token: \${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: \${{ secrets.ORG_ID }}
        vercel-project-id: \${{ secrets.PROJECT_ID }}
        vercel-args: '--prod'
`;
  }

  private generateRustGithubActions(): string {
    return `name: Backend CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        components: rustfmt, clippy
    
    - name: Cache cargo dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: \${{ runner.os }}-cargo-\${{ hashFiles('**/Cargo.lock') }}
    
    - name: Run clippy
      run: cargo clippy -- -D warnings
    
    - name: Run formatter check
      run: cargo fmt --all -- --check
    
    - name: Run tests
      run: cargo test
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build and deploy
      run: |
        # Add deployment commands here
        echo "Deploy to production"
`;
  }

  // Additional helper methods for other templates...
  private generateFullStackPackageJson(context: TemplateContext): string {
    return JSON.stringify({
      name: context.projectName,
      version: "0.1.0",
      description: context.description,
      author: context.author,
      license: context.license,
      private: true,
      workspaces: ["frontend", "backend"],
      scripts: {
        install: "npm run install:frontend && npm run install:backend",
        "install:frontend": "cd frontend && npm install",
        "install:backend": "cd backend && cargo build",
        dev: "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
        "dev:frontend": "cd frontend && npm run dev",
        "dev:backend": "cd backend && cargo watch -x run",
        build: "npm run build:frontend && npm run build:backend",
        "build:frontend": "cd frontend && npm run build",
        "build:backend": "cd backend && cargo build --release",
        test: "npm run test:frontend && npm run test:backend",
        "test:frontend": "cd frontend && npm run test",
        "test:backend": "cd backend && cargo test"
      },
      devDependencies: {
        "concurrently": "^8.2.2"
      }
    }, null, 2);
  }

  private generateFullStackDockerCompose(): string {
    return `version: '3.8'

services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: fullstack_app
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      DATABASE_URL: postgres://postgres:postgres@postgres:5432/fullstack_app
      RUST_LOG: info
    depends_on:
      - postgres
    volumes:
      - ./backend:/app
      - cargo_cache:/usr/local/cargo

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    environment:
      VITE_API_URL: http://localhost:3001/api
    depends_on:
      - backend
    volumes:
      - ./frontend:/app
      - node_modules:/app/node_modules

volumes:
  postgres_data:
  cargo_cache:
  node_modules:
`;
  }

  private generateFullStackDockerfile(): string {
    return `# Multi-stage build for full-stack application
FROM node:18-alpine as frontend-build

WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm ci
COPY frontend/ ./
RUN npm run build

FROM rust:1.70 as backend-build

WORKDIR /app/backend
COPY backend/Cargo.toml backend/Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm src/main.rs

COPY backend/src ./src
COPY backend/migrations ./migrations
RUN touch src/main.rs
RUN cargo build --release

FROM nginx:alpine

# Copy frontend build
COPY --from=frontend-build /app/frontend/dist /usr/share/nginx/html

# Copy backend binary
COPY --from=backend-build /app/backend/target/release/* /usr/local/bin/

# Copy nginx config for SPA
RUN echo 'server {
    listen 80;
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }
    location /api {
        proxy_pass http://localhost:3001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}' > /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["sh", "-c", "backend & nginx -g 'daemon off;'"]
`;
  }

  private generateFullStackGithubActions(): string {
    return `name: Full-Stack CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test-frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm run test
    
    - name: Build
      run: npm run build

  test-backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
    
    - name: Cache cargo dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          backend/target
        key: \${{ runner.os }}-cargo-\${{ hashFiles('**/Cargo.lock') }}
    
    - name: Run tests
      run: cargo test
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db

  deploy:
    needs: [test-frontend, test-backend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy full-stack application
      run: |
        echo "Deploy to production"
        # Add your deployment commands here
`;
  }

  private generateFullStackReadme(context: TemplateContext): string {
    return `# ${context.projectName}

${context.description || 'A full-stack application with React frontend and Rust backend'}

## Architecture

- **Frontend**: React + TypeScript + Vite + shadcn/ui + Tailwind CSS
- **Backend**: Rust + Axum + SQLx + PostgreSQL + Supabase
- **Database**: PostgreSQL with migrations
- **Authentication**: Supabase Auth
- **Deployment**: Docker + Docker Compose

## Getting Started

### Prerequisites

- Node.js 18 or higher
- Rust 1.70 or higher  
- PostgreSQL 14 or higher
- Docker (optional)

### Quick Start with Docker

1. Clone the repository:
   \`\`\`bash
   git clone <repository-url>
   cd ${context.projectName.toLowerCase()}
   \`\`\`

2. Start all services:
   \`\`\`bash
   docker-compose up -d
   \`\`\`

3. Access the application:
   - Frontend: http://localhost:5173
   - Backend API: http://localhost:3001
   - Database: localhost:5432

### Manual Setup

1. **Setup Backend**:
   \`\`\`bash
   cd backend
   cargo build
   sqlx migrate run
   cargo run
   \`\`\`

2. **Setup Frontend**:
   \`\`\`bash
   cd frontend
   npm install
   npm run dev
   \`\`\`

3. **Setup Database**:
   \`\`\`bash
   createdb fullstack_app
   \`\`\`

## Development

### Root Commands

- \`npm run dev\` - Start both frontend and backend
- \`npm run build\` - Build both projects
- \`npm run test\` - Run all tests

### Frontend Commands

- \`cd frontend && npm run dev\` - Start frontend dev server
- \`cd frontend && npm run build\` - Build frontend
- \`cd frontend && npm run test\` - Run frontend tests

### Backend Commands

- \`cd backend && cargo run\` - Start backend server
- \`cd backend && cargo test\` - Run backend tests
- \`cd backend && cargo build --release\` - Build for production

## Project Structure

\`\`\`
‚îú‚îÄ‚îÄ frontend/                 # React frontend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/       # React components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/           # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/             # Utility functions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/           # TypeScript types
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts
‚îú‚îÄ‚îÄ backend/                  # Rust backend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/             # API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/          # Database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db/              # Database utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth/            # Authentication
‚îÇ   ‚îú‚îÄ‚îÄ migrations/          # Database migrations
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ shared/                   # Shared types and utilities
‚îú‚îÄ‚îÄ docker-compose.yml        # Development environment
‚îî‚îÄ‚îÄ README.md
\`\`\`

## API Documentation

The backend provides a RESTful API with the following endpoints:

### Authentication
- \`POST /api/v1/auth/login\` - User login
- \`POST /api/v1/auth/register\` - User registration
- \`POST /api/v1/auth/refresh\` - Refresh JWT token

### Users
- \`GET /api/v1/users\` - List users
- \`GET /api/v1/users/:id\` - Get user by ID
- \`PUT /api/v1/users/:id\` - Update user
- \`DELETE /api/v1/users/:id\` - Delete user

## Environment Variables

### Backend (\`.env\`)
\`\`\`
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/fullstack_app
SUPABASE_URL=your-supabase-url
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
JWT_SECRET=your-jwt-secret
PORT=3001
RUST_LOG=info
\`\`\`

### Frontend (\`.env\`)
\`\`\`
VITE_API_URL=http://localhost:3001/api
VITE_SUPABASE_URL=your-supabase-url
VITE_SUPABASE_ANON_KEY=your-anon-key
\`\`\`

## Deployment

### Docker Deployment

1. Build the application:
   \`\`\`bash
   docker-compose -f docker-compose.prod.yml build
   \`\`\`

2. Deploy:
   \`\`\`bash
   docker-compose -f docker-compose.prod.yml up -d
   \`\`\`

### Cloud Deployment

- **Frontend**: Deploy to Vercel, Netlify, or AWS S3
- **Backend**: Deploy to Railway, Fly.io, or AWS ECS
- **Database**: Use Supabase, AWS RDS, or managed PostgreSQL

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## License

${context.license || 'MIT'}
`;
  }

  private generateFullStackGitignore(): string {
    return `# Dependencies
node_modules/
target/
dist/
build/

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
logs/

# Database
*.db
*.sqlite

# Cargo
Cargo.lock
target/

# Build outputs
dist/
build/

# Cache
.cache/
.parcel-cache/
.next/
.nuxt/

# Coverage
coverage/
.nyc_output/

# Docker
.dockerignore

# Misc
*.tgz
*.tar.gz
`;
  }

  // Helper methods for additional template content generation
  private generateRustEnvExample(): string {
    return `# Database
DATABASE_URL=postgresql://username:password@localhost:5432/database

# Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# JWT
JWT_SECRET=your-jwt-secret-key

# Server
PORT=3001
RUST_LOG=info

# CORS
CORS_ORIGIN=http://localhost:5173
`;
  }

  private generateRustApiMod(): string {
    return `pub mod users;

pub use users::*;
`;
  }

  private generateRustUsersApi(): string {
    return `use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{models::User, AppState};

pub fn routes() -> Router<AppState> {
    Router::new()
        .route("/", get(list_users).post(create_user))
        .route("/:id", get(get_user).put(update_user).delete(delete_user))
}

#[derive(Deserialize)]
pub struct ListUsersQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

#[derive(Deserialize)]
pub struct CreateUserRequest {
    email: String,
    username: String,
    full_name: Option<String>,
}

#[derive(Deserialize)]
pub struct UpdateUserRequest {
    email: Option<String>,
    username: Option<String>,
    full_name: Option<String>,
}

pub async fn list_users(
    Query(params): Query<ListUsersQuery>,
    State(state): State<AppState>,
) -> Result<Json<Vec<User>>, StatusCode> {
    let page = params.page.unwrap_or(1);
    let limit = params.limit.unwrap_or(10);
    let offset = (page - 1) * limit;

    let users = sqlx::query_as!(
        User,
        "SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2",
        limit as i64,
        offset as i64
    )
    .fetch_all(&state.db)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(users))
}

pub async fn get_user(
    Path(id): Path<Uuid>,
    State(state): State<AppState>,
) -> Result<Json<User>, StatusCode> {
    let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", id)
        .fetch_one(&state.db)
        .await
        .map_err(|_| StatusCode::NOT_FOUND)?;

    Ok(Json(user))
}

pub async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, StatusCode> {
    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (email, username, full_name)
        VALUES ($1, $2, $3)
        RETURNING *
        "#,
        payload.email,
        payload.username,
        payload.full_name
    )
    .fetch_one(&state.db)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(user))
}

pub async fn update_user(
    Path(id): Path<Uuid>,
    State(state): State<AppState>,
    Json(payload): Json<UpdateUserRequest>,
) -> Result<Json<User>, StatusCode> {
    let user = sqlx::query_as!(
        User,
        r#"
        UPDATE users 
        SET 
            email = COALESCE($2, email),
            username = COALESCE($3, username),
            full_name = COALESCE($4, full_name),
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        "#,
        id,
        payload.email,
        payload.username,
        payload.full_name
    )
    .fetch_one(&state.db)
    .await
    .map_err(|_| StatusCode::NOT_FOUND)?;

    Ok(Json(user))
}

pub async fn delete_user(
    Path(id): Path<Uuid>,
    State(state): State<AppState>,
) -> Result<StatusCode, StatusCode> {
    let result = sqlx::query!("DELETE FROM users WHERE id = $1", id)
        .execute(&state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    if result.rows_affected() == 0 {
        return Err(StatusCode::NOT_FOUND);
    }

    Ok(StatusCode::NO_CONTENT)
}
`;
  }

  private generateRustModelsMod(): string {
    return `pub mod user;

pub use user::*;
`;
  }

  private generateRustUserModel(): string {
    return `use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub username: String,
    pub full_name: Option<String>,
    pub avatar_url: Option<String>,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NewUser {
    pub email: String,
    pub username: String,
    pub full_name: Option<String>,
}
`;
  }

  private generateRustDbMod(): string {
    return `pub mod connection;

pub use connection::*;
`;
  }

  private generateRustDbConnection(): string {
    return `use sqlx::{PgPool, postgres::PgPoolOptions};
use anyhow::Result;

pub async fn create_pool(database_url: &str) -> Result<PgPool> {
    let pool = PgPoolOptions::new()
        .max_connections(20)
        .connect(database_url)
        .await?;

    // Test the connection
    sqlx::query("SELECT 1")
        .execute(&pool)
        .await?;

    Ok(pool)
}

pub async fn run_migrations(pool: &PgPool) -> Result<()> {
    sqlx::migrate!("./migrations").run(pool).await?;
    Ok(())
}
`;
  }

  private generateRustAuthMod(): string {
    return `pub mod supabase;

pub use supabase::*;
`;
  }

  private generateRustSupabaseAuth(): string {
    return `use axum::{
    extract::State,
    http::{HeaderMap, StatusCode},
    response::Json,
    routing::post,
    Router,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};

use crate::AppState;

pub fn routes() -> Router<AppState> {
    Router::new()
        .route("/verify", post(verify_token))
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,
    pub email: String,
    pub exp: usize,
}

#[derive(Serialize)]
pub struct AuthResponse {
    pub user_id: String,
    pub email: String,
    pub valid: bool,
}

pub async fn verify_token(
    headers: HeaderMap,
    State(_state): State<AppState>,
) -> Result<Json<AuthResponse>, StatusCode> {
    let auth_header = headers
        .get("authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    let token = auth_header
        .strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;

    let jwt_secret = std::env::var("JWT_SECRET")
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let validation = Validation::new(Algorithm::HS256);
    let decoding_key = DecodingKey::from_secret(jwt_secret.as_ref());

    match decode::<Claims>(token, &decoding_key, &validation) {
        Ok(token_data) => {
            let claims = token_data.claims;
            Ok(Json(AuthResponse {
                user_id: claims.sub,
                email: claims.email,
                valid: true,
            }))
        }
        Err(_) => Err(StatusCode::UNAUTHORIZED),
    }
}
`;
  }

  private generateInitialMigration(): string {
    return `-- Initial schema for users table
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    full_name VARCHAR(255),
    avatar_url TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for users table
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
`;
  }

  private generateRustReadme(context: TemplateContext): string {
    return `# ${context.projectName} - Rust Backend

High-performance Rust backend with Axum web framework, PostgreSQL database, and Supabase authentication.

## Features

- ü¶Ä **Rust** - Memory-safe and performant
- ‚ö° **Axum** - Modern async web framework
- üêò **PostgreSQL** - Robust relational database
- üîê **Supabase Auth** - Authentication and authorization
- üìä **SQLx** - Compile-time checked SQL queries
- üê≥ **Docker** - Containerized deployment
- üß™ **Testing** - Comprehensive test suite
- üìù **Migrations** - Database version control

## Getting Started

### Prerequisites

- Rust 1.70 or higher
- PostgreSQL 14 or higher
- SQLx CLI: \`cargo install sqlx-cli\`

### Installation

1. Install dependencies:
   \`\`\`bash
   cargo build
   \`\`\`

2. Set up environment:
   \`\`\`bash
   cp .env.example .env
   # Edit .env with your configuration
   \`\`\`

3. Run migrations:
   \`\`\`bash
   sqlx migrate run
   \`\`\`

4. Start the server:
   \`\`\`bash
   cargo run
   \`\`\`

The API will be available at \`http://localhost:3001\`.

### Development

- **Start dev server**: \`cargo watch -x run\`
- **Run tests**: \`cargo test\`
- **Check formatting**: \`cargo fmt --all -- --check\`
- **Run linter**: \`cargo clippy -- -D warnings\`

## API Endpoints

### Health Check
- \`GET /health\` - Server health status

### Authentication
- \`POST /api/v1/auth/verify\` - Verify JWT token

### Users
- \`GET /api/v1/users\` - List users (paginated)
- \`GET /api/v1/users/:id\` - Get user by ID
- \`POST /api/v1/users\` - Create new user
- \`PUT /api/v1/users/:id\` - Update user
- \`DELETE /api/v1/users/:id\` - Delete user

## Project Structure

\`\`\`
src/
‚îú‚îÄ‚îÄ main.rs              # Application entry point
‚îú‚îÄ‚îÄ lib.rs               # Library exports
‚îú‚îÄ‚îÄ api/                 # API route handlers
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îî‚îÄ‚îÄ users.rs
‚îú‚îÄ‚îÄ auth/                # Authentication logic
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îî‚îÄ‚îÄ supabase.rs
‚îú‚îÄ‚îÄ db/                  # Database utilities
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îî‚îÄ‚îÄ connection.rs
‚îî‚îÄ‚îÄ models/              # Data models
    ‚îú‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ user.rs
migrations/              # Database migrations
tests/                   # Test files
Cargo.toml              # Dependencies and metadata
\`\`\`

## Database Schema

### Users Table
\`\`\`sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    full_name VARCHAR(255),
    avatar_url TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
\`\`\`

## Environment Variables

\`\`\`bash
# Database
DATABASE_URL=postgresql://username:password@localhost:5432/database

# Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# JWT
JWT_SECRET=your-jwt-secret-key

# Server
PORT=3001
RUST_LOG=info
\`\`\`

## Testing

Run the test suite:
\`\`\`bash
cargo test
\`\`\`

Run integration tests:
\`\`\`bash
cargo test --test integration
\`\`\`

## Deployment

### Docker

1. Build the image:
   \`\`\`bash
   docker build -t ${context.projectName.toLowerCase()}-backend .
   \`\`\`

2. Run the container:
   \`\`\`bash
   docker run -p 3001:3001 \\
     -e DATABASE_URL=your-db-url \\
     ${context.projectName.toLowerCase()}-backend
   \`\`\`

### Production

1. Build for release:
   \`\`\`bash
   cargo build --release
   \`\`\`

2. Run migrations:
   \`\`\`bash
   sqlx migrate run
   \`\`\`

3. Start the server:
   \`\`\`bash
   ./target/release/${context.projectName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}
   \`\`\`

## Performance

- **Memory Safe**: Zero-cost abstractions with compile-time guarantees
- **Async Runtime**: Tokio for high-concurrency I/O
- **Connection Pooling**: SQLx connection pool for database efficiency
- **Compile-time SQL**: SQLx checks SQL queries at compile time

## Security

- **JWT Verification**: Supabase JWT token validation
- **SQL Injection Protection**: Parameterized queries with SQLx
- **CORS Configuration**: Configurable cross-origin resource sharing
- **Environment Variables**: Secure configuration management

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Run the test suite
6. Submit a pull request

## License

${context.license || 'MIT'}
`;
  }

  // Public API methods
  public getTemplate(id: string): FrameworkStackTemplate | undefined {
    return this.templates.get(id);
  }

  public getAllTemplates(): FrameworkStackTemplate[] {
    return Array.from(this.templates.values());
  }

  public getTemplatesByCategory(category: string): FrameworkStackTemplate[] {
    return Array.from(this.templates.values()).filter(template => template.category === category);
  }

  public async scaffoldProject(templateId: string, context: TemplateContext, outputPath: string): Promise<void> {
    const template = this.getTemplate(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }

    console.log(`üöÄ Scaffolding ${template.name} project...`);
    
    // Create project structure
    await this.createProjectStructure(template, context, outputPath);
    
    // Generate configuration files
    await this.generateConfigurationFiles(template, context, outputPath);
    
    // Install dependencies
    await this.installDependencies(template, outputPath);
    
    // Run post-installation steps
    await this.runPostInstallationSteps(template, outputPath);
    
    console.log(`‚úÖ Project ${context.projectName} scaffolded successfully!`);
  }

  private async createProjectStructure(template: FrameworkStackTemplate, context: TemplateContext, outputPath: string): Promise<void> {
    // Implementation for creating directory structure and files
    // This would create all directories and files defined in the template
  }

  private async generateConfigurationFiles(template: FrameworkStackTemplate, context: TemplateContext, outputPath: string): Promise<void> {
    // Implementation for generating configuration files
    // This would process templated files with the context
  }

  private async installDependencies(template: FrameworkStackTemplate, outputPath: string): Promise<void> {
    // Implementation for installing dependencies based on package managers
    // This would run npm install, cargo build, etc.
  }

  private async runPostInstallationSteps(template: FrameworkStackTemplate, outputPath: string): Promise<void> {
    // Implementation for running post-installation commands
    // This would run the installation steps defined in the template
  }
}

// Export singleton instance
export const advancedFrameworkScaffolder = new AdvancedFrameworkScaffolder();